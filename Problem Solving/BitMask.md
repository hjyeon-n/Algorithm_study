# BitMask 👻

### 비트가 뭐였더라? 🤔

컴퓨터에서 사용되는 데이터의 최소 단위 (0, 1)

흔히 말해 이진법이고 10을 이진법으로 구하면 1010이 된다는 건 기본! 😉

<br>

### 그러면 비트 마스크는 무엇이고 왜 쓰는 거지? 😕

비트마스크는 **정수의 이진수 표현을 활용한 기법!** 아래 사진은 비트마스크의 예시 중 AND 연산이다.

![image](https://user-images.githubusercontent.com/62419307/92944905-88bfe700-f48f-11ea-91f5-70812b33058a.png)

비트 마스크를 사용하면...

1. DP나 순열 등 배열 활용만으로 힘든 문제에서 사용할 수 있음
2. 부분 집합을 구할 때 사용 가능
3. 작은 메모리와 빠른 수행시간으로 해결이 가능
4. 집합을 배열의 인덱스로 표현 가능
5. 코드가 간결해짐

<br>

예를 들어보자. 길이가 5인 집합 { 0, 1, 2, 3, 4 } 가 존재한다고 가정해 보자. 

여기서 몇 가지 요소를 뽑아 어떤 요소를 선택했는지 표현할 수 있다.

즉, 집합의 어떤 요소를 구성하고 있는 지를 나타내는 부분집합을 어떻게 표현할까? 😎 

```
{ 1, 2, 3, 4 }, { 1, 2, 4 }, { 2, 4 }, { 1 } . . .
```

이와 같은 형태로 인덱스를 활용하면

```
int[] array1 = [1, 1, 1, 1, 0]; int[] array2 = [1, 1, 0, 1, 0]; int[] array3 = [1, 0, 1, 0, 0];
```

이처럼 표현할 수 있고, 1 또는 0으로 나타낼 수 있다는 건...? 그렇다! 바로 비트를 이용해서 풀 수 있다는 것이다! 🙆‍♀️

비트 마스크를 이용하면

```
{ 0, 1, 2, 3, 4 } → 11111 : 31
{ 1, 2, 3, 4 } → 11110 : 30
{ 1, 2, 4 } → 10110 : 22
{ 2, 4 } → 10100 : 20
{ 1 } → 00010 : 2
```

이렇게 이진수로 나타낸 뒤 다시 십진수로 변환하면, 배열이 아닌 정수를 통해 나타낼 수 있다.

즉, 20 이란 정수는 부분집합 { 2, 4 } 를 나타내는 것을 의미한다. 

{ 2, 4 } 부분집합에서 i를 추가하고 싶으면, 단순히 i번째 비트의 값을 1로 변경해 주면 된다. 🧐

이러한 삽입, 삭제, 조회 등은 비트 연산을 통해 쉽게 제어할 수 있다.

<br>

### 비트 연산 🛠

**AND 연산(&)**

대응하는 두 비트가 모두 1일 때, 1을 반환.

> 1010 & 1111 = 1010

<br>

**OR 연산(|)**

대응하는 두 비트가 모두 1 또는 하나라도 1일 때, 1을 반환.

> 1010 | 1111 = 1111

 <br>

**XOR 연산(^)**

대응하는 두 비트가 서로 다르면 1을 반환.

> 1010 ^ 1111 = 0101

 <br>

**NOT 연산(~)**

비트의 값을 반전하여 반환.

> ~1010 = 0101

 <br>

**시프트(Shift) 연산(>>, <<)** 

왼쪽 또는 오른쪽으로 비트를 옮긴다.

> 00001010 << 2 = 101000 (왼쪽)
> 00001010 >> 2 = 000010  (오른쪽)

 <br>

왼쪽 시프트는 A * 2^B 를 의미하고, 오른쪽 시프트는 A / 2^B 를 의미한다.

```
0001 → 0010 → 0100 → 1000 : 1, 2, 4, 8 .....

1000 → 0100 → 0010 → 0001 : 8, 4, 2, 1 ..... 
```

(A + B) / 2 를 (A + B) >> 1 로 사용할 수도 있듯이 많은 곳에서 일반적인 사칙연산을 더 효율적으로 할 수 있다.

```java
// A&B 
for(int i = 0; i < len; i++) { 
	c[i] = a[i] == 1 && b[i] == 1 ? 1 : 0; 
} // a[i]가 1이고 b[i]가 1이면 c[i]가 1 아니면 0

// A|B 
for (int i = 0; i < len; i++) { 
    c[i] = a[i] == 1 || b[i] == 1 ? 1 : 0; 
} // a[i]가 1 또는 b[i]가 1이면 c[i]가 1 아니면 0

// A^B 
for (int i = 0; i < len; i++) { 
    c[i] = a[i] != b[i] ? 1 : 0; 
} // a[i]와 b[i]가 같지 않으면 c[i]가 1 아니면 0

// ~A 
for (int i = 0; i < len; i++) {
    c[i] = a[i] == 1 ? 0 : 1; 
} // a[i]가 1이면 c[i]가 0 아니면 1

// ~B 
for (int i = 0; i < len; i++) { 
    c[i] = b[i] == 1 ? 0 : 1; 
} // b[i]가 1이면 c[i]가 0 아니면 1
```

<br>

### 비트 삽입, 삭제, 조회 👀

#### 1. 비트 삽입

*1010 로 표현하고 있을 때, i번째 비트의 값을 1로 어떻게 변경할 수 있을까?*

i = 2 이라고 가정할 때, 결과는 1110 을 원한다.

2번째 비트를 1로 변경할 수 있는 방법은 다음과 같다.

 <br>

> 1010 | 1 << 2
> 1010 | 0100 → 1110

 <br>

시프트 연산을 통해 2번째 비트만 1로 할당되어 있는 이진수를 만든다.

그리고 **OR 연산**을 통해 원하는 결과를 만들 수 있다.

 <br>

#### 2. 비트 삭제

*반대로 2번째 비트의 값을 0로 어떻게 변경할 수 있을까?*

  <br>

> 1110 & ~1 << 2 <br>
> 1110 & 1011 → 1010

  <br>

**AND 연산**과 **NOT 연산**을 활용할 수 있다.

 <br>

#### 3. 비트 조회

*그리고 i번째 비트의 값을 알 수 있는 방법은 다음과 같다.*

  <br>

> A & (1 << i) <br>
> 2번째 비트 - 1010 & (1 << 2) = 1010 & 0100 → 0 <br>
> 3번째 비트 - 1010 & (1 << 3) = 1010 & 1000 → 1000

  <br>

**AND 연산**과 **시프트 연산**을 통해 i번째 비트의 값이 0이라면 값이 0이라는 것을 알 수 있다.

이렇게 비트를 활용한 테크닉을 통해 접근하는 것이 비트마스크다! 💃

<br>

[참고](https://mygumi.tistory.com/361)
# Back Tracking 🔍

| 문제 번호                                      | 이름                            |
| ---------------------------------------------- | ------------------------------- |
| [14889](https://www.acmicpc.net/problem/14889) | [스타트와 링크](#스타트와-링크) |
| [1038](https://www.acmicpc.net/problem/1038)   | [감소하는 수](#감소하는-수)     |

<br>

<hr>

#### #스타트와 링크

[스타트와 링크 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.09/Solution_14889)

삼성 SW 역량 테스트 기출 문제. 난이도는 실버3이었는데 체감은 실버1쯤이었다.

몸이 좋지 않아서 중간중간 쉬는 바람에 엄청나게 오랜 시간동안 문제를 풀었다. 😥

<br>

**ver 1 풀이 과정**

문제는 스타트와 링크라는 두 팀으로 나누고 각 팀의 능력치를 더한 후 능력치의 차가 최소가 되는 값을 구하면 된다.

두 팀으로 나누는 경우가 조합과 같았기 때문에 [N과 M (2)](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_15650.java)을 참고했다.

두 팀으로 나누고 나서 경험치를 더하는 과정은 순열로 구했다. (지금 생각해 보면 이미 ij와 ji의 합을 더했기 때문에 이 과정은 전혀 필요가 없었다... 왜 이렇게 풀었는지 의문...) 

N의 범위가 작아 시간초과를 피할 수 있었지만, 뭔가 깔끔하지 않기도 했고 시간도 다른 사람과 비교했을 때 꽤 많이 소요됐기 때문에 다른 사람의 코드를 참고해서 다시 풀었다.

<br>

**ver 2 풀이 과정**

1. 팀에 들어가는 사람을 정하기 위해 마찬가지로 조합을 사용했다. ver1(이미 스타트에 사람을 집어넣고, 후에 스타트 팀에 없는 사람을 링크팀에 넣는 방식)과 다르게 동시에 스타트와 링크 팀에 팀원들을 넣었다.

2. 능력치를 더하는 기능의 cal이라는 함수를 정의해 ij, ji의 능력치를 더했다.

   능력치를 더하는 과정도 조합과 같은 방식으로 이루어진다.

   예를 들어, 스타트 팀에 1, 2, 3이 속해있다고 하자. (코드에선 0, 1, 2가 된다.)

   나올 수 있는 경우의 수는 1, 2 / 1, 3 / 2, 3이 되고 각각을 뒤집어 2, 1 / 3, 1 / 3, 2를 구해 더해주면 된다.

   **경우의 수를 잘 보면 앞의 값보다 뒤에 있는 값이 크다.** 따라서 코드 상에서는 

   ```java
   for (int i = 0; i < arr.length; i++) {
   	for (int j = i + 1; j < arr.length; j++) {
   		x = arr[i]; 
   		y = arr[j];
   		sum += s[x][y] + s[y][x]; // Sij + Sji
   	}
   }
   ```

   이와 같이 나오게 된다.

3. 스타트와 링크의 cal의 반환값을 빼서 min에 저장되어있는 값과 비교해 더 작은 값을 min에 저장한다.

<br>

<hr>

#### #감소하는 수

[감소하는 수 소스 코드](https://www.acmicpc.net/problem/1038)

백트래킹으로 푼 건 아니지만... 문제 분류가 백트래킹이어서 일단은 백트래킹 풀이에 써놓는다.

처음엔 dp 문제가 아닐까 싶었다. 그래서 dp 배열을 이차원으로 해놓고 0부터 앞 자릿수 숫자보다 작을 때까지 하나씩 증가하면 되지 않을까했다. 예를 들어 dp[2] [0], dp[2] [1] 이런 식으로 말이다. 하지만 bottom-up으로 하자니 밑에서부터 쌓을 게 없었고 일단 N번째 숫자를 구해야 하기 때문에 적절해 보이지 않았다. 그리고 자릿수가 계속 증가하기 때문에 이차원 배열로 두는 것도 문제가 있을 것 같았다.

<br>

규칙을 하나 찾아내긴 했다. 앞자리 수가 어떤 수가 오든 간에 뒷자리 수들은 중복이 된다는 점이다.

예를 들어 20, 21이 감소하는 수라면 세 자리 수라고 생각했을 때 앞의 자릿수가 3이 오더라도 320 321이 될 것이고,

4가 오더라도 420 421 이 올 수 있다.  하지만 이후로는 더 생각이 나지 않았고 다른 분의 풀이를 참고했다. 😥

<br>

한 자릿수에 올 수 있는 경우의 수는 0부터 9까지이다. 따라서 자릿수가 2 이상인 수들은 10으로 나눈 나머지를 생각하면 된다.

수를 저장하는 자료구조로 큐를 사용했고, 큐에서 뽑아냈을 때는 수가 감소하는지만 따지면 되기 때문에 10으로 나눈 나머지 (즉 일의 자릿수만 나오게 된다)를 이용해 0부터 그 수보다 작은 경우까지 경우의 개수를 세는 과정을 거치는 게 알고리즘의 핵심이었다.

정리하자면,

1. N(내 코드에서는 num)이 9 이하라면 N값을 출력한다. (0은 0번째, 1은 1번째, 2는 2번째... 순으로 가기 때문)

2. 감소하는 수로 나올 수 있는 최댓값은 9876543210이다. 이 수는 1022번째 수이기 때문에 1023부터는 -1을 출력하면 된다.

   사실 나는 다들... 어떻게 1022번째 수인 걸 아는 거지? 😦 궁금했다... ~~왜 나만 몰라...😭~~

   찾아봤더니 감소하는 수의 총수는 10개 중에 k개를 구하는 경우의 수의 합이기 때문이다!

   ![image](https://user-images.githubusercontent.com/62419307/93068513-8b048a00-f6b7-11ea-9b35-8ce56702284d.png)

3. 큐를 선언하고 1부터 9까지 큐에 넣어준다. 물론, 이 경우도 N에 들어가기 때문에 cnt를 증가시켜준다.

4. 큐가 빌 때까지 큐에서 수를 하나 뽑아낸 뒤, 한 자릿수에 올 수 있는 수만 생각하면 되기 때문에 10을 나눈 나머지를 tmp에 저장한다.

5. 감소하는 수를 구하는 것이기 때문에 다음 자릿수에 올 수 있는 수는 0부터 tmp보다 작은 수이다. 반복문을 돌면서 **tmp * 10** (다음 자릿수를 만들어주기 위해) **+ i** (다음 자릿수에 올 수 있는 수를 구하는 반복인자)를 큐에 넣고 cnt를 증가한다.

6. cnt가 N이 되면 더이상 볼 필요가 없으므로 **tmp * 10 + i**을 출력하고 끝내주면 된다.


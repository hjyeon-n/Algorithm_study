# Dynamic Programming

| 문제 번호 | 문제 이름                                                 |
| --------- | --------------------------------------------------------- |
| 2293      | [동전 1](#동전-1)                                         |
| 2294      | [동전 2](#동전-2)                                         |
| 11054     | [가장 긴 바이토닉 부분 수열](#가장-긴-바이토닉-부분-수열) |

<br>

<hr>

#### #동전 1

[동전 1 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_2293.java)

아주 오래 전에 시도했다가 포기했던 문제였는데 갑자기 도전하고 싶은 마음이 생겨 풀게 됐다.

처음엔 dp[i] i원을 만들기 위한 방법의 수라고 생각해서 접근했다.

```
n = 3, k = 10, 주어진 동전의 가치는 1, 2, 5이다.
```

dp[0] = 1이고,

dp[1]은 1원으로 만들기 위한 방법의 수이므로 1원의 동전을 하나 사용해서 만들 수 있기 때문에 1

dp[2]는 1원의 동전 2개, 2원의 동전 1개를 사용할 수 있으므로 2

dp[3]은 1원 동전 3개, 2원 동전 1개와 1원 동전 1개로 만들 수 있으므로 2

dp[4]는 1원 동전 4개, 2원 동전 2개, 2원 동전 1개와 1원 동전 2개로 만들 수 있으므로 3...

이런 식으로 손으로 하나하나 풀었다.

자세히 보니 규칙이 있어서 dp[4] = dp[3] + dp[1] 이런 식으로 점화식이 나오는 건가 했는데 더 전개하다가 아니라는 것을 알았다.

조금만 더 생각 하면 알 것 같았는데 그 조금이 항상 어려워서 결국 다른 사람의 풀이를 참고했다. 

<br>

> dp[j] += dp[j - coin[i]]

규칙을 찾아보면 이 점화식이 나온다고 하던데 나로서는 도저히 이해가 힘들어서😇... 좀 더 시간을 투자해서 많은 사람들의 풀이를 봤다. 약간 이해가 됐을 때 빠르게 정리해야지... ✍

<br>

동전의 가치는 예제를 참고했다.

coin[]은 동전의 가치를 나타낸 배열, dp[i]는 i원을 만들기 위한 동전의 수라고 생각하면 된다.

dp[0]은 동전을 아예 사용하지 않은 경우이기 때문에 1로 초기화한다. 나머지는 표로 보면 더 쉽다.

<br>

**1원의 동전만 사용했을 때**

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |

엥 왜 1이지..? 하고 고민하고 있을지도 모르는 미래의 나를 위해 정리하자면,

예를 들어, 2는 1원의 동전을 2개 사용해서 만들 수 있고 그 방법이 유일하기 때문에 1이다.

<br>

**2원의 동전까지 사용했을 때**

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 2    | 3    | 3    | 4    | 4    | 5    | 5    | 6    |

4원의 가치를 만들기 위해서는 1원 동전 4개, 2원 동전 2개, 2원 동전 1개와 1원 동전 2개로 만들 수 있으므로 방법의 수는 3이다.

즉, An += (An - 2)다. 이게 또 무슨 뜬금 없는 소리냐 하겠지만...

An - 2는 2원으로 n을 만들 수 있는 경우의 수라고 생각하면 좀 낫다. 2원을 사용하지 않고 10을 만들려고 한다면 1원으로만 10을 만들어야 한다. 하지만 2원까지 사용한다면, 8만 만들면 되는 것이다. 따라서 이를 일반화하면 An -2 가 된다.

<br>

**5원의 동전까지 사용했을 때**

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 10   |

5원보다 크기가 작은 1, 2, 3, 4원은 5원의 동전을 사용할 수 없기 때문에 경우의 수는 2원의 동전까지 사용했을 때와 똑같다.

5원부터는 5원을 사용할 수 있는 경우가 생겨 변동이 생길 것이다. 

5원의 가치를 만들기 위해서 2원의 동전까지 사용했을 때 1원 동전 5개, 2원 동전 2개와 1원 동전 1개, 2원 동전 1개와 1원 동전 3개를 사용할 수 있었다면, 5원까지 사용할 수 있다면 5원 1개를 통해서도 만들 수 있기 때문의 방법의 수는 4로, 1만큼 증가하게 된다.

즉, An += (An - 5)의 식을 도출할 수 있다.

<br>

이 모든 과정을 통해 결국 An = (An - 1) + (An - 2) + (An - 5)가 나온다. 

동전의 가치는 가변적이기 때문에 좀 더 일반화해야 한다. 

이때 **동전의 수는 n**, **가치는 k**이고 dp[k]는 n가지의 동전을 사용하는 경우의 수가 아니라 **1부터 n까지의 동전을 사용해서 k원을 만들 수 있는 경우의 수**이기 때문에 (즉, dp[8]은 동전 1, 2, 5를 적당히 합해 8로 만드는 경우의 수다.)  

동전의 수만큼 돌면서 (즉, 사용할 수 있는 동전을 점차 늘려가면서) dp 배열을 채우면 된다.

결국, 이전에 말했던 것처럼 최종 점화식은 이와 같다.

```
dp[j] += dp[j - coin[i]]
```

[참고](https://dundung.tistory.com/125)

<br>

<hr>

#### #동전 2

동전 1과 비슷한 문제지만, 이번에는 경우의 수가 아니라 동전의 촤소 개수를 구해야 한다.

동전 1처럼 표를 그려서 점화식을 생각하려고 했고, 처음에는 나눗셈 연산으로 점화식으로 만들려고 했다.

```
n = 3, k = 15, 주어진 동전의 가치는 1, 5, 12이다.
```

최솟값을 구하는 문제이기 때문에 dp 배열을 최댓값인 Integer.MAX_VALUE로 초기화하고, 

j % coin[i] == 0일 때, dp[j에 dp[j]의 값과 j % coin[i] 값을 비교한 후 작은 값을 넣어주었다.

하지만 6 같은 경우에는 나머지 연산으로 나누어 떨어지진 않지만, 1원 하나와 5원 하나로 만들 수 있으므로 값은 2가 돼야 하는데 이 식으로는 도저히 이를 표현할 수 없었다...

다른 방법을 찾아 보니 동전의 개수를 누적시키면서 최소를 구분하면 된다고 하길래 식을 고쳤다.

```
dp[j] = Math.min(dp[i], dp[j - coin[i]] + 1);
```

마찬가지로 표를 보면서 차근차근 확인해 보자.

0원으로 만들기 위해서는 동전을 사용하지 말아야 하기 때문에 dp[0] = 0이다.

또, dp 배열을 최댓값인 Integer.MAX_VALUE로 초기화했었는데 Integer.MAX_VALUE는 말 그대로 최댓값이기 때문에 1을 더하면 오버플로우가 발생하기 때문에 문제의 조건에 주어진 동전의 가치 100000보다 1이 더 큰 1000001으로 초기화해야 한다.

<br>

**1원의 동전만 사용했을 때**

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |

예를 들어, 8원을 만들기 위해서는 1원 동전 8개가 필요하고 이는 1000001로 초기화되어있던 dp[1]보다 작은 값이기 때문에 8로 바뀐다.

<br>

**5원의 동전까지 사용했을 때**

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 3    | 4    | 1    | 2    | 3    | 4    | 5    | 2    | 3    | 4    | 5    | 6    | 3    |

동전1 문제와 마찬가지로 5보다 작은 값은 신경쓰지 않고 5 이상의 수만 신경쓰면 된다.

예를 들어, 5원의 경우엔 1원 5개보다 5원 1개가 최소의 개수이기 때문에 1로 넣어준다.

식으로 살펴보면 dp[5] = Math.min(dp[5], dp[5 - coin[1]] + 1) 이때, coin[1]이 5이기 때문에 dp[5]와 dp[0] + 1을 비교해야 한다.

여기서 왜 + 1을 해주냐고 한다면 동전의 수를 증가하기 위해서이다.

더 구체적으로 말하자면 동전의 가치가 K원보다 작다면 필연적으로 dp[j - coin[i]]가 dp[0]이 되고, 

dp[0]은 0이기 때문에 동전의 개수를 늘리기 위해 +1을 해준다고 생각하자. ☺

(그래도 어려우면... 합 K에서 5원만큼 빼주면 K - 5가 되는데, K - 5를 만들기 위한 동전의 수에 5원을 하나 사용했기 때문에 +1 이라고 생각하면 된다.)

그러면 dp[5]는 dp[0] + 1 즉, 1이 된다.

<br>

**12원의 동전까지 사용했을 때**

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 3    | 4    | 1    | 2    | 3    | 4    | 5    | 2    | 3    | 1    | 2    | 3    | 3    |

12부터 신경쓰면 되고, 12의 경우 12원 동전 1개만 쓰면 되기 때문에 1로 바뀐다.

위의 과정처럼 마찬가지로 예를 들어 K가 13이라고 하자.

이미 12원의 동전을 썼다고 가정하면 동전의 수는 1이 되는데 나머지 1원을 채우기 위해서는 dp[1]만큼 더해주면 된다.

그러면 dp[13] = 2가 된다.

<br>

<hr>

#### #가장 긴 바이토닉 부분 수열

[가장 긴 바이토닉 부분 수열 소스 코드]()

대충 [가장 긴 증가하는 부분 수열](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11053.java), [가장 긴 감소하는 부분 수열](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11722.java)이랑 유사한 문제인 건 알았는데 중간에 꺾이는 부분(증가하다가 감소하는 부분)을 어떻게 잡아야 할 지 몰라서 고민했었다.

1. 가장 긴 증가하는 부분 수열의 끝지점부터 감소하는 부분 수열을 하면 되나?

   ```
   10
   10 1 3 5 7 6 3 2 1 10
   ```

   실제 답은 8이지만 1번과 같은 논리로는 5가 됨

2. 가장 긴 증가하는 부분 수열의 길이와 감소하는 부분 수열의 길이를 더한 후 최댓값을 출력하면 되나?

   ```
   10
   10 1 3 5 7 6 3 2 1 10
   ```

   마찬가지로 실제 답은 8이지만 2번과 같은 논리로는 7이 됨

<br>

거의 답에 근거한 논리를 찾아내다가 얼떨결에 답을 봐버렸다... 😥

**왼쪽에서 오른쪽으로 진행하는 LIS(가장 긴 증가하는 수열) + 오른쪽에서 왼쪽으로 진행하는 LIS를 더한 뒤 -1을 해주면 된다.**

두 가지 경우가 있기 때문에 dp 배열을 이차원 배열로 선언한 뒤 dp[x] [0]은 첫 번째 경우, dp[x] [1]은 두 번째 경우를 고려한다.

표를 통해서 차근차근 살펴보자. ☺

```
10
1 5 2 1 4 3 4 5 2 1
```

<br>

왼쪽에서 오른쪽으로 가장 긴 증가하는 부분 수열

| 1    | 5    | 2    | 1    | 4    | 3    | 4    | 5    | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 2    | 1    | 3    | 3    | 4    | 5    | 2    | 1    |

이 값들을 dp[x] [0]에 넣는다.

<br>

오른쪽에서 왼쪽으로 가장 긴 증가하는 부분 수열

| 1    | 5    | 2    | 1    | 4    | 3    | 4    | 5    | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 5    | 1    | 1    | 4    | 3    | 3    | 3    | 2    | 1    |

이 값들을 dp[x] [1]에 넣는다.

<br>

dp 배열의 값들을 더해주면서 최댓값을 구한다.

| 1    | 5    | 2    | 1    | 4    | 3    | 4    | 5    | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 2    | 1    | 3    | 3    | 4    | 5    | 2    | 1    |
| 1    | 5    | 2    | 1    | 4    | 3    | 3    | 3    | 2    | 1    |
| 2    | 7    | 4    | 2    | 7    | 6    | 7    | 8    | 4    | 2    |

두 가지 경우의 LIS를 구하면서 1이 중복되기 때문에 (왜냐면 기본 길이가 1이기 때문에) 최댓값에서 1을 빼주면 된다.

<br>

바이토닉 수열은 증가하다가 감소하는 수열이기 때문에 그 길이를 최대로 하기 위해서는 왼쪽에서 LIS, 오른쪽에서의 LIS를 합한 최댓값이 그 변곡점이 된다는 점은 잘 알겠는데 왜 가장 긴 감소하는 부분 수열로는 안 되는지 생각을 더 해 봤다.

가장 긴 증가/감소하는 부분 수열은 1에서부터 i까지 증가/감소하는 부분이어야 한다. 즉, 그림이 이렇게 그려진다.

![image](https://user-images.githubusercontent.com/62419307/93017835-aebbc780-f606-11ea-8269-bb357a01c588.png)

<br>

양쪽으로 LIS를 구해야 겹치는 점이 생겨 '변곡점'이 생기게 된다.

![image](https://user-images.githubusercontent.com/62419307/93017921-4f11ec00-f607-11ea-8d8b-5ac69e417559.png)

<br>

예전과 달리 왜 그럴까 더 생각해 보는 습관을 기르고 있는데 좋은 방법인 것 같다! 😉






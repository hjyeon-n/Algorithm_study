# Dynamic Programming

| 문제 번호 | 문제 이름                               |
| ----- | ----------------------------------- |
| 2293  | [동전 1](#동전-1)                       |
| 2294  | [동전 2](#동전-2)                       |
| 11054 | [가장 긴 바이토닉 부분 수열](#가장-긴-바이토닉-부분-수열) |
| 5582  | [공통 부분 문자열](#공통-부분-문자열)             |
| 9252  | [LCS 2](#LCS-2)                     |
| 1699  | [제곱수의 합](#제곱수의-합)                   |
| 14719 | [빗물](#빗물)                           |

<br>

<hr>

#### #동전 1

[동전 1 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_2293.java)

아주 오래 전에 시도했다가 포기했던 문제였는데 갑자기 도전하고 싶은 마음이 생겨 풀게 됐다.

처음엔 dp[i] i원을 만들기 위한 방법의 수라고 생각해서 접근했다.

```
n = 3, k = 10, 주어진 동전의 가치는 1, 2, 5이다.
```

dp[0] = 1이고,

dp[1]은 1원으로 만들기 위한 방법의 수이므로 1원의 동전을 하나 사용해서 만들 수 있기 때문에 1

dp[2]는 1원의 동전 2개, 2원의 동전 1개를 사용할 수 있으므로 2

dp[3]은 1원 동전 3개, 2원 동전 1개와 1원 동전 1개로 만들 수 있으므로 2

dp[4]는 1원 동전 4개, 2원 동전 2개, 2원 동전 1개와 1원 동전 2개로 만들 수 있으므로 3...

이런 식으로 손으로 하나하나 풀었다.

자세히 보니 규칙이 있어서 dp[4] = dp[3] + dp[1] 이런 식으로 점화식이 나오는 건가 했는데 더 전개하다가 아니라는 것을 알았다.

조금만 더 생각 하면 알 것 같았는데 그 조금이 항상 어려워서 결국 다른 사람의 풀이를 참고했다. 

<br>

> dp[j] += dp[j - coin[i]]

규칙을 찾아보면 이 점화식이 나온다고 하던데 나로서는 도저히 이해가 힘들어서😇... 좀 더 시간을 투자해서 많은 사람들의 풀이를 봤다. 약간 이해가 됐을 때 빠르게 정리해야지... ✍

<br>

동전의 가치는 예제를 참고했다.

coin[]은 동전의 가치를 나타낸 배열, dp[i]는 i원을 만들기 위한 동전의 수라고 생각하면 된다.

dp[0]은 동전을 아예 사용하지 않은 경우이기 때문에 1로 초기화한다. 나머지는 표로 보면 더 쉽다.

<br>

**1원의 동전만 사용했을 때**

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |

엥 왜 1이지..? 하고 고민하고 있을지도 모르는 미래의 나를 위해 정리하자면,

예를 들어, 2는 1원의 동전을 2개 사용해서 만들 수 있고 그 방법이 유일하기 때문에 1이다.

<br>

**2원의 동전까지 사용했을 때**

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 2   | 2   | 3   | 3   | 4   | 4   | 5   | 5   | 6   |

4원의 가치를 만들기 위해서는 1원 동전 4개, 2원 동전 2개, 2원 동전 1개와 1원 동전 2개로 만들 수 있으므로 방법의 수는 3이다.

즉, An += (An - 2)다. 이게 또 무슨 뜬금 없는 소리냐 하겠지만...

An - 2는 2원으로 n을 만들 수 있는 경우의 수라고 생각하면 좀 낫다. 2원을 사용하지 않고 10을 만들려고 한다면 1원으로만 10을 만들어야 한다. 하지만 2원까지 사용한다면, 8만 만들면 되는 것이다. 따라서 이를 일반화하면 An -2 가 된다.

<br>

**5원의 동전까지 사용했을 때**

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 2   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 10  |

5원보다 크기가 작은 1, 2, 3, 4원은 5원의 동전을 사용할 수 없기 때문에 경우의 수는 2원의 동전까지 사용했을 때와 똑같다.

5원부터는 5원을 사용할 수 있는 경우가 생겨 변동이 생길 것이다. 

5원의 가치를 만들기 위해서 2원의 동전까지 사용했을 때 1원 동전 5개, 2원 동전 2개와 1원 동전 1개, 2원 동전 1개와 1원 동전 3개를 사용할 수 있었다면, 5원까지 사용할 수 있다면 5원 1개를 통해서도 만들 수 있기 때문의 방법의 수는 4로, 1만큼 증가하게 된다.

즉, An += (An - 5)의 식을 도출할 수 있다.

<br>

이 모든 과정을 통해 결국 An = (An - 1) + (An - 2) + (An - 5)가 나온다. 

동전의 가치는 가변적이기 때문에 좀 더 일반화해야 한다. 

이때 **동전의 수는 n**, **가치는 k**이고 dp[k]는 n가지의 동전을 사용하는 경우의 수가 아니라 **1부터 n까지의 동전을 사용해서 k원을 만들 수 있는 경우의 수**이기 때문에 (즉, dp[8]은 동전 1, 2, 5를 적당히 합해 8로 만드는 경우의 수다.)  

동전의 수만큼 돌면서 (즉, 사용할 수 있는 동전을 점차 늘려가면서) dp 배열을 채우면 된다.

결국, 이전에 말했던 것처럼 최종 점화식은 이와 같다.

```
dp[j] += dp[j - coin[i]]
```

[참고](https://dundung.tistory.com/125)

<br>

<hr>

#### #동전 2

동전 1과 비슷한 문제지만, 이번에는 경우의 수가 아니라 동전의 촤소 개수를 구해야 한다.

동전 1처럼 표를 그려서 점화식을 생각하려고 했고, 처음에는 나눗셈 연산으로 점화식으로 만들려고 했다.

```
n = 3, k = 15, 주어진 동전의 가치는 1, 5, 12이다.
```

최솟값을 구하는 문제이기 때문에 dp 배열을 최댓값인 Integer.MAX_VALUE로 초기화하고, 

j % coin[i] == 0일 때, dp[j에 dp[j]의 값과 j % coin[i] 값을 비교한 후 작은 값을 넣어주었다.

하지만 6 같은 경우에는 나머지 연산으로 나누어 떨어지진 않지만, 1원 하나와 5원 하나로 만들 수 있으므로 값은 2가 돼야 하는데 이 식으로는 도저히 이를 표현할 수 없었다...

다른 방법을 찾아 보니 동전의 개수를 누적시키면서 최소를 구분하면 된다고 하길래 식을 고쳤다.

```
dp[j] = Math.min(dp[i], dp[j - coin[i]] + 1);
```

마찬가지로 표를 보면서 차근차근 확인해 보자.

0원으로 만들기 위해서는 동전을 사용하지 말아야 하기 때문에 dp[0] = 0이다.

또, dp 배열을 최댓값인 Integer.MAX_VALUE로 초기화했었는데 Integer.MAX_VALUE는 말 그대로 최댓값이기 때문에 1을 더하면 오버플로우가 발생하기 때문에 문제의 조건에 주어진 동전의 가치 100000보다 1이 더 큰 1000001으로 초기화해야 한다.

<br>

**1원의 동전만 사용했을 때**

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |

예를 들어, 8원을 만들기 위해서는 1원 동전 8개가 필요하고 이는 1000001로 초기화되어있던 dp[1]보다 작은 값이기 때문에 8로 바뀐다.

<br>

**5원의 동전까지 사용했을 때**

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 2   | 3   | 4   | 1   | 2   | 3   | 4   | 5   | 2   | 3   | 4   | 5   | 6   | 3   |

동전1 문제와 마찬가지로 5보다 작은 값은 신경쓰지 않고 5 이상의 수만 신경쓰면 된다.

예를 들어, 5원의 경우엔 1원 5개보다 5원 1개가 최소의 개수이기 때문에 1로 넣어준다.

식으로 살펴보면 dp[5] = Math.min(dp[5], dp[5 - coin[1]] + 1) 이때, coin[1]이 5이기 때문에 dp[5]와 dp[0] + 1을 비교해야 한다.

여기서 왜 + 1을 해주냐고 한다면 동전의 수를 증가하기 위해서이다.

더 구체적으로 말하자면 동전의 가치가 K원보다 작다면 필연적으로 dp[j - coin[i]]가 dp[0]이 되고, 

dp[0]은 0이기 때문에 동전의 개수를 늘리기 위해 +1을 해준다고 생각하자. ☺

(그래도 어려우면... 합 K에서 5원만큼 빼주면 K - 5가 되는데, K - 5를 만들기 위한 동전의 수에 5원을 하나 사용했기 때문에 +1 이라고 생각하면 된다.)

그러면 dp[5]는 dp[0] + 1 즉, 1이 된다.

<br>

**12원의 동전까지 사용했을 때**

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 2   | 3   | 4   | 1   | 2   | 3   | 4   | 5   | 2   | 3   | 1   | 2   | 3   | 3   |

12부터 신경쓰면 되고, 12의 경우 12원 동전 1개만 쓰면 되기 때문에 1로 바뀐다.

위의 과정처럼 마찬가지로 예를 들어 K가 13이라고 하자.

이미 12원의 동전을 썼다고 가정하면 동전의 수는 1이 되는데 나머지 1원을 채우기 위해서는 dp[1]만큼 더해주면 된다.

그러면 dp[13] = 2가 된다.

<br>

<hr>

#### #가장 긴 바이토닉 부분 수열

[가장 긴 바이토닉 부분 수열 소스 코드]()

대충 [가장 긴 증가하는 부분 수열](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11053.java), [가장 긴 감소하는 부분 수열](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11722.java)이랑 유사한 문제인 건 알았는데 중간에 꺾이는 부분(증가하다가 감소하는 부분)을 어떻게 잡아야 할 지 몰라서 고민했었다.

1. 가장 긴 증가하는 부분 수열의 끝지점부터 감소하는 부분 수열을 하면 되나?
   
   ```
   10
   10 1 3 5 7 6 3 2 1 10
   ```
   
   실제 답은 8이지만 1번과 같은 논리로는 5가 됨

2. 가장 긴 증가하는 부분 수열의 길이와 감소하는 부분 수열의 길이를 더한 후 최댓값을 출력하면 되나?
   
   ```
   10
   10 1 3 5 7 6 3 2 1 10
   ```
   
   마찬가지로 실제 답은 8이지만 2번과 같은 논리로는 7이 됨

<br>

거의 답에 근거한 논리를 찾아내다가 얼떨결에 답을 봐버렸다... 😥

**왼쪽에서 오른쪽으로 진행하는 LIS(가장 긴 증가하는 수열) + 오른쪽에서 왼쪽으로 진행하는 LIS를 더한 뒤 -1을 해주면 된다.**

두 가지 경우가 있기 때문에 dp 배열을 이차원 배열로 선언한 뒤 dp[x] [0]은 첫 번째 경우, dp[x] [1]은 두 번째 경우를 고려한다.

표를 통해서 차근차근 살펴보자. ☺

```
10
1 5 2 1 4 3 4 5 2 1
```

<br>

왼쪽에서 오른쪽으로 가장 긴 증가하는 부분 수열

| 1   | 5   | 2   | 1   | 4   | 3   | 4   | 5   | 2   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 2   | 2   | 1   | 3   | 3   | 4   | 5   | 2   | 1   |

이 값들을 dp[x] [0]에 넣는다.

<br>

오른쪽에서 왼쪽으로 가장 긴 증가하는 부분 수열

| 1   | 5   | 2   | 1   | 4   | 3   | 4   | 5   | 2   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 5   | 1   | 1   | 4   | 3   | 3   | 3   | 2   | 1   |

이 값들을 dp[x] [1]에 넣는다.

<br>

dp 배열의 값들을 더해주면서 최댓값을 구한다.

| 1   | 5   | 2   | 1   | 4   | 3   | 4   | 5   | 2   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 2   | 2   | 1   | 3   | 3   | 4   | 5   | 2   | 1   |
| 1   | 5   | 2   | 1   | 4   | 3   | 3   | 3   | 2   | 1   |
| 2   | 7   | 4   | 2   | 7   | 6   | 7   | 8   | 4   | 2   |

두 가지 경우의 LIS를 구하면서 1이 중복되기 때문에 (왜냐면 기본 길이가 1이기 때문에) 최댓값에서 1을 빼주면 된다.

<br>

바이토닉 수열은 증가하다가 감소하는 수열이기 때문에 그 길이를 최대로 하기 위해서는 왼쪽에서 LIS, 오른쪽에서의 LIS를 합한 최댓값이 그 변곡점이 된다는 점은 잘 알겠는데 왜 가장 긴 감소하는 부분 수열로는 안 되는지 생각을 더 해 봤다.

가장 긴 증가/감소하는 부분 수열은 1에서부터 i까지 증가/감소하는 부분이어야 한다. 즉, 그림이 이렇게 그려진다.

![image](https://user-images.githubusercontent.com/62419307/93017835-aebbc780-f606-11ea-8269-bb357a01c588.png)

<br>

양쪽으로 LIS를 구해야 겹치는 점이 생겨 '변곡점'이 생기게 된다.

![image](https://user-images.githubusercontent.com/62419307/93017921-4f11ec00-f607-11ea-8d8b-5ac69e417559.png)

<br>

예전과 달리 왜 그럴까 더 생각해 보는 습관을 기르고 있는데 좋은 방법인 것 같다! 😉

<br>

<hr>

#### #공통 부분 문자열

[공통 부분 문자열 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_5582.java)

[LCS](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_9251.java)랑 비슷한 문제. 기본 알고리즘은 동일하지만, 이 문제는 연속으로 공통돼야 한다.

LCS 문제에서는 

1. str_x와 str_y의 공통부분이 생기면  c[i - 1] [j - 1] 값에 1을 더한 뒤 c[i] [j]에 넣는다.
2. 같지 않으면, 값을 비우고 넘어가는 게 아니라 c[i] [j]에 표의 윗칸 즉, c[i - 1] [j]와 바로 옆칸 c[i] [j - 1] 중 최댓값을 넣는다.

구체적인 풀이는 [여기](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.07/Dynamic%20Programming.md#LCS)에서 확인하면 된다.

<br>

공통 부분 문자열은 '연속'이기 때문에 2번과 같은 경우를 변형해 주어야 한다. 마찬가지로 표를 통해 확인해 보자.

|       | T   | H   | E   | N   |
| ----- | --- | --- | --- | --- |
| **T** | 1   | 0   | 0   | 0   |
| **H** | 0   | 2   | 0   | 0   |
| **A** | 0   | 0   | 0   | 0   |
| **N** | 0   | 0   | 0   | 0   |

str_x와 str_y의 공통부분이 생기면 LCS 문제 처럼 c[i] [j] = c[i - 1] [j - 1] + 1을 해주면 된다.

이를 위해 반복문을 1부터 돌려야 하고 배열의 크기도 str의 길이보다 하나 더 크게 잡아주어야 한다.

만약 공통부분이 연속적으로 이루어지지 않는 경우, 값을 채우지 않고 넘어간다. 

단, **최장 길이를 구해야 하기 때문에 max를 따로 선언해 c[i] [j]와 max를 비교해 더 큰 값으로 초기화하는 과정이 필요하다.**

따라서 최댓값은 2로 정답은 2가 된다.

<br>

<hr>

#### #LCS 2

[LCS 2 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_9252.java)

역시나 [LCS](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_9251.java)랑 비슷한 문제. 이번에는 공통 문자열도 출력해야 한다는 차이점이 있다.

나는 문자열 변수 str를 선언해 공통 문자열이 발생했을 때, 즉, x[i]와 y[j]가 같을 때 str += x[i]로 공통문자열을 표시하려고 했다.

하지만 중첩 반복문을 돌면서 x[i]와 y[j]가 같을 때가 많아졌고 같은 문자가 중복되는 경우가 생겨 flag 변수를 만들어 중복 여부를 파악하려고 했다. 그래도 계속 틀렸다... 😫

찬찬히 살펴보니 틀린 점을 찾아냈다. 예를 들어 ABCA와 BACA가 있으면 실제 답은 BCA지만 내 코드 상으로는 ABC가 됐다. 

즉, 공통 문자열이 str_y를 역전(?) 하는 현상이 생겼고 이를 위해 반복인자 j의 크기를 제한했으나 또 틀렸다...! 😕

고민하다가 이유를 또 찾아냈다!

```
ACAYKP
CAPCAK
```

이 예시의 정답은 ACAK인데 서로 순서가 바뀌어도 ACAK가 나와야 하는데 난 완전 딴판의 문자열이 튀어나왔다😯

그래서 이젠 c 배열을 역추적하기로 결정했다.

**str_x와 str_y의 문자가 같고, 현재 길이가 len일 때**를 기준으로 공통문자열 str을 채워나가면 되겠다 싶었다.

1. LCS의 길이를 알아낸 뒤, 그 길이(length)와 str_x(m), str_y(n)의 길이를 넘겨 backTracking 함수를 호출한다.
2. 공통 문자열을 넣을 str을 선언하고, c의 마지막부터 첫번째까지 반복문을 돌린다.
3. 공통된 문자가 있고, c의 값이 현재 len이랑 같을 때 str을 채워준다.
4. len을 하나 빼준다.
5. 반복문을 다 돌고나서 str을 거꾸로 되어있기 때문에 reverse해준 뒤 메인 함수로 반환한다.

<br>

결론은 정답이었다! 😉 무난하게 해결할 수 있었다!

<br>

<hr>

#### #제곱수의 합

[제곱수의 합](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_1699.java)

재밌는 문제였다. 😛 약간 헤맨 것도 있는데 그래도 어렵지 않게 해결할 수 있었다. 시간을 점점 줄여보는 연습을 해야지!

하나씩 써보면서 규칙을 찾아내려고 했다. 그래서 도달한 식은 dp[i] = i / max + dp[i % max] 였다. 여기서 max는 현재까지의 제곱수이다. 즉, 4이상 9미만일 때는 max의 값이 4(2^2)이고, 9가 되면 max의 값이 9(3^2)가 되는 형식이었다.

물론 틀렸다! 18 같은 경우는 3^2 + 3^2로 2가 나와야 하는데 내 식으로는 4^2 + 1^2 + 1^2가 나왔다.

그래서 prev라는 별도의 변수를 선언했다. 만약 max의 값이 9이면 이전의 max 4를 저장하는 용도였다. 그래서 prev로 나눴을 때 나누어 떨어지면 prev로 나눈 몫을 dp에 저장하는 방식을 이용하려고 했다. 물론 틀렸다! 😝 

142 같은 경우는 6^2 + 5^2 + 9^2 로 이전에 사용했던 제곱수를 한껏 사용했다!!! 🤪 그래서 나도 현재 제곱근부터 2까지 반복문을 돌리면서 min 값을 찾는 방식을 사용했다.

<br>

1. dp배열 1부터 3까지는 미리 값을 정의해주었다. 다음에 오는 수는 2^2오기 때문에 cnt는 2로 선언했다.
2. 나머지 부분은 Integer.MAX_VALUE로 최댓값을 정의한다.
3. 4부터 n까지 bottom-up 방식으로 dp를 실행한다. 
4. 만약 i가 cnt의 제곱수와 같다면 하나의 항만 사용해도 되기 때문에 1을 넣고 다시 반복문으로 돌아간다.
5. 4번의 경우가 아니라면, tmp 라는 변수를 정의해 cnt로 초기화해 준다.
6. tmp가 2이상이 될 때까지 반복문을 돈다.
7. 6번의 반복문 안에서 tmp의 제곱수(val)를 구하고, 그 제곱수로 나눈 몫에 나머지를 더한 값과 dp의 값을 비교한 뒤 작은 값을 dp에 넣어준다. (이를 위해 처음에 dp를 최댓값으로 초기화했다.) 

<br>

✔ 즉, 점화식은 dp[i] = Math.min(dp[i], i / val + dp[i % val])

<br>

사실 이렇게 했는데도... 몇 번의 런타임 에러가 있었다. 로직 자체의 문제는 아니었고 배열 선언 시 int[] dp = new int[n + 1];로 해두었는데 이게 말썽이었다. 결국 문제에서 제시한 최댓값에 1만큼 더 더해 배열의 크기를 정의해서 문제를 해결했다.

0을 입력하니 무슨 문제였는지 알 것 같았다. 내 방식대로라면 1만큼의 배열이 하나 생성될 것이다.

```java
for (int i = 1; i <= 3; i++) {
            dp[i] = i;
}
```

그렇게 되면 여기서 인덱스 에러가 날 것이다. 생각해 보니 이제까지 런타임 에러가 났을 때 저 for문 앞에 배열의 크기를 체크하는 조건문을 더 달아줬던 것 같다...! 

런타임 에러도 더 신경 쓰면서 문제를 풀어야겠다.👾

<br>

<hr>

#### #빗물

[빗물 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_14719.java)

📌 2023.01.07

이 문제는 하도 풀어서인지 풀이 방법을 외워버린 것 같다....

문제 보자마자 풀어버렸음 🙃 20년 하반기 쿠팡, 엔테크 코테 유사문제였던 걸로 기억한다.

<br>

<u>✍ 여기서부터 이전 풀이!</u>

오래 걸리지도 않았고 재밌게 풀었던 문제다. 

처음 문제를 봤을 때는 가장 높은 블록과 그 다음 높은 블록이 있으면 2번째로 큰 높은 블록만큼 물이 차겠다 싶어서 이를 이용하려고 했다. 이차원 배열을 만들어 블록에 해당하는 건 1로 채우고 나머지는 0으로 채운 뒤에 한 줄에 블록이 하나만 존재한다면 그 전까지가 두 번째로 높은 블록이기 때문에 이를 기준으로 나머지의 차이를 구하는 식이었다. 이 방식으로 구현해 보지 않았지만, 그렇게 했어도 틀렸을 것이다.

다음 시도는 첫 번째 시도와는 유사하나, 이차원 배열을 따로 생성하지 않고 블록의 높이의 차를 구하는 방식으로 진행했다. 하지만 첫 번째 방법도, 두 번째 방법도 틀릴 수밖에 없을 것이다.

![image](https://user-images.githubusercontent.com/62419307/94132791-c31b8200-fe9a-11ea-9103-a5b4212bbb29.png)

이와 같은 경우엔, 오른쪽에서 2인 블록 높이로 인하여 빗물이 고이겠지만 내 방식은 이와 같은 경우는 고려하지 않았다.

그래서 다음 방식은 지금 **현재 위치에서 오른쪽에서 가장 큰 높이, 왼쪽에서 가장 큰 높이를 구해 그 중 작은 값을 기준으로 해서 현재값을 빼준다면 빗물이 고인 높이를 알아내는 방법**을 사용했다. 매번 최댓값을 찾을 수 없으므로 정방향과 역방향 각각의 최댓값을 저장하는 dp 배열을 만들어서 해결했다. 👊

<br>

1. arr의 정방향으로 현재 max 값과 arr의 값 중 더 큰 값을 찾아서 dp에 저장한다.
2. 마찬가지로 역방향으로 최댓값을 찾아 dp_r에 저장한다.
3. W만큼 반복문을 돌면서 현재 위치의 왼쪽에서 가장 큰 높이 (dp), 오른쪽에서 가장 큰 높이 (dp_r) 값 중 작은 값을 구해 그 값을 h라고 정의하고 h에서 현재 arr[i]의 값을 빼준 뒤, sum(고인 물의 높이)에 더해준다.
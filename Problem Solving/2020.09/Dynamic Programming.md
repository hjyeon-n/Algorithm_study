# Dynamic Programming

| 문제 번호 | 문제 이름         |
| --------- | ----------------- |
| 2293      | [동전 1](#동전-1) |

<br>

<hr>

#### #동전 1

[동전 1 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_2293.java)

아주 오래 전에 시도했다가 포기했던 문제였는데 갑자기 도전하고 싶은 마음이 생겨 풀게 됐다.

처음엔 dp[i] i원을 만들기 위한 방법의 수라고 생각해서 접근했다.

```
n = 3, k = 10, 주어진 동전의 가치는 1, 2, 5이다.
```

dp[0] = 1이고,

dp[1]은 1원으로 만들기 위한 방법의 수이므로 1원의 동전을 하나 사용해서 만들 수 있기 때문에 1

dp[2]는 1원의 동전 2개, 2원의 동전 1개를 사용할 수 있으므로 2

dp[3]은 1원 동전 3개, 2원 동전 1개와 1원 동전 1개로 만들 수 있으므로 2

dp[4]는 1원 동전 4개, 2원 동전 2개, 2원 동전 1개와 1원 동전 2개로 만들 수 있으므로 3...

이런 식으로 손으로 하나하나 풀었다.

자세히 보니 규칙이 있어서 dp[4] = dp[3] + dp[1] 이런 식으로 점화식이 나오는 건가 했는데 더 전개하다가 아니라는 것을 알았다.

조금만 더 생각 하면 알 것 같았는데 그 조금이 항상 어려워서 결국 다른 사람의 풀이를 참고했다. 

<br>

> dp[j] = dp[j - coin[i]]

규칙을 찾아보면 이 점화식이 나온다고 하던데 나로서는 도저히 이해가 힘들어서😇... 좀 더 시간을 투자해서 많은 사람들의 풀이를 봤다. 약간 이해가 됐을 때 빠르게 정리해야지... ✍

<br>

동전의 가치는 예제를 참고했다.

coin[]은 동전의 가치를 나타낸 배열, dp[i]는 i원을 만들기 위한 동전의 수라고 생각하면 된다.

dp[0]은 동전을 아예 사용하지 않은 경우이기 때문에 1로 초기화한다. 나머지는 표로 보면 더 쉽다.

<br>

**1원의 동전만 사용했을 때**

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |

엥 왜 1이지..? 하고 고민하고 있을지도 모르는 미래의 나를 위해 정리하자면,

예를 들어, 2는 1원의 동전을 2개 사용해서 만들 수 있고 그 방법이 유일하기 때문에 1이다.

<br>

**2원의 동전까지 사용했을 때**

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 2    | 3    | 3    | 4    | 4    | 5    | 5    | 6    |

4원의 가치를 만들기 위해서는 1원 동전 4개, 2원 동전 2개, 2원 동전 1개와 1원 동전 2개로 만들 수 있으므로 방법의 수는 3이다.

즉, An += (An - 2)다. 이게 또 무슨 뜬금 없는 소리냐 하겠지만...

An - 2는 2원으로 n을 만들 수 있는 경우의 수라고 생각하면 좀 낫다. 2원을 사용하지 않고 10을 만들려고 한다면 1원으로만 10을 만들어야 한다. 하지만 2원까지 사용한다면, 8만 만들면 되는 것이다. 따라서 이를 일반화하면 An -2 가 된다.

<br>

**5원의 동전까지 사용했을 때**

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 10   |

5원보다 크기가 작은 1, 2, 3, 4원은 5원의 동전을 사용할 수 없기 때문에 경우의 수는 2원의 동전까지 사용했을 때와 똑같다.

5원부터는 5원을 사용할 수 있는 경우가 생겨 변동이 생길 것이다. 

5원의 가치를 만들기 위해서 2원의 동전까지 사용했을 때 1원 동전 5개, 2원 동전 2개와 1원 동전 1개, 2원 동전 1개와 1원 동전 3개를 사용할 수 있었다면, 5원까지 사용할 수 있다면 5원 1개를 통해서도 만들 수 있기 때문의 방법의 수는 4로, 1만큼 증가하게 된다.

즉, An += (An - 5)의 식을 도출할 수 있다.

<br>

이 모든 과정을 통해 결국 An = (An - 1) + (An - 2) + (An - 5)가 나온다. 

동전의 가치는 가변적이기 때문에 좀 더 일반화해야 한다. 

이때 **동전의 수는 n**, **가치는 k**이고 dp[k]는 n가지의 동전을 사용하는 경우의 수가 아니라 **1부터 n까지의 동전을 사용해서 k원을 만들 수 있는 경우의 수**이기 때문에 (즉, dp[8]은 동전 1, 2, 5를 적당히 합해 8로 만드는 경우의 수다.)  

동전의 수만큼 돌면서 (즉, 사용할 수 있는 동전을 점차 늘려가면서) dp 배열을 채우면 된다.

결국, 이전에 말했던 것처럼 최종 점화식은 이와 같다.

```
dp[j] = dp[j - coin[i]]
```

[참고](https://dundung.tistory.com/125)
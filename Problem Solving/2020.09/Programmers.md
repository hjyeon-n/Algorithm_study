# Programmers 👩‍💻

| 문제 이름                                 |
| ----------------------------------------- |
| [문자열 압축](#문자열-압축)               |
| [실패율](#실패율)                         |
| [괄호 변환](#괄호-변환)                   |
| [오픈채팅방](#오픈채팅방)                 |
| [자물쇠와 열쇠](#자물쇠와-열쇠)⭐          |
| [후보키](#후보키)                         |
| [비밀지도](#비밀지도)                     |
| [다트 게임](#다트-게임)                   |
| [캐시](#캐시)                             |
| [뉴스 클러스터링](#뉴스-클러스터링)       |
| [프렌즈4블록](#프렌즈4블록)               |
| [길 찾기 게임](#길-찾기-게임)             |
| [K번째수](#K번째수)                       |
| [모의고사](#모의고사)                     |
| [완주하지 못한 선수](#완주하지-못한-선수) |
| [가장 큰 수](#가장-큰-수)                 |
| [H-Index](#H-Index)                       |
| [소수 찾기](#소수-찾기)                   |
| [전화번호 목록](#전화번호-목록)           |
| [타겟 넘버](#타겟-넘버)                   |
| [위장](#위장)                             |
| [카펫](#카펫)                             |
| [주식가격](#주식가격)                     |

<br>

<hr>

#### #문자열 압축

[문자열 압축 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/문자열%20압축.java)

이 문제는 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 요구한다.

```
예를 들어, ababcdcdababcdcd의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 2ab2cd2ab2cd로 표현할 수 있다. 다른 방법으로 8개 단위로 잘라서 압축한다면 2ababcdcd로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법이다.
```

어려운 문제는 아니었지만, 생각보다 시간이 좀 걸렸던 문제였다. 

압축 단위는 1부터 문자열 s의 길이 1/2까지 올 수 있다. 1/2가 넘으면 겹치는 부분이 없어 압축될 수 없기 때문이다.

일단 정답이긴 하지만, 다른 사람의 풀이를 봤더니 재귀 같은 다른 방식으로 푼 것도 있어 참고하면서 더 공부해야겠다.

내 풀이 방식은 다음과 같다.

1. 문자열을 분리하는 단위를 하나씩 늘려가기 위해 (즉, 2개 단위로 단어를 끊다가 3개 단위로 단어를 끊는 방식) 반복문을 돌린다.

2. 반복문 안에서 1번의 반복 인자만큼의 단위로 자르고, 각각의 것을 보관하기 위해 배열을 선언한다. 만약, 3개의 단위로 자르는데 문자열의 길이가 3으로 나누어 떨어지지 않을 수 있기 때문에 1만큼의 여분 인덱스를 더 선언한다.

3. 문자열 집합에 자른 문자열을 보관할 때도 2번과 마찬가지로 그 단위의 수에 맞게 항상 나누어 떨어지진 않기 때문에 배열에 값을 저장할 때마다 remain이라는 문자열 s의 길이를 저장한 변수에 단위 만큼 빼준다.

4. 만약 단위는 3, remain이 2라면 배열에 남은 문자열을 다 저장하고, 반복문에서 빠져나온다.

5. 문자열 배열의 값들은 equals 함수를 통해 비교한다.

6. 이때, aa 뿐만 아니라 aaa 같이 반복의 수가 정해져 있지 않으므로, 주의해야 한다.

   예를 들어, cccab라는 문자열이 있다고 하자. 문자열을 자르는 단위는 1이고, 현재 위치는 0이라고 하면 c는 3번 반복되기 때문에 3c가 될 것이다. 이후 인덱스는 다시 2로 넘어갈 필요없이 (이미 검사를 진행했으므로) 인덱스 4의 값 a로 넘어가면 된다. 이때 반복의 수를 저장하는 m을 선언해 m은 3이 되고, 인덱스의 값은 다시 원래대로 돌려줘야하기 때문에 idx - m을 해준다.

7. cnt가 1보다 더 크면 중복되는 값이 있기 때문에 cnt와 함께 str[idx]를 새로운 문자열 newStr에 저장한다.

8. cnt가 1보다 작으면 중복 값이 없기 때문에 str[idx]를 newStr에 저장한다.

9. 2번부터 8번까지의 반복이 끝나면 원래 문자열 s의 길이를 저장한 answer와 새로운 문자열 newStr의 길이를 비교해 작은 값을 저장한다.

10. 1의 과정으로 넘어가 다시 반복한다.

<br>

<hr>

#### #실패율

[실패율 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/실패율.java)

아주 쉬운 문제였지만 Comparator가 까다로웠다. 파이썬으로 하면 람다식으로 깔끔하게 코드를 짤 수 있으나 자바로 하면 아무래도 코드가 좀 지저분해지는 건 어쩔 수 없다...😥

Comparator 부분은 종종 나오기 때문에 아예 개념으로 따로 정리하려고 한다. 여기서는 그냥 단순 문제 풀이만 정리해야지.

✅ 추가 완료! [Comparable과 Comparator 개념 정리](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/Comparable%EA%B3%BC%20Comparator.md)

<br>

1. 스테이지 개수만큼 실패율을 저장해야 하기 때문에 fail이라는 Stage형 배열을 선언한다. (Comparator을 위해 따로 Stage라는 클래스를 정의한 뒤, 객체로 사용한다.)
2. stages를 돌며 스테이지 개수를 찾아야 하기 때문에 double형 cnt를 선언한다. (int형으로 선언 뒤, typecasting도 가능하다.) 이때, 스테이지는 1 ~ N이 올 수 있고 stages의 값들도 이러한 값들이 오기 때문에 2번은 1번의 반복문 안에서 돌아야 한다.
3. fail 배열에 인덱스인 idx, 실패율인 cnt / userNum을 넣는다.
4. 유저의 수는 처음엔 stages의 길이와 동일하고, 반복문을 돌 때마다 cnt만큼 빼야 한다.
5. 1번의 반복문이 끝이 나면 Comparator를 통해 실패율을 기준으로 idx를 내림차순으로 정렬한다.

<br>

<hr>

#### #괄호 변환

[괄호 변환 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/괄호%20변환.java)

문제에 설명돼 있는 알고리즘대로 코드를 짜면 된다. 하지만 재귀가 간만이었기도 했고, 이상한 부분에서 시간을 많이 소비했다😖

이 문제는 하나의 기능을 하나의 함수로 빼놓으면 더 간단하고, 한 눈에 보이는 좋은 코드를 짤 수 있다는 걸 보여주는 좋은 문제였다!

<br>

```
1. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다. 
2. 문자열 w를 두 "균형잡힌 괄호 문자열" u, v로 분리합니다. 단, u는 "균형잡힌 괄호 문자열"로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다. 
3. 문자열 u가 "올바른 괄호 문자열" 이라면 문자열 v에 대해 1단계부터 다시 수행합니다. 
  3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다. 
4. 문자열 u가 "올바른 괄호 문자열"이 아니라면 아래 과정을 수행합니다. 
  4-1. 빈 문자열에 첫 번째 문자로 '('를 붙입니다. 
  4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다. 
  4-3. ')'를 다시 붙입니다. 
  4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다. 
  4-5. 생성된 문자열을 반환합니다.
```

나는 기능을 크게 4가지로 나누었고, 각각의 기능마다 함수를 새로 정의했다.

1. *divideStr* : 문자열 w를 두 "균형잡힌 괄호 문자열" u, v로 분리
2. *isFine* : 문자열이 "올바른 괄호 문자열" 인지 확인
3. *reverse* : 문자열의 괄호 방향을 뒤집음
4. *makeStr* : 문자열 생성 (4번의 과정)

<br>

처음에는 4번의 과정을 따로 함수로 빼지 않고 solution 함수에서 진행했다. 아마도 재귀 중에 문자열의 값이 계속 바뀌어서 원하는 답이 나오지 않았는데, 따로 함수로 빼서 u와 v를 매개변수로 둔 후 정의했더니 값이 바뀌지 않아 값이 제대로 나왔다. 이 부분에 대해선 좀 더 디버깅하고 확실히 익혀야겠다.

2번의 경우도 처음에는 flag 변수로 둬서 올바른 괄호를 체크하려고 했으나, '(' 다음에 바로 나오는 ')'을 어떻게 표현해야 하나 고민하다가 예전에 BOJ에서 풀었던 [괄호](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_9012.java) 문제를 참고했다. 참 내가 풀어놓고선 또 까먹어버렸다...😫

다른 함수는 직관적이고, 문제에 나온 설명 그대로를 따르기 때문에 풀이는 생략한다.

<br>

<hr>

#### #오픈채팅방

[오픈채팅방 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.09/%EC%98%A4%ED%94%88%EC%B1%84%ED%8C%85%EB%B0%A9)

아주아주 쉬웠던 문제! 두 가지 버전으로 푸는 데 1시간도 안 걸렸던 것 같다.

문제 풀이는 처음 생각했던 방식과 개선된 방식 둘 다 설명할 것이다. 물론, 두 방법 다 정답이다.😎

<br>

```
채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.

- 채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다.
- 채팅방에서 닉네임을 변경한다.

닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다.

채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라.
```

🖥 첫 번째 방법

1. 닉네임이 중복되는 경우도 있고, 닉네임이 변경되면 기존 닉네임의 메시지들도 다 수정해줘야 하기 때문에 HashMap을 정의한다.

2. 기록들을 메시지들로 나타내기 위해 record의 수만큼 반복문을 돌린다.

3. 1번의 반복문 안에서 record의 원소 하나를 꺼내 공백을 기준으로 split한 뒤, String형 배열 str에 저장한다 . 

   (예: Leave uid123 → str[0] = Leave, str[1] = uid123)

4.  Leave, Enter 등 명령어는 항상 첫 단어에 나오기 때문에 str[0]이 어떤 값이 나오느냐에 따라 다르게 처리하도록 switch문을 정의한다. (예: Enter는 닉네임을 변경할 수 있고, 처음 들어올 수도 있기 때문에 map을 통해 id에 해당하는 닉네임을 설정해준다.)

5. 4번의 결과물에 따라 다시 switch문을 통해 메시지를 작성해 answer 배열에 저장하고 반환한다.

<br>

4, 5번의 과정은 거의 흡사하기 때문에 하나의 함수로 묶어주었다.

새로운 rslt 배열을 생성해서 명령어와 uid를 다시 넣어주었고, 4번의 switch문에서의 핵심 역할은 닉네임의 변경을 위한 map 사용이었다.

사실 이 방식은 많은 문제점이 있었다. 

1. 같은 함수를 사용하기 때문에 닉네임 변경 과정 / 메시지 생성 과정에 따라 달라지는 부분은 flag와 같은 매개변수를 통해 구분해야했다. (변경 과정은 0, 생성 과정은 1)
2. 이게 가장 큰 문제였는데, Change 같은 경우는 닉네임 변경에만 영향을 미치지 메시지 출력과는 상관이 없었다. 하지만 이 방식은 변경과정과 생성과정 모두 새로운 배열 rslt에 넣는 방식이었다. 즉, Change도 포함한 만큼 배열의 크기가 할당되기 때문에 **Change가 빠지면서 남은 자리는 null이 들어가고** 그러면 잘못된 값을 출력했다. 리스트를 사용하면 되지만, 나는 같은 함수를 사용하려고 했기 때문에 cnt라는 전역변수를 사용해 Change의 반복 횟수만큼 배열의 크기를 줄여주었다.

정답이긴 했지만, 다른 풀이로 한 번 더 풀어야겠다고 생각했다.

<br>

🖥 두 번째 방법

이 방법은 함수로 따로 정의하지 않고 메인에서 한 번에 진행했다.

1. 닉네임 변경을 위한 HashMap 자료구조와 메시지를 넣을 List형 자료구조를 선언한다.
2. 첫 번째 방법의 2, 3 과정
3. str 길이가 2 이상이라는 건 Change, Enter를 의미하고 이는 닉네임 변경과 관련돼 있다.
4. 다만, Change의 경우 메시지 생성과 관련이 없기 때문에 Change가 아닐 경우에만 list에 str[0], str[1]을 삽입한다.
5. 메시지 생성 과정이 끝난 후, 답을 반환할 answer 배열을 선언한다.
6. list의 길이만큼 돌면서 answer에 메시지를 넣어준다. 이때, map에서 아이디에 해당하는 닉네임을 꺼내면 된다.

<br>

아까의 문제점을 한 방에 없애주는 풀이였다. 이건 사실 나 스스로 짰다기 보다는 다른 사람의 풀이 중 괜찮은 알고리즘을 골라 내 방식대로 다시 풀어낸 것이다. 여러 방식을 알 수 있게 됐고 조금이라도 개선된 방향으로 코드를 짠 것 같아서 기분이 좋다 🌷

<br>

<hr>

⭐⭐⭐⭐⭐


#### #자물쇠와 열쇠

[자물쇠와 열쇠 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%EC%9E%90%EB%AC%BC%EC%87%A0%EC%99%80%20%EC%97%B4%EC%87%A0.java)

프로그래머스 문제를 풀면서 처음으로 답을 보고 풀었던 문제... 안 보려고 노력했지만 도저히 감이 잡히지 않았다. 따쉬...🤦‍♀️

처음 생각했던 아이디어는 이랬다.

1. 열쇠의 크기는 자물쇠의 크기보다 작거나 같으므로, 열쇠가 동 서 남 북 & 회전할 때의 모든 경우를 다 탐색한다.
2. 즉, 동쪽으로 가면 동 서 남 북으로 또 갈 수 있는 방향이 있고 여기서 또 동쪽으로 가면 다시 동서남북... 이런 식으로 재귀가 이루어질 것이다.

하지만 결국 구현하지 못했다... 일단 시간 초과가 날 것 같기도 했고, 무엇보다 재귀로 어떻게 짤 지 감이 잘 잡히지 않았다. 

예를 들어... 동쪽 끝까지 진입했을 때 다시 하나씩 돌아가면서 다른 방향으로 전진한다? 말로도 이미 복잡하고 다른 방법이 더 있지 않을까 고민하다가 머리가 터질 것 같아서🤯 결국 해설을 봤다.

<br>

근데 해설을 봐도 이해가 안 되는데...? 😇

소리 지르다가 결국 다른 사람 풀이를 봤는데 여기서도 이해가 안 돼서 한참 고민했다...

이해가 안 된 부분

1. 왜 3배를 확장해줘야 하나
2. 확장해서 푼 게 어떻게 동서남북을 다 이동해 본 것 같은 거라는 거지?

결국 같은 의미인데 나는 그림을 하나씩 그려서 생각해 봤다.

![image](https://user-images.githubusercontent.com/62419307/92690343-cdf2f480-f37b-11ea-8591-0854e91393f4.png)

[그림 출처](https://travelbeeee.tistory.com/415)

2번은 직접 그림을 그려보니 결국 모든 경우를 탐색하는 것과 결과가 같았기 때문에 이해를 했는데... 왜 3배를 확장했을까 더 고민했다.

찾아보니 lock.length + (key.length - 1) * 2 만큼 확장하는 사람이 많았다. 

3배만큼 확장하는 건 그냥 넉넉하게 잡아준 것 같고, 실제로 그려보면 3배만큼 확장했을 땐 처음의 경우가 그림의 첫번째 부분처럼 겹쳐서 시작하지 않는다. 이 무의미한 경우를 빼준 게 lock.length + (key.length - 1) * 2인 것 같다.

다음엔 왜 이런 식이 나왔는지 고민했다.

![image](https://user-images.githubusercontent.com/62419307/92691920-5c687580-f37e-11ea-99b6-49a8bcb7f77d.png)

이것도 그림을 그려보면서 이해했다. 가운데 lock의 길이와 key 길이에서 겹친 key 부분 (처음 겹치는 길이가 1)을 빼주면 이런 식이 나온다.

난 [해설](https://tech.kakao.com/2019/10/02/kakao-blind-recruitment-2020-round1/)처럼 3배 만큼 확장한 범위를 사용했다.

<br>

#### 드디어 문제 풀이다!

회전과 동서남북 이동이 있고,  회전도 90, 180, 270, 360(0)의 4가지 경우가 필요하기 때문에 우선 회전을 한 뒤 그 회전한 key를 가지고 이동을 시키면 된다.

1. 자물쇠 배열의 3배의 크기로 확장한 map을 정의한 후, map의 가운데에 자물쇠 배열을 삽입한다.
2. key 배열을 회전시킨다.
3. 이제 탐색을 시작한다. 탐색은 0부터 map.length - key.length 만큼 반복문을 돌리면서 수행한다.
4. 3번의 반복문 안에서 열쇠를 자물쇠에 끼우는 과정을 거친다.
5. 4번의 결과가 전부 1인지 확인한다. 만약 1이 아니면 다시 값을 원래대로 돌려놓고, 1이면 탐색을 종료한다.

<br>

<hr>

#### #후보키

[후보키 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%ED%9B%84%EB%B3%B4%ED%82%A4.java)

풀다가 열받아서 무슨 만화처럼 머리 헝클어뜨리면서 소리 질렀다...😇

어려운 문제가 아닐지는 몰라도 나에게 너무나 어려웠기 때문... 🤯 ~~(나한테 어려우면 다 어려운 문제다. 흥)~~

정말 기이이인 시간동안 풀었고, 18 19 20 22 25 << 이 테스트케이스에서 자꾸 틀려서 포기할까도 했지만 포기하기엔 너무 멀리 와서 끝까지 풀었고 결국 해냈다... 난 진짜 멋있는 어른이다... 🤸‍♀️

<br>

```
관계 데이터베이스에서 릴레이션(Relation)의 튜플(Tuple)을 유일하게 식별할 수 있는 속성(Attribute) 또는 속성의 집합 중, 다음 두 성질을 만족하는 것을 후보 키(Candidate Key)라고 한다.

- 유일성(uniqueness) : 릴레이션에 있는 모든 튜플에 대해 유일하게 식별되어야 한다.
- 최소성(minimality) : 유일성을 가진 키를 구성하는 속성(Attribute) 중 하나라도 제외하는 경우 유일성이 깨지는 것을 의미한다. 즉, 릴레이션의 모든 튜플을 유일하게 식별하는 데 꼭 필요한 속성들로만 구성되어야 한다.
```

후보키는 속성 1개가 될 수도 있고 그 이상일 수도 있다. 이 모든 경우를 따지기 위해서는 조합이 필요하다. 

나는 DFS 백트래킹으로 조합을 구했다.  인덱스 배열을 만든 뒤 그 배열에서 1 ~ 행의 개수까지 뽑는 수를 늘려가면서 풀었다.

1. 유일성을 구하기 위해서

   모든 튜플에 대해 유일하게 식별되어야 한다는 건 해당 속성에서의 튜플이 모두 유일하게 식별이 돼야 한다는 뜻이고, 조합의 결과로 가지고 온 인덱스를 이용해 relation의 튜플을 뽑아내 **튜플(열)의 수만큼 반복문을 돌면서 유일한 값인지 판별하려고 했다.**

   relation이 String 타입인 점을 이용해 str이라는 문자열을 선언하고 그 값에 값들을 하나씩 더해갔다.

   (예를 들어, 조합의 결과로 1, 2라는 인덱스 값이 나왔다면, i를 반복인자로 하여 튜플의 길이만큼 relation[i] [1]와 relation[i] [2]를 더해주면 된다.  그러면 "apeach math"와 같은 값들이 set에 차례대로 저장될 것이다.)

   이를 위해서 set 자료구조를 사용했다. 그리고 set의 size와 튜플의 수를 비교했다. 만약 다르면 중복값이 있었다는 뜻이기 때문에 다음 조합의 값으로 넘어간다. 

   같은 경우엔... 최소성을 따져봐야 한다. 사실 여기서 문제가 돼서 삽질을 열심히 했다. 🌪 

   <br>

2. 최소성을 구하기 위해서

   결론적으로 말하면 **후보키를 저장한 값들(별도로 리스트에 저장됨)과 현재 조합의 결과로 나온 값을 비교하면 된다.**

   contains를 사용하면 되는데 그냥 단순히 리스트의 값과 현재 값을 비교하면 안 된다!!!!! 😭 (여기에서 제일 오래 고민했다)

   예를 들어, 리스트에 있는 값은 1, 3 비교 대상인 1, 2, 3은 최소성에 위배되는데 1, 3이 포함된다는 것을 알기 위해서는 **1과 3이 포함되어있는지 따로따로 검사해야 한다.** 그러기 위해서 나는 charAt을 사용해 String의 값을 따로 분리해낸 뒤 비교했다.

<br>

다른 사람의 풀이를 참고하려고 했는데 나는 너무나 먼 길을 와서... 결국 스스로 풀었지만 내가 봐도 너무 복잡해서 다른 사람의 풀이를 더 찾아봤는데 대부분 비트마스킹으로 풀고 있어서 우선, 비트마스킹 개념 정리부터 해야겠다.

<br>

<hr>

#### #비밀지도

[비밀지도 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.09/%EB%B9%84%EB%B0%80%EC%A7%80%EB%8F%84)

이제까지 풀었던 프로그래머스 문제 중 가장 쉬웠다. 보자마자 비트마스킹으로 풀면 되겠다고 생각했다. 

그래서 toBinaryString으로 이진수로 바꾸고 포맷을 맞춰준 뒤, int로 바꿔서 비트마스킹으로 풀려고 했는데 Integer.parseInt는 단순히 다른 타입을 정수로 바꿔주는 게 아니라 **정수 형태로 바꿔준다는 사실**을 간과했다.

그러니까 01001이라는 String을 int로 바꾸면 1001이 된다. 그래서 첫 번째 방법은 단순히 String 비교로 문제를 해결했다.

첫 번째 방법

1. arr1, arr2에 있는 정수를 하나씩 꺼내서 이진수로 바꿔준 뒤 자릿수를 맞춰주기 위해 앞자리에 0을 추가하는 과정을 거친다.
2. 위의 과정은 결과값이 String 형태로 나오고 각각의 결과값을 str1, str2라고 한다면 charAt을 이용해 하나하나 비교해서 새로운 문자열 answerStr을 선언해 둘다 0일 때만 answerStr에 공백을 더해주고 그렇지 않으면 #을 더해준다.
3. answerStr을 answer 배열에 넣는다.

<br>

위 방법으로 일단 정답이 되었지만 다른 사람 풀이를 보니 내가 처음에 생각했던 것처럼 비트마스킹으로 푼 풀이가 있어서 다시 한 번 풀었다.

두 번째 방법

1. 이진수로 바꿔주기 전에 비트마스킹으로 정수 값을 구해준 뒤, 그 값을 이진수로 바꿔주었다.
2. 1의 값을 answer 배열에 하나씩 넣어준다.
3. 자릿수를 맞춰주기 위해 format을 사용하고, 1은 #으로 0은 공백으로 바꿔준다.

<br>

요즘은 문제를 푸는 것도 중요하지만 더 효율적인 방식이 있을까 고민하게 되는데 이번 문제가 그 중요성을 더 일깨워줬다.

아직 문제를 맞히는 것도 힘들지만 좀 더 실력이 향상되면 클린 코드를 짜는 데도 더 심혈을 기울일 수 있는 사람이 돼야겠다 💪

<br>

<hr>

#### #다트 게임

[다트 게임 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%EB%8B%A4%ED%8A%B8%20%EA%B2%8C%EC%9E%84.java) 🎯

 스택으로 접근하면 되는 문제. 처음에는 스택 말고 다른 방식으로 풀고 싶었는데 * 같은 경우엔 현재 항과 이전 항에 2를 곱해줘야 하기 때문에 prev라는 이전 항 값을 저장해야 하는 변수가 필요해서 그냥 스택으로 풀었다.

1. switch문으로 숫자와 문자를 구분한다.
2. 숫자의 경우, 10이 올 수 있기 때문에 일의 자리수와 비교해 주기 위해서 처음에는 n을 -1로 초기화한다.
3. n이 -1일 경우 현재 숫자를 n으로 초기화해 준다.
4. 만약 n이 -1이 아닌데 다음에 오는 것도 숫자라면 10을 의미하기 때문에 n을 10이라고 초기화해 준다.
5. S, D, T는 각각 1의 제곱, 2의 제곱, 3의 제곱을 해준 후, 스택에 push한다.
6. #는 현재 스택의 top에 -1을 곱해준다.
7. *은 이전 항과 현재 항에도 영향을 미치기 때문에 현재 top을 먼저 pop하고 스택이 비어있지 않으면 다음 top을 pop한 뒤 각각을 2로 곱해준 뒤, 다시 순서대로 push 해준다.
8. 모두 끝이 나면 스택이 빌 때까지 합을 스택의 값을 더한 후, 값을 반환한다.

<br>

<hr>

#### #캐시

[캐시 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.09/%EC%BA%90%EC%8B%9C)

쉬운 문제. 다만 무슨 자료구조를 이용할까 잠깐 고민했었다. 

캐시 적중 여부를 파악하기 위해서 HashMap을 사용할까 하다가 LRU로 삽입이나 삭제가 빈번하니까 Queue를 사용할까 고민했다. 그러다가 LinkedHashMap이라는 순서대로 값을 저장할 수 있는 HashMap을 이용해서 적중하지 않을 땐 첫 번째 인덱스 값을 빼고 다시 넣고... 이 과정을 반복할까도 했다. 그런데 인덱스로 접근하기도 힘들어서 두개 다 사용할까 하다가 그냥 큐만 사용하기로 결정했다.

결론적으로 말하면 remove 함수를 사용하면 아주 쉽게 풀 수 있었는데 처음엔 remove를 사용했다가 자꾸 틀리길래 remove 함수가 내가 생각하는 기능을 못하는 줄 알아서 (사실 원인은 다른 곳에 있었음!) Deque로 일일이 구현하는... 과정을 거쳤다😂 이게 ver1 나중에 고친 게 ver2다.

1. 캐시 사이즈가 0이면 보관하는 곳이 없기 때문에 바로 cities 길이에 5를 곱해 반환한다.
2. 만약 0이 아니라면 cities의 길이만큼 반복문을 돌면서 적중여부를 확인한다. 이때 contains 함수를 사용한다.
3. 적중한다면 캐시에 있던 String 값을 삭제하고 다시 새로운 값으로 넣어준다. answer에 1만큼 더해준다.
4. 적중하지 않는다면 캐시 사이즈와 큐 사이즈를 비교해 만약 같다면 캐시는 더 커질 수 없으므로 큐의 값을 하나 빼주고 cities 값을 넣어준다.

<br>

ver2의 경우엔 3을 위해 Deque를 사용했고, 별도의 리스트를 선언해 적중 값이 나올 때까지 큐의 값을 빼주면서 그 값은 리스트에 넣어준다. 만약 적중 값을 만나면 반복문에서 빠져나오게 되고 큐의 첫번째 부분에 리스트를 역순으로 해서 넣어준다. (이거 때문에 Deque를 사용했다.)

<br>

<hr>

#### #뉴스 클러스터링

[뉴스 클러스터링 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.09/%EB%89%B4%EC%8A%A4%20%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81)

어려운 문제는 아니었다! 생각보다 쉽게 풀긴 했는데 처음 실행했을 때는 몇 개의 테스트케이스에서 틀렸다.

집합 A와 집합 B의 원소가 중복되며 겹칠 때만 신경을 써주고 겹치지는 않지만, 중복되는 경우는 무시해서 틀렸다는 걸 질문란에서 알아챘다. 예를 들어, aabbcccdeff와 aabcdde가 있을 때 합집합은 aabbcccddeff지만 내 코드로는 aabbcccddef로 나와서 틀렸었고 이 부분을 고치니 통과했다. 코드가 좀 복잡해서 다른 사람 풀이를 참고한 코드는 ver2로 따로 올려놨다.

<br>

나는 set 자료구조를 이용해서 문제를 풀었고, set을 이용해 교집합과 합집합을 구한 뒤, String 매개변수에서 특수 문자를 제외하고, 2개씩 잘라 만든 리스트에서 교집합/합집합의 원소가 몇 개 중복되는지를 체크하는 로직으로 문제를 풀었다.

1. 대소문자가 구분이 없기 때문에 매개변수로 오는 값 모두 소문자로 바꿔준다.
2. String 값을 2개씩 자르되, 정규식을 이용해서 만약 영문자가 아니면 그 값은 리스트에서 제외시키고 나머지는 리스트에 추가한다.
3. A 집합과 B 집합의 리스트 결과를 각각 set으로 바꿔 중복을 없애주고 교집합과 합집합을 구한다. 
4. 교집합 리스트를 만들기 위해 (3번의 값은 중복을 없앤 값, 4번은 자카드 정리를 위한 교집합) 교집합 전체를 돌면서 A 집합과 B 집합의 중복 수를 파악해 그 중 작은 값만큼 교집합 리스트에 추가시킨다. 합집합 리스트를 위한 교집합 리스트는 max 값만큼 추가해야 하기 때문에 이 차이는 flag 변수를 사용해서 구했다.
5. 합집합 리스트를 만들기 위해 (flag = 1일 때가 합집합이다.) A 집합, B 집합에 공통적으로 포함돼 있는 것은 아니지만 그 값이 중복으로 존재할 때를 세 주기 위해 list1(집합 A를 2개씩 잘라 만든 리스트), list2를 전부 돌면서 현재 앞에서 만든 교집합 리스트에 포함돼 있진 않은 경우에 대해 합집합 리스트에 따로 추가하는 과정을 거친다.
6. 메인함수로 돌아와 값을 구한 뒤, 반환한다.

<br>

ver2의 코드는 더 간단하다.

1. ver1의 1번과 2번 과정과 똑같다.
2. 집합 A를 기준으로 교집합과 합집합을 구하는 과정이 진행된다. A가 비어있지 않을 때까지 반복한다.
3. 집합 A의 첫 번째 원소 target을 뽑아 집합 A에서 target이 포함된 만큼 빼준다. 이 값은 targetSizeOfSet1이 된다.
4. 집합 B에서 target이 포함된 만큼 빼준다. 이 값은 targetSizeOfSet2가 된다.
5. 만약 targetSizeOfSet2이 0보다 크다면 이는 A와 B 모두 공통된 원소가 있다는 뜻이기 때문에 targetSizeOfSet1와  targetSizeOfSet2의 값을 비교해 작은 값이 교집합의 크기가 된다. 이 값을 intersectionSize에 더해준다. 
6. 합집합은  targetSizeOfSet1와  targetSizeOfSet2의 값을 비교해 큰 값이 합집합의 크기가 된다. 이 값을 unionSize에 더해준다. 
7. 만약 targetSizeOfSet2이 0보다 작다면 이는 공통된 원소가 아니라는 뜻이다. 그렇기 때문에 합집합의 크기만을 구한다.
8. 반복문이 전부 끝나고 나서 unionSize에 set2의 크기를 더해준다. 이는 set1과 공통된 원소는 전부 제거한 상태이고 즉, B에서 중복되는 값이나 단독으로 존재하는 값들이 있을 것이며 결국 전부 합집합의 대상이 되기 때문이다.
9. 자카드 유사도 값을 구한 뒤, 반환한다.

<br>

<hr>

#### #프렌즈4블록

[프렌즈4블록 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%ED%94%84%EB%A0%8C%EC%A6%884%EB%B8%94%EB%A1%9D.java)

어려운 문제는 아니었는데 이상한 데서 엄청 헤맸다😂

처음에는 BFS로 풀어야 하나 그렇게 되면 어떻게 2X2 형태인지는 파악하고... 또 겹치는 부분은 어떡하지? 고민을 했다.

어차피 n과 m 범위도 작으니까 그냥 중첩 반복문 돌면서 2X2 형태가 가능한지 파악하는 방법으로 풀었다.

제일 시간이 오래 걸렸던 부분은 블록을 아래로 당기는 과정이었는데 지금 생각하면 왜 그랬는지는 모르겠지만 큐 2개로 0일 때와 1일 때를 구분해서 풀려고 했다. 그냥 쭉 밀면 되는데🤦‍♀️ 테스트 케이스 10, 11번에서 자꾸 틀렸다고 해서 환장하는 줄 알았지만 결국 스스로 해결했다.

<br>

1. 문장의 글자 하나하나를 블럭으로 취급하기 때문에 문장을 글자별로 자른 뒤 map이라는 이차원 배열에 저장한다.
2. 2X2 블록의 개수를 찾는 함수와 블록을 아래로 미는 함수는 따로 분리했고, 메인에서는 2X2 블록의 개수가 0이면 while문을 빠져나가 블록의 개수(여기서는 *이 블록의 개수다)를 세주면 된다.
3. 2X2 블록의 개수를 찾는 함수에서는 중첩 반복문을 돌면서 모든 정점에 대해 2X2가 이루어지는지 확인한다. 범위 안이고, 2X2가 모두 같은 글자일 땐 블록의 개수를 하나 증가시킨다. 2X2 형태가 발견되더라도 겹치는 2X2도 생각해봐야 하기 때문에 바로 제거하지 않고 block이라는 정수형 이차원 배열을 선언해서 해당 형태에 1을 넣어준다.
4. 블록을 움직이는 함수는 아래로만 밀 수 있기 때문에 열을 중심으로 생각한다. 1일 때는 다음 턴에서 제거될 예정이기 때문에 0을 아래로 밀어주는 게 핵심이다. 열의 마지막 인덱스에서부터 0까지 거꾸로 올라가면서 0일 때는 별도의 큐를 선언해 큐에 삽입한다.
5. 열에 대해서 큐 삽입이 끝나면 큐에서 하나씩 원소(이 원소는 인덱스를 나타낸다.)를 빼내서 마지막 인덱스부터 원소의 인덱스에 해당하는 값으로 채워준다.
6. 큐가 전부 비었는데 아직 인덱스가 0까지 도달하지 않았으면 0이 될 때까지 전부 *로 채워준다.  후에 메인에서 이 개수를 세서 반환하면 정답이다.

<br>

<hr>

#### #길 찾기 게임

[길 찾기 게임 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%EA%B8%B8%20%EC%B0%BE%EA%B8%B0%20%EA%B2%8C%EC%9E%84.java)

쉬운 문제만 골라서 푸는 건가... 요즘 프로그래머스에서 문제 푸는 게 제일 재밌다 😊

처음에는 문제가 이해가 안 돼서 한참 보다가 이해했다. 말그래도 '좌표'인데 그 값이 그냥 트리를 구성한다고 생각했었나 보다.

이차원 배열을 만들어 좌표값대로 배열의 인덱스를 찾아가 좌표값이 위치한 배열의 순서 + 1만큼 값을 넣어주고 이를 트리로 만들려고 했던 게 첫 번째 시도였다. 이차원 배열을 만들고 또 0이 아닌 값을 찾아서 큐에 넣고 또 그 값대로 트리를 만드는 과정이 불안불안했는데 역시나 메모리 초과가 났다...😢

다음엔 이차원 배열을 만드는 과정을 생략하고 바로 매개변수로 주어진 좌표 값들로 바로 트리를 만들자고 생각했다. 그냥 간단히 생각하니 comparator로 y 값을 기준으로 값을 정렬하고 이를 트리로 만들면 얼추 될 것 같아서 그렇게 시도했고 정답이었다. 😎

<br>

1. 트리를 생성하기 위해 Node 클래스를 선언한다. 트리의 왼쪽, 오른쪽과 좌표값을 기준으로 하기 때문에 loc_x, loc_y를 멤버 변수로 선언하고 데이터 값을 넣을 data도 선언해 준다.
2. 메인에서 매개변수로 받은 배열에서배열의 순서 + 1,  x, y 좌표를 Node 생성자 매개변수 순서에 맞게 선언한 뒤, list에 넣어준다.
3. y값이 가장 높은 게 가장 위에 위치할 것이기 때문에 그게 바로 루트가 된다. 그런 개념을 토대로 y 값을 기준으로 list를 내림 차순 정렬해 준다.
4.  list에서 첫 번째 값을 뽑아 루트로 선언한 뒤에 list가 전부 빌 때까지 root에 삽입해 준다.
5. 트리를 전위 순회, 후위 순회한 값을 전역변수로 선언한 리스트에 넣어준 다음 메인에서 각각을 이차원 배열에 넣고 그 배열을 반환해 주면 된다.

<br>

약간 헤매기는 했지만 그래도 스스로 다 풀었으니 만족한다! 😉

 comparator를 별도로 정리하니까 이해가 쉬워서 금방 풀 수 있었다. 트리 삽입 과정에 대한 설명은 [여기](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.09/Data%20Structure.md#%EC%9D%B4%EC%A7%84-%EA%B2%80%EC%83%89-%ED%8A%B8%EB%A6%AC)에서 확인할 수 있다.

<br>

<hr>

#### #K번째수

[K번째수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.09/K%EB%B2%88%EC%A7%B8%EC%88%98)

프로그래머스에서 SQL을 제외하고 처음으로 카카오 기출 문제가 아닌 문제를 풀어봤다.

쉬운 문제였고 여기서 새로 알게 된 점은 Arrays.copyOfRange(배열, 시작 인덱스, 마지막 인덱스) 함수! (이때 시작인덱스는 0부터 시작).

정렬은 Arrays.sort를 이용했다.

<br>

<hr>

#### #모의고사

[모의고사 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.09/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC)

쉬운 문제였고, ver1에서는 최댓값을 찾기 위해 반복문을 돌렸지만 ver2에서는 Math.max로 구했다.

문제의 키포인트는 답이랑 찍은 문항을 어떻게 비교하냐인데, 완전 탐색보다 나머지 연산을 떠올릴 수 있느냐가 더 중요하게 작용했던 것 같다.

<br>

<hr>

#### #완주하지 못한 선수

[완주하지 못한 선수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.09/%EC%99%84%EC%A3%BC%ED%95%98%EC%A7%80%20%EB%AA%BB%ED%95%9C%20%EC%84%A0%EC%88%98)

이 문제에서 새로 알게 된 점은 단연 getOrDefault(player, 0)다. HashMap의 함수로 player에 대한 값이 없으면 default인 0을 반환해주는 함수인데 나는 이를 알지 못해서 조건문으로 containsKey를 사용했다. 다음에 한 번 써먹어야겠다! 🤸‍♀️

<br>

<hr>

#### #가장 큰 수

[가장 큰 수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%EA%B0%80%EC%9E%A5%20%ED%81%B0%20%EC%88%98.java)

주어진 정수 배열을 String 값으로 바꿔서 해 볼까도 했고, 일단 정렬을 할까도 했는데 이 문제의 경우엔 단순히 정렬을 시키는 게 아니라 자릿수를 비교해서 정렬을 해줘야 했기 때문에 고민했다. 대충 아스키 코드를 사용해야 할 것 같고 Comparator을 이용해야 할 것 같았는데 확신이 잡히지 않아서 다른 사람 풀이를 조금 참고했다.

근데 처음에 생각했던 방법이 맞더라...😅 조금 더 고민해 볼 걸 그랬다. 이럴 때 너무 아쉽다...

주어진 정수 배열의 값이 전부 0일 때는 그냥 0을 반환한다. 만약 그렇지 않다면 일단 문자열을 만들고 Comparator로 아스키 코드 값을 비교해 정렬했다. 

<br>

<hr>

#### #H-Index

[H-Index 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.09/H-Index)

문제가 잘 이해가 안 돼서 잘못된 테스트케이스 봤다가 더 꼬여버린 문제... 위키 가서 개념 익힌 후에야 문제를 풀 수 있었다.

ver1가 내가 푼 버전이고 나 같은 경우는 answer을 0으로 초기화한 뒤, 1일 때부터 citations의 길이까지 하나씩 늘려가면서 가능한 h의 최댓값을 answer에 넣는 방식이었다.

1. 배열을 정렬한다.
2. 1부터 citations의 길이(포함)까지 h를 늘려간다. (이때 반복인자는 i)
3. 2번의 반복문 안에서 0부터 h번까지 h번 인용된 논문이 h번 이상이고 h번 이하인지 확인한다. 이하는 small의 값으로, 이상은 big의 값을 담는다. 이때 이미 정렬된 배열이기 때문에 big이 i번 이상이 되면 더 보지 않아도 뒤엔 모두 big이 되기 때문에 break를 건다.
4. small이 h번 이하이고 big이 h번 이상이면 answer에 i값을 넣어준다. 

<br>

그리고 다른 사람의 풀이도 확인했는데(ver2) 너무 신박했다. 근데 나는 코드 이해도 좀 힘들었고... 나는 실제 테스트에서는 이렇게 풀기 힘들 것 같다...😂 거꾸로 배열을 확인하면서 원소 값은 점점 감소하고, 원소 값 이상인 것의 개수도 점점 감소하므로... 이 두 값의 최소값의 변화가 증가하다가 감소하는 지점을 찾으면 되는 것 같은데... 아직도 이해가 힘들다.

차라리 내가 처음 생각했던 방식이 괜찮을 것 같다.

1. 배열을 정렬한다.
2. h는 배열의 길이 - i로 초기화한다.
3. i가 0부터 배열의 길이까지 반복문을 돌면서 citations[i]의 값이 h보다 크거나 같으면 answer는 citations[i]가 되고 더 이상 볼 필요 없이 break한다. 왜냐면 최대로 올 수 있는 h의 값은 citations의 길이인데 정렬한 배열의 첫 번째 값이 그보다 크면 h의 최댓값은 바로 citations의 길이가 되기 때문이다.

<br>

<hr>

#### #소수 찾기

[소수 찾기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%EC%86%8C%EC%88%98%20%EC%B0%BE%EA%B8%B0.java)

종이 조각을 어떻게 배열하느냐에 따라 다른 값이 나올 수 있기 때문에 순열로 풀었다. 조합이 아니라 순열을 사용한 이유는 0, 1, 1이 있을 때 2개를 뽑을 경우는 1, 1이 될 수 있고 1, 0이 될 수 있고 0, 1이 될 수 있는 등 순서를 고려해야 하기 때문이다.

1. String을 글자 하나씩으로 쪼개 digits 배열에 넣는다.
2. 종이조각 하나만을 고려할 땐, digits 배열의 하나하나를 소수인지 판별한다.
3. 2개 이상일 때는 순열로 경우를 뽑는다.
4. 순열을 뽑는 백트래킹 함수에서 정해진 개수만큼 다 뽑았다면, 그 수가 0부터 시작하는지 판별한다.
5. 만약 0부터 시작한다면 그건 정상적인 수가 아니기 때문에 제외하고, 0부터 시작하지 않는다면 그 수 자체가 소수가 되는지 확인한다.

보자마자 순열이라고 생각했고, 바로 문제를 풀 수 있어서 뿌듯했다😏

<br>

<hr>

#### #전화번호 목록

[전화번호 목록 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.09)

처음에는 어떻게 풀지 막막하다가... 해시 카테고리에 있기도 하고, 어떤 번호를 가지고 다른 번호의 접두어인지 확인할 때에 어떤 번호가 그 리스트에 있으면 안 되기 때문에 이를 제거하기 위해서는 해시가 쉬울 것 같아서 해시를 사용하기로 했다.

1. 우선 리스트를 정렬해 준다. 배열이 11911, 119, 1234 이런 식으로 나올 수 있고, 그렇게 되면 11911은 119라는 어떤 번호의 접두어로 시작하지만 제거해 주기 때문에 이를 발견하지 못하기 때문이다.
2. 그리고 만약 배열의 길이가 하나인 경우엔 다른 번호가 나오지 않는다는 말이기 때문에 그대로 반환해 준다.
3. 만약 길이가 1 이상인 경우엔 반복문을 돌려 기준이 되는 어떤 번호를 골라 그 번호에 해당되는 해시 값을 삭제 해준다.
4. 해시 값 리스트를 가지고 와 다른 번호의 접두어가 되는지 확인하기 위해 startWith를 사용한다. 만약 startWith가 true라면 더 볼 필요도 없이 false를 반환한다.

<br>

<hr>

#### #타겟 넘버

[타겟 넘버 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%ED%83%80%EA%B2%9F%20%EB%84%98%EB%B2%84.java)

처음에는 +1과 -1로 이루어진 배열을 순열로 뽑는 과정을 거치려고 했다. 그런데 자꾸 경우가 반복됐다 😥

예를 들어 -1, -1, -1, -1, 1이 있을 때 1, -1, -1, -1, -1 / -1, 1, -1, -1, -1 과 같이 구한 후, 각각을 numbers를 곱한 뒤 더하려고 했는데 경우가 중복되니까 엄청나게 큰 수가 나왔다...😖

그래서 다른 사람 풀이를 참고해 봤다. 다른 사람들도 DFS를 사용하고 백트래킹을 사용한 듯 보이지만 numbers에 집중해서 풀었던 게 결정적으로 달랐다. 결국 재귀 방식인데 재귀는 언제 봐도 헷갈린다. 또 열심히 디버깅 한 후 이해했다. 

이 문제는 재귀 방식을 이해하냐가 가장 큰 관건이기 때문에 이 방법에 대해서 설명하고 넘어가겠다.

**재귀는 문을 열고, 문을 닫는 과정**이라고 생각하면 쉽다. (사실 쉽진 않다😂)

만약 numbers가 4, 2, 6, 1, 5로 주어진다면 경우는 아래와 같이 이루어진다. 

```
4, 2, 6, 1, 5
4, 2, 6, 1, -5
4, 2, 6, -1, -5
4, 2, 6, -1, 5 . . .
```

1. 먼저 다 1을 곱해주는 과정을 끝낸다. 이 과정을 문을 다 열고 가는 과정이라고 생각하면 된다.

2. 문을 다 연 후, numbers[k] = -1;를 만나게 되는데 문을 끝까지 열었기 때문에 현재 k는 4이다. 그러므로 값은 **4, 2, 6, 1, -5**가 된다. 그리고 다시 dfs(target, numbers, k + 1)를 호출하고나선 4번 문을 닫는다.

3. 이제 3번 문을 닫을 시간이다. 3번도 마찬가지로 k[3]에 -1을 곱해주고,  dfs(target, numbers, k + 1)를 호출한다. 이때 다시 4번 문을 연다.

4. 4번의 문을 열어서 1번에서 **3번 문을 열고 4번 문을 향했던 것처럼**(그래서 재귀다! 😲) "다시" 1을 곱한 뒤, dfs(target, numbers, k + 1)를 호출한다. 그러면 값은 **4, 2, 6, -1, -5**가 된다.

5. 이제 다시 문을 닫기 위해 numbers[k] = -1를 만난다. 그러면 값은 **4, 2, 6, -1, 5**가 된다. 다시 dfs(target, numbers, k + 1)를 호출하고 나서 4번 문을 닫는다.

6. 그러면 3번 문까지 모두 닫혔고, 이제 다시 2번 문을 열어줄 차례다. 이 과정도 똑같이 2번 문을 닫기 위해 3번 문을 열고, 4번 문을 열고 또 다시 닫는 과정을 거치게 된다.


<br>

<hr>

#### #위장

[위장 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%EC%9C%84%EC%9E%A5.java) 🕶

내가 생각한 방식은 옷이 나올 수 있는 경우의 수를 조합으로 구하는 것이었다. 그래서 clothes 배열에서 해시로 입력하면서 (해시를 사용한 이유는 옷의 종류와 옷의 이름을 함께 저장하기 위해서다.) 옷이 하나일 경우의 경우의 수를 세주고 또한 set을 선언해서 옷의 종류를 중복 없이 담았다. 그 후, set에서 하나씩 뽑아 type이라는 배열을 만들었고, 이 배열에서 2에서 이 배열의 길이만큼 개수를 점점 늘려주면서 순열로 뽑았다. 

틀린 방식은 아니었다고 생각한다. 하지만 첫 번째 케이스에서 시간 초과가 났고 다른 방식을 사용해야했다. 😥

그래서 찾게 된 방식은 조합이 아니라 옷을 입었을 때 입지 않았을 때의 경우의 수를 계산식을 통해 구하는 것이었다.

예를 들어,  머리:3, 얼굴:2, 옷:1 일 때 아래와 같은 식으로 표현할 수 있다.

```
(3 + 1) * (2  + 1) * (1 + 1) - 1
```

각 항마다 1을 더해준 이유는 이 옷을 입지 않았을 경우를 구한 것이고, 마지막에 1만큼 빼준 이유는 아예 입지 않은 경우는 없기 때문에 그만큼 빼준 것이다.

그래서 나는 아까 처음 생각했던 방식에서 set을 만드는 방식까지는 동일하게 진행했고, 나머지는 옷 type에 대한 key의 개수를 세기 위해 type에 해당하는 value를 갖는 key의 개수를 세주는 방식으로 진행했다.

<br>

<hr>

#### #카펫

[카펫 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%EC%B9%B4%ED%8E%AB.java)

간단하게 풀겠군! 😎 하고 시도했던 문제인데 오늘 푼 문제 중에 제일 이해하기 힘들었다...

처음에는 brown과 yellow의 합이 넓이를 나타내니 넓이를 나타낼 수 있는 약수 중 가로 길이가 세로 길이보다 크거나 같을 때 반환하면 되겠다고 간단히 생각했다. 하지만 4, 6, 7번에서 틀렸다고 나오고... 다른 방법을 더 찾아보기로 했다. 사실 이 문제는 프로그래밍 문제라기 보다는 수학 문제에 더 가까웠다.

수학을 못해서인지... 다른 사람 풀이를 보고도 한참 헤매다가 겨우 이해했다. 😥 

1. brown과 yellow의 합을 rslt라고 정의한다.
2. 반복문을 돌면서 rslt의 약수값을 찾는다. 
3. 만약, 약수라면 가로(width)는 rslt / i 값, 세로(height)를 i값이라고 한다.
4. 이때 yellow는 가운데에 위치해야 하기 때문에 2만큼 빼준다. (여기서 무슨 말인고.. 싶었는데 말 그대로다. 예제 그림이라면, 왼쪽에서 1만큼, 오른쪽에서 1만큼 뺀 위치에 있어야 격자무늬가 된다.)
5. 가로가 세로보다 길거나 같고, 가로와 세로 각각 2를 빼고 곱한 값이 yellow와 같다면 구하고자 하는 값이기 때문에 정답 배열에 넣고 break 해 준다.

<br>

<hr>

#### #주식가격

[주식가격 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%EC%A3%BC%EC%8B%9D%EA%B0%80%EA%B2%A9.java)

다른 사람들도 많이 궁금해 하던데... 왜 이게 스택/큐 카테고리에 있는지 모르겠다. 내가 푼 방식이 문제가 있겠지만... 스택으로 풀었더니 처음에는 정확성, 효율성 모두 꽝이라 다른 사람 풀이를 참고해서 다시 스택으로 풀었으나 효율성에서 땡이었다. 🤦‍♀️

그래서 단순 배열로 풀었다. 그리고 또 많은 사람이 지적했던 것처럼 문제 설명이 좀 부실하다... 이해하는 데 시간이 좀 걸렸다.

<br>

가격이 떨어지지 않고 유지하는 "시간"에 집중하면 된다.

1. 이중 반복문을 돌려 하나는 파라미터 값으로 주어진 배열에서 순서대로 값을 하나씩 배열의 다음 인덱스와 비교한다.
2. 만약 가격이 떨어지는 부분이 있으면 answer에 j - i 값을 넣어준다. 이 이유는 j가 i의 다음 인덱스부터 끝까지 차례대로 나아가고 있기 때문에 j가 i보다 앞장서고 있다고 생각하면 된다. 만약 j에서 값이 꺾인다면 거기까지만 가격을 유지한 것이기 때문이다.
3. 그리고 마지막까지 가격이 떨어지지 않은 경우에 대해선 j가 마지막 인덱스에 위치할 때의 j - i값을 넣어주면 된다.
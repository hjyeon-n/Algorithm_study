# Programmers 👩‍💻

| 문제 이름                        |
| -------------------------------- |
| [문자열 압축](#문자열-압축)      |
| [실패율](#실패율)                |
| [괄호 변환](#괄호-변환)          |
| [오픈채팅방](#오픈채팅방)        |
| [자물쇠와 열쇠](#자물쇠와-열쇠)⭐ |
| [후보키](#후보키)                |
| [비밀지도](#비밀지도)            |

<br>

<hr>

#### #문자열 압축

[문자열 압축 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/문자열%20압축.java)

이 문제는 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 요구한다.

```
예를 들어, ababcdcdababcdcd의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 2ab2cd2ab2cd로 표현할 수 있다. 다른 방법으로 8개 단위로 잘라서 압축한다면 2ababcdcd로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법이다.
```

어려운 문제는 아니었지만, 생각보다 시간이 좀 걸렸던 문제였다. 

압축 단위는 1부터 문자열 s의 길이 1/2까지 올 수 있다. 1/2가 넘으면 겹치는 부분이 없어 압축될 수 없기 때문이다.

일단 정답이긴 하지만, 다른 사람의 풀이를 봤더니 재귀 같은 다른 방식으로 푼 것도 있어 참고하면서 더 공부해야겠다.

내 풀이 방식은 다음과 같다.

1. 문자열을 분리하는 단위를 하나씩 늘려가기 위해 (즉, 2개 단위로 단어를 끊다가 3개 단위로 단어를 끊는 방식) 반복문을 돌린다.

2. 반복문 안에서 1번의 반복 인자만큼의 단위로 자르고, 각각의 것을 보관하기 위해 배열을 선언한다. 만약, 3개의 단위로 자르는데 문자열의 길이가 3으로 나누어 떨어지지 않을 수 있기 때문에 1만큼의 여분 인덱스를 더 선언한다.

3. 문자열 집합에 자른 문자열을 보관할 때도 2번과 마찬가지로 그 단위의 수에 맞게 항상 나누어 떨어지진 않기 때문에 배열에 값을 저장할 때마다 remain이라는 문자열 s의 길이를 저장한 변수에 단위 만큼 빼준다.

4. 만약 단위는 3, remain이 2라면 배열에 남은 문자열을 다 저장하고, 반복문에서 빠져나온다.

5. 문자열 배열의 값들은 equals 함수를 통해 비교한다.

6. 이때, aa 뿐만 아니라 aaa 같이 반복의 수가 정해져 있지 않으므로, 주의해야 한다.

   예를 들어, cccab라는 문자열이 있다고 하자. 문자열을 자르는 단위는 1이고, 현재 위치는 0이라고 하면 c는 3번 반복되기 때문에 3c가 될 것이다. 이후 인덱스는 다시 2로 넘어갈 필요없이 (이미 검사를 진행했으므로) 인덱스 4의 값 a로 넘어가면 된다. 이때 반복의 수를 저장하는 m을 선언해 m은 3이 되고, 인덱스의 값은 다시 원래대로 돌려줘야하기 때문에 idx - m을 해준다.

7. cnt가 1보다 더 크면 중복되는 값이 있기 때문에 cnt와 함께 str[idx]를 새로운 문자열 newStr에 저장한다.

8. cnt가 1보다 작으면 중복 값이 없기 때문에 str[idx]를 newStr에 저장한다.

9. 2번부터 8번까지의 반복이 끝나면 원래 문자열 s의 길이를 저장한 answer와 새로운 문자열 newStr의 길이를 비교해 작은 값을 저장한다.

10. 1의 과정으로 넘어가 다시 반복한다.

<br>

<hr>

#### #실패율

[실패율 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/실패율.java)

아주 쉬운 문제였지만 Comparator가 까다로웠다. 파이썬으로 하면 람다식으로 깔끔하게 코드를 짤 수 있으나 자바로 하면 아무래도 코드가 좀 지저분해지는 건 어쩔 수 없다...😥

Comparator 부분은 종종 나오기 때문에 아예 개념으로 따로 정리하려고 한다. 여기서는 그냥 단순 문제 풀이만 정리해야지.

✅ 추가 완료! [Comparable과 Comparator 개념 정리](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/Comparable%EA%B3%BC%20Comparator.md)

<br>

1. 스테이지 개수만큼 실패율을 저장해야 하기 때문에 fail이라는 Stage형 배열을 선언한다. (Comparator을 위해 따로 Stage라는 클래스를 정의한 뒤, 객체로 사용한다.)
2. stages를 돌며 스테이지 개수를 찾아야 하기 때문에 double형 cnt를 선언한다. (int형으로 선언 뒤, typecasting도 가능하다.) 이때, 스테이지는 1 ~ N이 올 수 있고 stages의 값들도 이러한 값들이 오기 때문에 2번은 1번의 반복문 안에서 돌아야 한다.
3. fail 배열에 인덱스인 idx, 실패율인 cnt / userNum을 넣는다.
4. 유저의 수는 처음엔 stages의 길이와 동일하고, 반복문을 돌 때마다 cnt만큼 빼야 한다.
5. 1번의 반복문이 끝이 나면 Comparator를 통해 실패율을 기준으로 idx를 내림차순으로 정렬한다.

<br>

<hr>

#### #괄호 변환

[괄호 변환 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/괄호%20변환.java)

문제에 설명돼 있는 알고리즘대로 코드를 짜면 된다. 하지만 재귀가 간만이었기도 했고, 이상한 부분에서 시간을 많이 소비했다😖

이 문제는 하나의 기능을 하나의 함수로 빼놓으면 더 간단하고, 한 눈에 보이는 좋은 코드를 짤 수 있다는 걸 보여주는 좋은 문제였다!

<br>

```
1. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다. 
2. 문자열 w를 두 "균형잡힌 괄호 문자열" u, v로 분리합니다. 단, u는 "균형잡힌 괄호 문자열"로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다. 
3. 문자열 u가 "올바른 괄호 문자열" 이라면 문자열 v에 대해 1단계부터 다시 수행합니다. 
  3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다. 
4. 문자열 u가 "올바른 괄호 문자열"이 아니라면 아래 과정을 수행합니다. 
  4-1. 빈 문자열에 첫 번째 문자로 '('를 붙입니다. 
  4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다. 
  4-3. ')'를 다시 붙입니다. 
  4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다. 
  4-5. 생성된 문자열을 반환합니다.
```

나는 기능을 크게 4가지로 나누었고, 각각의 기능마다 함수를 새로 정의했다.

1. *divideStr* : 문자열 w를 두 "균형잡힌 괄호 문자열" u, v로 분리
2. *isFine* : 문자열이 "올바른 괄호 문자열" 인지 확인
3. *reverse* : 문자열의 괄호 방향을 뒤집음
4. *makeStr* : 문자열 생성 (4번의 과정)

<br>

처음에는 4번의 과정을 따로 함수로 빼지 않고 solution 함수에서 진행했다. 아마도 재귀 중에 문자열의 값이 계속 바뀌어서 원하는 답이 나오지 않았는데, 따로 함수로 빼서 u와 v를 매개변수로 둔 후 정의했더니 값이 바뀌지 않아 값이 제대로 나왔다. 이 부분에 대해선 좀 더 디버깅하고 확실히 익혀야겠다.

2번의 경우도 처음에는 flag 변수로 둬서 올바른 괄호를 체크하려고 했으나, '(' 다음에 바로 나오는 ')'을 어떻게 표현해야 하나 고민하다가 예전에 BOJ에서 풀었던 [괄호](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_9012.java) 문제를 참고했다. 참 내가 풀어놓고선 또 까먹어버렸다...😫

다른 함수는 직관적이고, 문제에 나온 설명 그대로를 따르기 때문에 풀이는 생략한다.

<br>

<hr>

#### #오픈채팅방

[오픈채팅방 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.09/%EC%98%A4%ED%94%88%EC%B1%84%ED%8C%85%EB%B0%A9)

아주아주 쉬웠던 문제! 두 가지 버전으로 푸는 데 1시간도 안 걸렸던 것 같다.

문제 풀이는 처음 생각했던 방식과 개선된 방식 둘 다 설명할 것이다. 물론, 두 방법 다 정답이다.😎

<br>

```
채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.

- 채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다.
- 채팅방에서 닉네임을 변경한다.

닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다.

채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라.
```

🖥 첫 번째 방법

1. 닉네임이 중복되는 경우도 있고, 닉네임이 변경되면 기존 닉네임의 메시지들도 다 수정해줘야 하기 때문에 HashMap을 정의한다.

2. 기록들을 메시지들로 나타내기 위해 record의 수만큼 반복문을 돌린다.

3. 1번의 반복문 안에서 record의 원소 하나를 꺼내 공백을 기준으로 split한 뒤, String형 배열 str에 저장한다 . 

   (예: Leave uid123 → str[0] = Leave, str[1] = uid123)

4.  Leave, Enter 등 명령어는 항상 첫 단어에 나오기 때문에 str[0]이 어떤 값이 나오느냐에 따라 다르게 처리하도록 switch문을 정의한다. (예: Enter는 닉네임을 변경할 수 있고, 처음 들어올 수도 있기 때문에 map을 통해 id에 해당하는 닉네임을 설정해준다.)

5. 4번의 결과물에 따라 다시 switch문을 통해 메시지를 작성해 answer 배열에 저장하고 반환한다.

<br>

4, 5번의 과정은 거의 흡사하기 때문에 하나의 함수로 묶어주었다.

새로운 rslt 배열을 생성해서 명령어와 uid를 다시 넣어주었고, 4번의 switch문에서의 핵심 역할은 닉네임의 변경을 위한 map 사용이었다.

사실 이 방식은 많은 문제점이 있었다. 

1. 같은 함수를 사용하기 때문에 닉네임 변경 과정 / 메시지 생성 과정에 따라 달라지는 부분은 flag와 같은 매개변수를 통해 구분해야했다. (변경 과정은 0, 생성 과정은 1)
2. 이게 가장 큰 문제였는데, Change 같은 경우는 닉네임 변경에만 영향을 미치지 메시지 출력과는 상관이 없었다. 하지만 이 방식은 변경과정과 생성과정 모두 새로운 배열 rslt에 넣는 방식이었다. 즉, Change도 포함한 만큼 배열의 크기가 할당되기 때문에 **Change가 빠지면서 남은 자리는 null이 들어가고** 그러면 잘못된 값을 출력했다. 리스트를 사용하면 되지만, 나는 같은 함수를 사용하려고 했기 때문에 cnt라는 전역변수를 사용해 Change의 반복 횟수만큼 배열의 크기를 줄여주었다.

정답이긴 했지만, 다른 풀이로 한 번 더 풀어야겠다고 생각했다.

<br>

🖥 두 번째 방법

이 방법은 함수로 따로 정의하지 않고 메인에서 한 번에 진행했다.

1. 닉네임 변경을 위한 HashMap 자료구조와 메시지를 넣을 List형 자료구조를 선언한다.
2. 첫 번째 방법의 2, 3 과정
3. str 길이가 2 이상이라는 건 Change, Enter를 의미하고 이는 닉네임 변경과 관련돼 있다.
4. 다만, Change의 경우 메시지 생성과 관련이 없기 때문에 Change가 아닐 경우에만 list에 str[0], str[1]을 삽입한다.
5. 메시지 생성 과정이 끝난 후, 답을 반환할 answer 배열을 선언한다.
6. list의 길이만큼 돌면서 answer에 메시지를 넣어준다. 이때, map에서 아이디에 해당하는 닉네임을 꺼내면 된다.

<br>

아까의 문제점을 한 방에 없애주는 풀이였다. 이건 사실 나 스스로 짰다기 보다는 다른 사람의 풀이 중 괜찮은 알고리즘을 골라 내 방식대로 다시 풀어낸 것이다. 여러 방식을 알 수 있게 됐고 조금이라도 개선된 방향으로 코드를 짠 것 같아서 기분이 좋다 🌷

<br>

<hr>
⭐⭐⭐⭐⭐

#### #자물쇠와 열쇠

[자물쇠와 열쇠 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%EC%9E%90%EB%AC%BC%EC%87%A0%EC%99%80%20%EC%97%B4%EC%87%A0.java)

프로그래머스 문제를 풀면서 처음으로 답을 보고 풀었던 문제... 안 보려고 노력했지만 도저히 감이 잡히지 않았다. 따쉬...🤦‍♀️

처음 생각했던 아이디어는 이랬다.

1. 열쇠의 크기는 자물쇠의 크기보다 작거나 같으므로, 열쇠가 동 서 남 북 & 회전할 때의 모든 경우를 다 탐색한다.
2. 즉, 동쪽으로 가면 동 서 남 북으로 또 갈 수 있는 방향이 있고 여기서 또 동쪽으로 가면 다시 동서남북... 이런 식으로 재귀가 이루어질 것이다.

하지만 결국 구현하지 못했다... 일단 시간 초과가 날 것 같기도 했고, 무엇보다 재귀로 어떻게 짤 지 감이 잘 잡히지 않았다. 

예를 들어... 동쪽 끝까지 진입했을 때 다시 하나씩 돌아가면서 다른 방향으로 전진한다? 말로도 이미 복잡하고 다른 방법이 더 있지 않을까 고민하다가 머리가 터질 것 같아서🤯 결국 해설을 봤다.

<br>

근데 해설을 봐도 이해가 안 되는데...? 😇

소리 지르다가 결국 다른 사람 풀이를 봤는데 여기서도 이해가 안 돼서 한참 고민했다...

이해가 안 된 부분

1. 왜 3배를 확장해줘야 하나
2. 확장해서 푼 게 어떻게 동서남북을 다 이동해 본 것 같은 거라는 거지?

결국 같은 의미인데 나는 그림을 하나씩 그려서 생각해 봤다.

![image](https://user-images.githubusercontent.com/62419307/92690343-cdf2f480-f37b-11ea-8591-0854e91393f4.png)

[그림 출처](https://travelbeeee.tistory.com/415)

2번은 직접 그림을 그려보니 결국 모든 경우를 탐색하는 것과 결과가 같았기 때문에 이해를 했는데... 왜 3배를 확장했을까 더 고민했다.

찾아보니 lock.length + (key.length - 1) * 2 만큼 확장하는 사람이 많았다. 

3배만큼 확장하는 건 그냥 넉넉하게 잡아준 것 같고, 실제로 그려보면 3배만큼 확장했을 땐 처음의 경우가 그림의 첫번째 부분처럼 겹쳐서 시작하지 않는다. 이 무의미한 경우를 빼준 게 lock.length + (key.length - 1) * 2인 것 같다.

다음엔 왜 이런 식이 나왔는지 고민했다.

![image](https://user-images.githubusercontent.com/62419307/92691920-5c687580-f37e-11ea-99b6-49a8bcb7f77d.png)

이것도 그림을 그려보면서 이해했다. 가운데 lock의 길이와 key 길이에서 겹친 key 부분 (처음 겹치는 길이가 1)을 빼주면 이런 식이 나온다.

난 [해설](https://tech.kakao.com/2019/10/02/kakao-blind-recruitment-2020-round1/)처럼 3배 만큼 확장한 범위를 사용했다.

<br>

#### 드디어 문제 풀이다!

회전과 동서남북 이동이 있고,  회전도 90, 180, 270, 360(0)의 4가지 경우가 필요하기 때문에 우선 회전을 한 뒤 그 회전한 key를 가지고 이동을 시키면 된다.

1. 자물쇠 배열의 3배의 크기로 확장한 map을 정의한 후, map의 가운데에 자물쇠 배열을 삽입한다.
2. key 배열을 회전시킨다.
3. 이제 탐색을 시작한다. 탐색은 0부터 map.length - key.length 만큼 반복문을 돌리면서 수행한다.
4. 3번의 반복문 안에서 열쇠를 자물쇠에 끼우는 과정을 거친다.
5. 4번의 결과가 전부 1인지 확인한다. 만약 1이 아니면 다시 값을 원래대로 돌려놓고, 1이면 탐색을 종료한다.

<br>

<hr>

#### #후보키

[후보키 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.09/%ED%9B%84%EB%B3%B4%ED%82%A4.java)

풀다가 열받아서 무슨 만화처럼 머리 헝클어뜨리면서 소리 질렀다...😇

어려운 문제가 아닐지는 몰라도 나에게 너무나 어려웠기 때문... 🤯 ~~(나한테 어려우면 다 어려운 문제다. 흥)~~

정말 기이이인 시간동안 풀었고, 18 19 20 22 25 << 이 테스트케이스에서 자꾸 틀려서 포기할까도 했지만 포기하기엔 너무 멀리 와서 끝까지 풀었고 결국 해냈다... 난 진짜 멋있는 어른이다... 🤸‍♀️

<br>

```
관계 데이터베이스에서 릴레이션(Relation)의 튜플(Tuple)을 유일하게 식별할 수 있는 속성(Attribute) 또는 속성의 집합 중, 다음 두 성질을 만족하는 것을 후보 키(Candidate Key)라고 한다.

- 유일성(uniqueness) : 릴레이션에 있는 모든 튜플에 대해 유일하게 식별되어야 한다.
- 최소성(minimality) : 유일성을 가진 키를 구성하는 속성(Attribute) 중 하나라도 제외하는 경우 유일성이 깨지는 것을 의미한다. 즉, 릴레이션의 모든 튜플을 유일하게 식별하는 데 꼭 필요한 속성들로만 구성되어야 한다.
```

후보키는 속성 1개가 될 수도 있고 그 이상일 수도 있다. 이 모든 경우를 따지기 위해서는 조합이 필요하다. 

나는 DFS 백트래킹으로 조합을 구했다.  인덱스 배열을 만든 뒤 그 배열에서 1 ~ 행의 개수까지 뽑는 수를 늘려가면서 풀었다.

1. 유일성을 구하기 위해서

   모든 튜플에 대해 유일하게 식별되어야 한다는 건 해당 속성에서의 튜플이 모두 유일하게 식별이 돼야 한다는 뜻이고, 조합의 결과로 가지고 온 인덱스를 이용해 relation의 튜플을 뽑아내 **튜플(열)의 수만큼 반복문을 돌면서 유일한 값인지 판별하려고 했다.**

   relation이 String 타입인 점을 이용해 str이라는 문자열을 선언하고 그 값에 값들을 하나씩 더해갔다.

   (예를 들어, 조합의 결과로 1, 2라는 인덱스 값이 나왔다면, i를 반복인자로 하여 튜플의 길이만큼 relation[i] [1]와 relation[i] [2]를 더해주면 된다.  그러면 "apeach math"와 같은 값들이 set에 차례대로 저장될 것이다.)

   이를 위해서 set 자료구조를 사용했다. 그리고 set의 size와 튜플의 수를 비교했다. 만약 다르면 중복값이 있었다는 뜻이기 때문에 다음 조합의 값으로 넘어간다. 

   같은 경우엔... 최소성을 따져봐야 한다. 사실 여기서 문제가 돼서 삽질을 열심히 했다. 🌪 

   <br>

2. 최소성을 구하기 위해서

   결론적으로 말하면 **후보키를 저장한 값들(별도로 리스트에 저장됨)과 현재 조합의 결과로 나온 값을 비교하면 된다.**

   contains를 사용하면 되는데 그냥 단순히 리스트의 값과 현재 값을 비교하면 안 된다!!!!! 😭 (여기에서 제일 오래 고민했다)

   예를 들어, 리스트에 있는 값은 1, 3 비교 대상인 1, 2, 3은 최소성에 위배되는데 1, 3이 포함된다는 것을 알기 위해서는 **1과 3이 포함되어있는지 따로따로 검사해야 한다.** 그러기 위해서 나는 charAt을 사용해 String의 값을 따로 분리해낸 뒤 비교했다.

<br>

다른 사람의 풀이를 참고하려고 했는데 나는 너무나 먼 길을 와서... 결국 스스로 풀었지만 내가 봐도 너무 복잡해서 다른 사람의 풀이를 더 찾아봤는데 대부분 비트마스킹으로 풀고 있어서 우선, 비트마스킹 개념 정리부터 해야겠다.

<br>

<hr>

#### #비밀지도

[비밀지도 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.09/%EB%B9%84%EB%B0%80%EC%A7%80%EB%8F%84)

이제까지 풀었던 프로그래머스 문제 중 가장 쉬웠다. 보자마자 비트마스킹으로 풀면 되겠다고 생각했다. 

그래서 toBinaryString으로 이진수로 바꾸고 포맷을 맞춰준 뒤, int로 바꿔서 비트마스킹으로 풀려고 했는데 Integer.parseInt는 단순히 다른 타입을 정수로 바꿔주는 게 아니라 **정수 형태로 바꿔준다는 사실**을 간과했다.

그러니까 01001이라는 String을 int로 바꾸면 1001이 된다. 그래서 첫 번째 방법은 단순히 String 비교로 문제를 해결했다.

첫 번째 방법

1. arr1, arr2에 있는 정수를 하나씩 꺼내서 이진수로 바꿔준 뒤 자릿수를 맞춰주기 위해 앞자리에 0을 추가하는 과정을 거친다.
2. 위의 과정은 결과값이 String 형태로 나오고 각각의 결과값을 str1, str2라고 한다면 charAt을 이용해 하나하나 비교해서 새로운 문자열 answerStr을 선언해 둘다 0일 때만 answerStr에 공백을 더해주고 그렇지 않으면 #을 더해준다.
3. answerStr을 answer 배열에 넣는다.

<br>

위 방법으로 일단 정답이 되었지만 다른 사람 풀이를 보니 내가 처음에 생각했던 것처럼 비트마스킹으로 푼 풀이가 있어서 다시 한 번 풀었다.

두 번째 방법

1. 이진수로 바꿔주기 전에 비트마스킹으로 정수 값을 구해준 뒤, 그 값을 이진수로 바꿔주었다.
2. 1의 값을 answer 배열에 하나씩 넣어준다.
3. 자릿수를 맞춰주기 위해 format을 사용하고, 1은 #으로 0은 공백으로 바꿔준다.

<br>

요즘은 문제를 푸는 것도 중요하지만 더 효율적인 방식이 있을까 고민하게 되는데 이번 문제가 그 중요성을 더 일깨워줬다.

아직 문제를 맞히는 것도 힘들지만 좀 더 실력이 향상되면 클린 코드를 짜는 데도 더 심혈을 기울일 수 있는 사람이 되야겠다 💪 










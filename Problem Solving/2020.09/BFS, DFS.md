# BFS, DFS

BFS, DFS로 푼 문제

| 문제 번호 | 이름                        |
| --------- | --------------------------- |
| 1707      | [이분 그래프](#이분-그래프) |

<br>

<hr>

#### #이분 그래프

[이분 그래프 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.09/Solution_1707)

하루종일 이것만 풀긴 했지만 후회 없다... 😏

너무너무 재밌게 풀었고, 여러 채점 결과가 나와서 그때마다 수정하는 과정도 너무 재밌었다!

<br>

~ 실패의 역사 ~

1. **메모리 초과**

   제일 처음 생각했던 건 말 그대로 배열을 2개 (예를 들어 A, B) 선언해서 정점들을 조사해 각각의 배열로 나누려고 했다.

   <br>

   나는 정점 X를 A 혹은 B 배열에 넣을 때마다 그 배열 안에서 X와 인접한 점이 있는지 확인해야 한다고 생각했고, 코드도 더러워지고 생각도 복잡해져서 다른 방법을 생각했다.

   따라서 생각한 방법이 A, B 배열의 아이디어는 그대로 가져오되, arr라는 boolean 배열을 선언해서 T (A팀)/F (B팀)로 팀을 나누자고 생각했고, 배열이 하나로 줄고, 값도 간단해져서 쉽게 코드를 짤 수 있었다.

   1. 방문여부를 확인하는 visited[], 팀 구별을 위한 boolean 타입 arr[], 그래프의 인접행렬 map[] []을 선언한다.
   2. 어떤 점들과도 인접하지 않은 점들도 있기 때문에 visited 배열을 이용해 방문하지 않은 정점이 있으면 다시 BFS를 할 수 있도록 반복문을 돌린다.
   3. BFS 함수 안에서 시작점을 true로 둔다.(그러면 초기값인 false랑 다른 팀)
   4. 정점만큼 반복문을 돌면서 인접해 있고, 방문하지 않은 점이면 큐에 넣는다.
   5. **만약 현재 정점(큐에서 나온 점) x가 false 값이면, x의 인접 정점들이 아직 팀이 정해지지 않을 수도 있기 때문에(false는 팀 B를 나타내기도 하지만, 초기값이니까!) arr 배열의 값이 true인 정점들과 인접해 있는지 확인한다. **
   6. **인접한다면, true인 A팀에서도 인접한 점이 있고, x의 인접 정점에서 시작한 것이므로 x와 같은 팀 B에도 속할 수 없기 때문에 반복문에서 빠져나온다.** 

   <br>

   당연히 정답일 거라 생각했는데 간선이 20000이 나올 수도 있기 때문에 그러면 이차원 배열로 접근하는 경우 메모리 초과가 날 수 있다네요... 일단 난 메모리 초과가 났고 그대로 실패했다. 😭

   <br>

2. **시간 초과**

   인접 행렬에서 인접 리스트로 바꿨다. 인접 리스트로 푸는 건 처음이라 다른 분의 코드를 살짝 참고했다. 인접 리스트로 푸는 것도 익숙해져야겠다!

   사실 시간 초과 전에 몇 번의 틀렸습니다가 뜨긴 했지만 로직은 그대로 두되, 인접 행렬에서 리스트로 바꾸면서 약간의 실수가 있어서 그 부분은 따로 언급 안 해도 될 것 같다!

   1번 메모리 초과의 5번, 6번 과정이 아마 시간 초과를 일으킨 주범인 것 같다. 어떤 팀에 할당하기 전, 그 팀에 있는 점들과 인접하는지를 검사하기 위해 팀 내 모든 정점을 하나하나 확인해 봤기 때문인 듯.

   결국 다른 분의 코드를 좀 더 참고했다.

   <br>

3. **드디어 맞았습니다.**

   다른 분의 코드는 색깔을 정하는 방식이었다. 예를 들어 RED는 -1, BLUE는 1이라고 정하고 내 arr 같은 아이디어로 colors라는 배열을 만들어 거기에 B / R를 표현하셨다.

   정말 멋있는 방식이다! 라고 생각했던 이유는 나는 visited 배열을 따로 둬서 방문 여부를 확인했는데 이 분은 colors라는 배열을 0으로 초기화해 방문하지 않은 점은 0이고 방문했을 때는 R / B 중 하나로 표시해 arr + visited 역할을 한 번에 해냈다는 것이다...! 😲

   1. BFS이기 때문에 정점 A와 인접한 정점에 대해서 다시 BFS를 하게 될 것이다.
   2. colors 값이 0이면 즉, 방문하지 않았다면 1번 이유에 의해 이미 인접하고 있음을 알고 있기 때문에 정점 A의 색깔과 반대로 해주기 위해 -1을 곱한다.
   3. 만약 방문한 점이라면 정점 A와 해당 정점의 색을 비교한다. 색이 같지 않으면 0이어야 하는데 만약 0 값이 아니라면 같은 색이기 때문에 더이상 탐색할 필요도 없이 중단하면 된다.

   <br>

4. **다시 수정 뒤 최종 통과**

   왠지 내가 생각했던 방식도 약간의 수정만 있으면 통과가 될 수 있을 거라는 생각에 수정을 했다.

   나는 colors 대신 visited, arr를 사용했다.

   1. BFS이기 때문에 정점 A와 인접한 정점에 대해서 다시 BFS를 하게 될 것이다.
   2. 방문하지 않았다면 visited에 방문 여부를 표시하고 arr의 값은 정점 A와 반대로 해주기 위해 비트마스킹을 사용했다.
   3. 방문했다면, arr의 값을 비교한 후 값이 같으면 더이상 탐색할 필요 없이 return한다.

<br>

시간은 오래 걸렸지만 포기하지 않고 끝까지 도전한 내가 너무 대견스러웠다 🌱

자신감이 떨어져서 괴로울 때도 있지만 이런 순간을 생각하면서 버텨야지🌳










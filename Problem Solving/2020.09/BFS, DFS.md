# BFS, DFS

**BFS, DFS로 푼 문제**

| 문제 번호 | 이름                        |
| --------- | --------------------------- |
| 1707      | [이분 그래프](#이분-그래프) |

<br>

**BFS로 푼 문제**

| 문제 번호 | 이름              |
| --------- | ----------------- |
| 5567      | [결혼식](#결혼식) |
| 2638      | [치즈](#치즈)     |
| 2636      | [치즈](#치즈)     |

<br>

<hr>

#### #이분 그래프

[이분 그래프 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.09/Solution_1707)

하루종일 이것만 풀긴 했지만 후회 없다... 😏

너무너무 재밌게 풀었고, 여러 채점 결과가 나와서 그때마다 수정하는 과정도 너무 재밌었다!

<br>

~ 실패의 역사 ~

1. **메모리 초과**

   제일 처음 생각했던 건 말 그대로 배열을 2개 (예를 들어 A, B) 선언해서 정점들을 조사해 각각의 배열로 나누려고 했다.

   <br>

   나는 정점 X를 A 혹은 B 배열에 넣을 때마다 그 배열 안에서 X와 인접한 점이 있는지 확인해야 한다고 생각했고, 코드도 더러워지고 생각도 복잡해져서 다른 방법을 생각했다.

   따라서 생각한 방법이 A, B 배열의 아이디어는 그대로 가져오되, arr라는 boolean 배열을 선언해서 T (A팀)/F (B팀)로 팀을 나누자고 생각했고, 배열이 하나로 줄고, 값도 간단해져서 쉽게 코드를 짤 수 있었다.

   1. 방문여부를 확인하는 visited[], 팀 구별을 위한 boolean 타입 arr[], 그래프의 인접행렬 map[] []을 선언한다.
   2. 어떤 점들과도 인접하지 않은 점들도 있기 때문에 visited 배열을 이용해 방문하지 않은 정점이 있으면 다시 BFS를 할 수 있도록 반복문을 돌린다.
   3. BFS 함수 안에서 시작점을 true로 둔다.(그러면 초기값인 false랑 다른 팀)
   4. 정점만큼 반복문을 돌면서 인접해 있고, 방문하지 않은 점이면 큐에 넣는다.
   5. **만약 현재 정점(큐에서 나온 점) x가 false 값이면, x의 인접 정점들이 아직 팀이 정해지지 않을 수도 있기 때문에(false는 팀 B를 나타내기도 하지만, 초기값이니까!) arr 배열의 값이 true인 정점들과 인접해 있는지 확인한다. **
   6. **인접한다면, true인 A팀에서도 인접한 점이 있고, x의 인접 정점에서 시작한 것이므로 x와 같은 팀 B에도 속할 수 없기 때문에 반복문에서 빠져나온다.** 

   <br>

   당연히 정답일 거라 생각했는데 간선이 20000이 나올 수도 있기 때문에 그러면 이차원 배열로 접근하는 경우 메모리 초과가 날 수 있다네요... 일단 난 메모리 초과가 났고 그대로 실패했다. 😭

   <br>

2. **시간 초과**

   인접 행렬에서 인접 리스트로 바꿨다. 인접 리스트로 푸는 건 처음이라 다른 분의 코드를 살짝 참고했다. 인접 리스트로 푸는 것도 익숙해져야겠다!

   사실 시간 초과 전에 몇 번의 틀렸습니다가 뜨긴 했지만 로직은 그대로 두되, 인접 행렬에서 리스트로 바꾸면서 약간의 실수가 있어서 그 부분은 따로 언급 안 해도 될 것 같다!

   1번 메모리 초과의 5번, 6번 과정이 아마 시간 초과를 일으킨 주범인 것 같다. 어떤 팀에 할당하기 전, 그 팀에 있는 점들과 인접하는지를 검사하기 위해 팀 내 모든 정점을 하나하나 확인해 봤기 때문인 듯.

   결국 다른 분의 코드를 좀 더 참고했다.

   <br>

3. **드디어 맞았습니다.**

   다른 분의 코드는 색깔을 정하는 방식이었다. 예를 들어 RED는 -1, BLUE는 1이라고 정하고 내 arr 같은 아이디어로 colors라는 배열을 만들어 거기에 B / R를 표현하셨다.

   정말 멋있는 방식이다! 라고 생각했던 이유는 나는 visited 배열을 따로 둬서 방문 여부를 확인했는데 이 분은 colors라는 배열을 0으로 초기화해 방문하지 않은 점은 0이고 방문했을 때는 R / B 중 하나로 표시해 arr + visited 역할을 한 번에 해냈다는 것이다...! 😲

   1. BFS이기 때문에 정점 A와 인접한 정점에 대해서 다시 BFS를 하게 될 것이다.
   2. colors 값이 0이면 즉, 방문하지 않았다면 1번 이유에 의해 이미 인접하고 있음을 알고 있기 때문에 정점 A의 색깔과 반대로 해주기 위해 -1을 곱한다.
   3. 만약 방문한 점이라면 정점 A와 해당 정점의 색을 비교한다. 색이 같지 않으면 0이어야 하는데 만약 0 값이 아니라면 같은 색이기 때문에 더이상 탐색할 필요도 없이 중단하면 된다.

   <br>

4. **다시 수정 뒤 최종 통과**

   왠지 내가 생각했던 방식도 약간의 수정만 있으면 통과가 될 수 있을 거라는 생각에 수정을 했다.

   나는 colors 대신 visited, arr를 사용했다.

   1. BFS이기 때문에 정점 A와 인접한 정점에 대해서 다시 BFS를 하게 될 것이다.
   2. 방문하지 않았다면 visited에 방문 여부를 표시하고 arr의 값은 정점 A와 반대로 해주기 위해 비트마스킹을 사용했다.
   3. 방문했다면, arr의 값을 비교한 후 값이 같으면 더이상 탐색할 필요 없이 return한다.

<br>

시간은 오래 걸렸지만 포기하지 않고 끝까지 도전한 내가 너무 대견스러웠다 🌱

자신감이 떨어져서 괴로울 때도 있지만 이런 순간을 생각하면서 버텨야지🌳

<br>

<hr>

#### #결혼식

[결혼식 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_5567.java)

처음에는 [바이러스](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_2606)문제랑 비슷하다고 생각했는데 막상 풀어보니 오히려 [탈출](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_3055.java) 문제랑 더 비슷했다.

바이러스 문제처럼 무방향 그래프이며, visited 배열을 1차원으로 생각해야 하지만 탈출 문제처럼 모든 정점을 탐색하는 게 아니라 조건을 줘서 멈춰줘야 했다. 

결론적으로 말하면 푸는 데 10분 걸렸나...? 확실히 이 문제 이거랑 비슷한데? 하는 느낌이 생기니까 빨리 푸는 것 같다. 그래도 아직은 어렴풋이 생각만 나서 다시 그 문제로 가야 하는 게 문제지만... 

<br>

1. 무방향 그래프이기 때문에 1, 2가 친구이면 2, 1이 친구임도 표시한다.
2. bfs를 시작한다.
3. 문제의 조건이 **친구와 친구의 친구**이기 때문에 친구의 친구의 친구... 같은 경우는 고려하면 안 된다. 따라서 상근이의 친구만 탐색해야 한다.
4. 따라서 반복문을 돌며 map의 값이 1인지 (즉, 친구인지) 검사하면서 상근이의 친구 정점만 큐에 넣는다.
5. 큐의 크기를 별도의 변수에 저장하고, 이 크기만큼만 큐에서 정점을 뽑아내서 탐색한다. 이때, 방문한 정점을 큐에 삽입하지 않고 넘어간다.
6. 메인 함수로 돌아와서 visited 배열에 true 값이 몇 개인지 세고, 상근이를 빼야 하기 때문에 1을 빼고 출력한다.

<br>

5번의 경우 따로 별도의 변수에 저장하지 않고 큐에 정점이 없을 때까지 while문을 돌려서 해결해도 된다. 이 방법이 미미하지만 실행속도가 더 빨랐다.

<br>

<hr>

#### #치즈 

[치즈 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_2638.java) 

[토마토](https://www.acmicpc.net/problem/7576)와 비슷한 문제라고 생각했다. 그래서 visited 배열에 치즈가 녹는 날을 저장하려고 했다.

1. 치즈가 있는 격자에서 두 모서리 이상이 공기와 접촉하고 있으면 visited 배열에 1을 저장했다. 즉, map == 1이고 visited가 0일 때 cnt를 셌고, 그 cnt가 2 이상일 때 visited 배열 값을 넣어주는 방식이었다.
2. 1번은 dx, dy 배열만큼 반복문을 돌면서 이루어지는 일인데 단순히 visited 배열에 1을 저장하면, 결국 모든 격자의 visited가 1이 될 테고, 그건 처음 의도와 달랐다. 그렇다고 nx, ny를 사용하자니 반복문 밖으로 나와 cnt를 체크해야 해서 대략난감의 상황이 이어졌다... 😥

그리고 큐에 어떤 수를 넣어야 할 지 감도 잘 안 잡혔다... 계속 고민하다가 다른 분의 풀이를 참고했다.

<br>

보통 다른 풀이들은 나처럼 '치즈'에 집중한 게 아니라 '공기'에 집중했다. 그리고 시간도 visited 배열같이 이미 있는 배열을 활용한 게 아니라 별도의 변수를 선언해서 사용했고, 치즈가 녹기 때문에 map의 모든 수가 0이 될 때까지 반복문을 돌리는 과정을 사용했다.

1. 입력을 받으면서 모두 0인지 확인한다. 만약 모두 0이라면 더 볼 필요가 없기 때문에 바로 0을 출력한다. (이건 내 풀이!)
2. 치즈가 녹는 일을 세는 time을 0으로 선언하고, map의 모든 값이 0인지를 체크하는 chek 함수를 선언한다.
3. 2번의 반복문 안에서 visited 배열을 초기화해준다. 하루에 치즈가 녹을 때마다 다시 돌아와서 visited 배열을 다시 처음으로 돌려줘야 하기 때문이다. (즉, 다시 BFS를 진행해야 하기 때문!)
4. BFS를 진행한다.
5. 치즈의 외부에 더 중점을 주기 때문에 map의 값이 0이고 (즉, 치즈가 아니고) 아직 방문하지 않았다면 visited 배열에 1을 넣어 방문 표시를 해주고, 해당 좌표를 큐에 삽입한다.
6. 만약 치즈를 만난다면, visited 배열을 1만큼 증가시켜준다. 이는 외부에서 치즈를 만날 수 있는 경우의 수를 세준다고 보면 된다. 그렇기 때문에 2 이상이라면 치즈가 외부에 접해있다는 뜻이기 때문에 치즈는 녹을 것이다. 따라서 map의 값을 0으로 만들어준다.
7. BFS가 끝나면 다시 메인으로 돌아와 map의 모든 값이 0인지를 체크한다. 그렇지 않다면 time을 증가시켜주고 다시 반복문으로 돌아간다.
8. 모두 0이라면 while 반복문에서 빠져나와 time을 출력한다.

<br>

<hr>

#### #치즈

[치즈 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_2636.java)

위의 치즈 문제보다 더 쉬운 문제다. 원래 이거부터 풀어야 하는데... 거꾸로 풀었다😳

다만 이번 문제는 치즈가 다 녹기 전 마지막 치즈의 개수를 세줘야 한다. 풀이는 위의 풀이와 다른 점만 간단히 쓰고 넘어가야지.

1. tmp를 정의하고, map을 입력 받으면서 값이 1인 경우 tmp를 증가시킨다. 즉, tmp는 초기 치즈의 개수로 초기화해준다.
2. 마찬가지로 치즈의 외부에 더 집중해야 한다. 이 문제의 경우, 접촉해 있는 면의 수가 중요한 게 아니라 외부와 접촉하면 무조건 1시간 뒤 녹게 되므로 map의 값이 1이면 방문 표시를 해 주고 바로 map을 0으로 바꿔준다.
3. 2번의 과정(BFS)이 끝이 나면 다시 메인으로 돌아와 치즈가 남아있는지 확인하게 된다. 남아 있는 치즈의 개수와 tmp를 비교해서 더 작은 값을 tmp에 넣어준다. 다만 치즈가 0개일 때는 tmp의 값이 바뀌지 않도록 주의한다.
4. 치즈가 전부 다 녹으면 while문을 빠져나오게 되고, time과 tmp를 각각 출력하면 된다.








# Data Structure 

| 문제 번호 | 이름                              |
| --------- | --------------------------------- |
| 10866     | [덱](#덱)                         |
| 1920      | [수 찾기](#수-찾기)               |
| 1991      | [트리 순회](#트리-순회)           |
| 5639      | [이진 검색 트리](#이진-검색-트리) |
| 5052      | [전화번호 목록](#전화번호-목록)   |

<br>

<hr>

#### #덱

[덱 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_10866.java)

풀이 쓰기에도 민망한 문제... switch문으로 조건을 정해서 풀었다.

1. 정수 X를 덱의 앞에 넣는다. : addFirst

2. 정수 X를 덱의 뒤에 넣는다. : addLast

3. 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

   : isEmpty로 공백 확인 후, pollFirst

4. 덱의 가장 뒤에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

   : isEmpty로 공백 확인 후, pollLast

5. 덱에 들어있는 정수의 개수를 출력한다. : size

6. 덱이 비어있으면 1을, 아니면 0을 출력한다. : isEmpty

7. 덱의 가장 앞에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

   : isEmpty로 공백 확인 후, peekFirst

8. 덱의 가장 뒤에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

   : isEmpty로 공백 확인 후, peekLast

<br>

<hr>

#### #수 찾기

[수 찾기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.09/Solution_1920)

이진 탐색 기초 문제. 아직까지도 이 문제를 안 풀어봤다는 게 충격이다 😅

처음에는 라이브러리 함수로 풀고, 그 다음엔 직접 구현해서 풀 계획이었는데 시간 초과가 났다...

알고보니 배열을 정렬하는 위치 때문에 시간초과가 난 거지만, 계획을 틀어서 우선, 직접 구현으로 문제를 풀었다.

나머지는 단순하므로 이진 탐색 과정만 풀이하겠다. 

<br>

1. 이진 탐색은 값의 크기에 따라 어느 위치에 있는지를 파악하는 알고리즘이기 때문에 우선 배열을 오름차순으로 정렬해 준다.
2. 첫 번째 인덱스, 마지막 인덱스를 각각 first와 last로 선언해 준다.
3. 이진탐색은 배열의 반을 잘라 찾는 값이 어느 쪽에 속해 있는지를 확인하는 과정이기 때문에 first가 last보다 크거나 같을 때 반복문이 중단돼야 한다. (last는 점점 감소하고, first는 점점 증가하기 때문에 가능한 식)
4. mid는 first와 last 합의 1/2가 된다. first와 last의 값이 계속 변경되기 때문에 배열의 길이가 아니라 first와 last를 이용한다.
5. 만약 mid값 즉, 중간 값이 찾고자 하는 값이라면 반환해 준다.
6. 그렇지 않다면, 중간 값과 val의 크기를 비교한다. 만약 val이 크다면 오른쪽에 위치하는 것이기 때문에 first는 mid + 1에서 다시 탐색을 시작해야 한다.
7. mid가 크다면 왼쪽에 위치하는 것이기 때문에 last는 mid - 1까지 탐색해야 한다.

<br>

<hr>

#### #트리 순회

[트리 순회 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_1991.java)

예전에 BFS, DFS를 이론으로만 접하고 코드를 짤 수 없었던 때와 마찬가지로 트리도 자료구조를 배우면서 코드로 배우기는 했지만 과제를 해 보거나 그런 게 아니라서 금방 까먹었다... 대충 재귀로 어쩌구 하는 거였는데... 하는 기억만 남았다😖

그래서 다른 사람 풀이를 참고해서 문제를 풀었고 비슷한 문제를 많이 풀면서 내 것으로 만드는 과정을 거쳐야겠다!

<br>

1. 노드는 각 노드와 왼쪽 자식 노드, 오른쪽 자식 노드 순으로 주어진다. 그리고 주어지는 노드 값들은 고유하므로 이게 map의 key로 작동하게 하고 자식들은 list 자료구조로 묶는 형태로 트리를 정의했다.
2. 입력값을 받고 만약 .이 아니라면 리스트에 추가하고, map에도 노드의 값을 key로 하고 value에는 리스트를 넣는다.
3. 전위순회는 노드부터 나와야 하기 때문에 노드 값 출력 - 왼쪽 자식 - 오른쪽 자식 순으로 가야하고 왼쪽 자식에 접근할 때도 부모 노드의 값으로 접근하고 리스트의 0번째 인덱스에 위치한 값을 가지고 오면 된다.
4. 나머지 순회도 출력 순서와 호출 순서만 바뀌면 마찬가지로 똑같다. 다만 재귀 방식이기 때문에 베이스 케이스를 만들어야 한다. 이 경우엔 "."일 경우, 해당 노드가 존재하지 않기 때문에 이 때 중단해 주면 된다.

<br>

<hr>

#### #이진 검색 트리

[이진 검색 트리 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_5639.java)

EOF 처리에서 제일 오래 걸린 문제... 분명 맞는데 자꾸 무한 루프 돌길래 그냥 제출했더니 채점이 되더라💢

아무튼 이 문제도 삽입은 개념을 먼저 숙지하고 코드는 참고했다. 이 코드 말고 다른 코드도 많았지만 제일 직관적이어서 이 코드를 사용했다. 일반적으로 사용하는 재귀 코드는 ver2에 정리했다.

풀이는 일반적인 트리 삽입 과정(비재귀)에 대해서 설명하고 넘어가겠다.

<br>

1. 이진 탐색 트리에 원소를 삽입할 자리를 찾기 위해서는 우선 실패하는 검색을 한 번 수행해야 한다. 따라서 삽입할 위치를 잡는 t가 루트 노드부터 탐색을 시작한다.
2. t가 null일 때까지 (즉, 실패하는 탐색) 이동하고 만약 t의 값이 삽입하고자 하는 노드의 값과 같을 때는 이미 트리에 존재하므로 그 값을 반환한다.
3. 탐색을 진행하면서 왼쪽으로 갈지, 오른쪽으로 갈지 결정하기 위해 따라가는 노드, 즉 t의 상위 노드 p가 t의 위치를 받고 p의 값보다 작으면 t가 왼쪽으로, 크면 오른쪽으로 방향을 잡아준다.
4. t의 위치를 찾게 되면 실제로 노드를 삽입해야 한다. 따라서 노드의 값 value로 하는 노드를 하나 생성한다.
5. 어떤 노드의 자식이 되거나 만약 상위노드가 없을 때는 그 자체가 트리의 루트 값이 돼야 한다. 이를 if문으로 p가 null일 때와 그렇지 않을 때로 구분해서 나타내고 있다.
6. 만약 p가 null이 아니면 트리에 노드가 존재한다는 것이고 어떤 노드의 자식이 될 것이다. 새로 생성한 노드의 값이  p의 값보다 작으면 왼쪽에, 아니면 오른쪽에 삽입한다.

<br>

<hr>

#### #전화번호 목록

[전화번호 목록](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.09/Solution_5052)

[프로그래머스 전화번호 목록](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.09/Programmers.md#%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8-%EB%AA%A9%EB%A1%9D)이랑 똑같은 문제. 다만 효율성을 검사해서 전에 작성했던 코드는 시간초과가 발생했다.

그래서 전에 사용하던 방식이랑 달리 리스트를 사용하지 않고 풀었다.

1. 시작점을 0부터 하고, 비교 대상은 시작점 인덱스보다 +1한 곳에서 비교를 시작한다.
2. 1번의 반복문은 비교 대상을 위해서 배열의 길이보다 1만큼 작은 곳까지 비교하면 된다.

<br>

사실, 이 문제는 트라이 구조를 위해서 만든 문제라고 한다. 그래서 다른 사람의 코드를 참고해서 ver2로 트라이 구조를 이용해서 푼 코드를 업로드했다.

문제 풀이에 앞서, 트라이 구조에 대해 설명하겠다.

Trie는 문자열을 저장하기 위해 사용하는 트리 형태의 자료구조라고 생각하면 된다. 단순 탐색보다 트라이를 사용하면 트리를 이용해서 탐색을 하기 때문에 시간이 단축된다. O(m) (여기서 m은 문자열의 길이) 하지만, 포인터들을 저장해야 하기 때문에 메모리를 많이 사용하게 된다는 단점이 있다.



![image](https://user-images.githubusercontent.com/62419307/94441656-f6814800-01dd-11eb-9e2b-d036c9fd53eb.png)

[그림 출처](https://en.wikipedia.org/wiki/Trie#/media/File:Trie_example.svg)

위 사진처럼 트라이는 집합에 포함된 문자열의 접두사들에 대응되는 노드들이 서로 연결된 트리이다.

**한 접두사의 맨 뒤에 글자를 덧붙여 다른 접두사를 얻을 수 있을 때 ,두 노드는 부모 자식 관계로 연결**된다. 두 노드를 연결하는 간선은 덧붙인 글자에 대응된다.

그래서 나는 Trie 객체에 해당하는 Trie 클래스와 트리를 만들 TrieNode 클래스를 선언했다. 만약 apple이라는 문자가 들어왔을 때, 나머지 pple는 a 노드의 자식들이 될 것이다. **이 문제에서는 전화 번호의 길이가 10자 이내라고 했기 때문에 자식 노드의 길이도 10자로 정했다.** 

<br>

만약 911이 들어왔다고 하면, 그림은 이와 같을 것이다.

![image](https://user-images.githubusercontent.com/62419307/94443393-16b20680-01e0-11eb-886d-2cb827e0b018.png)

1. `현재 위치의 노드에서 자식 노드가 있는지 확인한다.`

2. `만약 자식 노드가 없으면, 노드를 하나 생성해 주고 그 노드로 이동한다.`

   : 현재 루트노드밖에 존재하지 않기 때문에 자식 노드를 생성한다. (9) 그리고 9 노드로 이동한 뒤 다음의 1이 왔을 때도 9의 자식 노드가 없기 때문에 이 과정을 반복해준다. 

3. `만약 자식 노드가 있다면 현재 문자열이 끝까지 왔는지 확인하고, 자식노드로 이동한다.`

4. `현재 위치가 끝인지를 확인하고 끝이라면 더 확인할 필요 없이 false를 반환한다.`

5. `만약 끝이 아니라면, 문자열 길이만큼 반복문을 다 돌 것이며 다 돌고나서는 끝임을 확인해 준다.`

   : 접두어에 해당하는 문자열을 만나지 않았기 때문에 911 모두 끝낼 수 있다.

<br>

![image](https://user-images.githubusercontent.com/62419307/94446068-1a935800-01e3-11eb-9e03-8f3083be6759.png)

"97625999"는 이와 같이 나타낼 수 있다. (길어서 중간 생략함) 아까의 과정을 거치면 다시 루트부터 시작하게 되는데, 현재 문자가 "9"일 때 해당 문자가 자식 노드로 연결돼 있기 때문에 그 노드를 방문하고 나머지 글자들도 자식 노드로 있는지 확인하고 없으면 새로 생성 뒤 트리와 연결시켰다.

<br>

![image](https://user-images.githubusercontent.com/62419307/94445547-86c18c00-01e2-11eb-85f9-1938bee86b1a.png)

"91125426"은 접두어를 만나게 돼서 false를 반환하는 경우다.

1. `현재 위치의 노드에서 자식 노드가 있는지 확인한다.`

   : 9에 해당하는 자식 노드가 있기 때문에 9로 이동한다. 나머지도 같은 과정을 통한다.

2. `만약 자식 노드가 없으면, 노드를 하나 생성해 주고 그 노드로 이동한다.`

3. `만약 자식 노드가 있다면 현재 문자열이 끝까지 왔는지 확인하고, 자식노드로 이동한다.`

   : 문자열이 끝나기 전에 4번의 과정으로 인해 false로 반환하게 된다. 따라서 이 과정은 이번 예제에서 거치지 않는다.

4. `현재 위치가 끝인지를 확인하고 끝이라면 더 확인할 필요 없이 false를 반환한다.`

   : 자식 노드를 따라서 쭉 이동하다가 자식 노드가 뚝 끊긴다면, 접두어에 해당한다는 것이다. 따라서 false를 반환한다.

5. `만약 끝이 아니라면, 문자열 길이만큼 반복문을 다 돌 것이며 다 돌고나서는 끝임을 확인해 준다.`

<br>

처음으로 트라이 구조를 사용해서 문제를 풀어봤다. 2021 카카오 공채에서도 트라이를 사용한 문제가 출제되었고, [2020 카카오 공채](https://programmers.co.kr/learn/courses/30/lessons/60060)에서 출제된 만큼 다양한 문제를 풀어봐야겠다.😊
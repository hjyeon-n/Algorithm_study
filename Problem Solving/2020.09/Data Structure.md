# Data Structure 

| 문제 번호 | 이름                |
| --------- | ------------------- |
| 10866     | [덱](#덱)           |
| 1920      | [수 찾기](#수-찾기) |

<br>

<hr>

#### #덱

[덱 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_10866.java)

풀이 쓰기에도 민망한 문제... switch문으로 조건을 정해서 풀었다.

1. 정수 X를 덱의 앞에 넣는다. : addFirst

2. 정수 X를 덱의 뒤에 넣는다. : addLast

3. 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

   : isEmpty로 공백 확인 후, pollFirst

4. 덱의 가장 뒤에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

   : isEmpty로 공백 확인 후, pollLast

5. 덱에 들어있는 정수의 개수를 출력한다. : size

6. 덱이 비어있으면 1을, 아니면 0을 출력한다. : isEmpty

7. 덱의 가장 앞에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

   : isEmpty로 공백 확인 후, peekFirst

8. 덱의 가장 뒤에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

   : isEmpty로 공백 확인 후, peekLast

<br>

<hr>

#### #수 찾기

[수 찾기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.09/Solution_1920)

이진 탐색 기초 문제. 아직까지도 이 문제를 안 풀어봤다는 게 충격이다 😅

처음에는 라이브러리 함수로 풀고, 그 다음엔 직접 구현해서 풀 계획이었는데 시간 초과가 났다...

알고보니 배열을 정렬하는 위치 때문에 시간초과가 난 거지만, 계획을 틀어서 우선, 직접 구현으로 문제를 풀었다.

나머지는 단순하므로 이진 탐색 과정만 풀이하겠다. 

<br>

1. 이진 탐색은 값의 크기에 따라 어느 위치에 있는지를 파악하는 알고리즘이기 때문에 우선 배열을 오름차순으로 정렬해 준다.
2. 첫 번째 인덱스, 마지막 인덱스를 각각 first와 last로 선언해 준다.
3. 이진탐색은 배열의 반을 잘라 찾는 값이 어느 쪽에 속해 있는지를 확인하는 과정이기 때문에 first가 last보다 크거나 같을 때 반복문이 중단돼야 한다. (last는 점점 감소하고, first는 점점 증가하기 때문에 가능한 식)
4. mid는 first와 last 합의 1/2가 된다. first와 last의 값이 계속 변경되기 때문에 배열의 길이가 아니라 first와 last를 이용한다.
5. 만약 mid값 즉, 중간 값이 찾고자 하는 값이라면 반환해 준다.
6. 그렇지 않다면, 중간 값과 val의 크기를 비교한다. 만약 val이 크다면 오른쪽에 위치하는 것이기 때문에 first는 mid + 1에서 다시 탐색을 시작해야 한다.
7. mid가 크다면 왼쪽에 위치하는 것이기 때문에 last는 mid - 1까지 탐색해야 한다.


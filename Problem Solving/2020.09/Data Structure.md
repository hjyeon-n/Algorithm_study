# Data Structure 

| 문제 번호 | 이름                    |
| --------- | ----------------------- |
| 10866     | [덱](#덱)               |
| 1920      | [수 찾기](#수-찾기)     |
| 1991      | [트리 순회](#트리-순회) |

<br>

<hr>

#### #덱

[덱 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_10866.java)

풀이 쓰기에도 민망한 문제... switch문으로 조건을 정해서 풀었다.

1. 정수 X를 덱의 앞에 넣는다. : addFirst

2. 정수 X를 덱의 뒤에 넣는다. : addLast

3. 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

   : isEmpty로 공백 확인 후, pollFirst

4. 덱의 가장 뒤에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

   : isEmpty로 공백 확인 후, pollLast

5. 덱에 들어있는 정수의 개수를 출력한다. : size

6. 덱이 비어있으면 1을, 아니면 0을 출력한다. : isEmpty

7. 덱의 가장 앞에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

   : isEmpty로 공백 확인 후, peekFirst

8. 덱의 가장 뒤에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

   : isEmpty로 공백 확인 후, peekLast

<br>

<hr>

#### #수 찾기

[수 찾기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.09/Solution_1920)

이진 탐색 기초 문제. 아직까지도 이 문제를 안 풀어봤다는 게 충격이다 😅

처음에는 라이브러리 함수로 풀고, 그 다음엔 직접 구현해서 풀 계획이었는데 시간 초과가 났다...

알고보니 배열을 정렬하는 위치 때문에 시간초과가 난 거지만, 계획을 틀어서 우선, 직접 구현으로 문제를 풀었다.

나머지는 단순하므로 이진 탐색 과정만 풀이하겠다. 

<br>

1. 이진 탐색은 값의 크기에 따라 어느 위치에 있는지를 파악하는 알고리즘이기 때문에 우선 배열을 오름차순으로 정렬해 준다.
2. 첫 번째 인덱스, 마지막 인덱스를 각각 first와 last로 선언해 준다.
3. 이진탐색은 배열의 반을 잘라 찾는 값이 어느 쪽에 속해 있는지를 확인하는 과정이기 때문에 first가 last보다 크거나 같을 때 반복문이 중단돼야 한다. (last는 점점 감소하고, first는 점점 증가하기 때문에 가능한 식)
4. mid는 first와 last 합의 1/2가 된다. first와 last의 값이 계속 변경되기 때문에 배열의 길이가 아니라 first와 last를 이용한다.
5. 만약 mid값 즉, 중간 값이 찾고자 하는 값이라면 반환해 준다.
6. 그렇지 않다면, 중간 값과 val의 크기를 비교한다. 만약 val이 크다면 오른쪽에 위치하는 것이기 때문에 first는 mid + 1에서 다시 탐색을 시작해야 한다.
7. mid가 크다면 왼쪽에 위치하는 것이기 때문에 last는 mid - 1까지 탐색해야 한다.

<br>

<hr>

#### #트리 순회

[트리 순회 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_1991.java)

예전에 BFS, DFS를 이론으로만 접하고 코드를 짤 수 없었던 때와 마찬가지로 트리도 자료구조를 배우면서 코드로 배우기는 했지만 과제를 해 보거나 그런 게 아니라서 금방 까먹었다... 대충 재귀로 어쩌구 하는 거였는데... 하는 기억만 남았다😖

그래서 다른 사람 풀이를 참고해서 문제를 풀었고 비슷한 문제를 많이 풀면서 내 것으로 만드는 과정을 거쳐야겠다!

<br>

1. 노드는 각 노드와 왼쪽 자식 노드, 오른쪽 자식 노드 순으로 주어진다. 그리고 주어지는 노드 값들은 고유하므로 이게 map의 key로 작동하게 하고 자식들은 list 자료구조로 묶는 형태로 트리를 정의했다.
2. 입력값을 받고 만약 .이 아니라면 리스트에 추가하고, map에도 노드의 값을 key로 하고 value에는 리스트를 넣는다.
3. 전위순회는 노드부터 나와야 하기 때문에 노드 값 출력 - 왼쪽 자식 - 오른쪽 자식 순으로 가야하고 왼쪽 자식에 접근할 때도 부모 노드의 값으로 접근하고 리스트의 0번째 인덱스에 위치한 값을 가지고 오면 된다.
4. 나머지 순회도 출력 순서와 호출 순서만 바뀌면 마찬가지로 똑같다. 다만 재귀 방식이기 때문에 베이스 케이스를 만들어야 한다. 이 경우엔 "."일 경우, 해당 노드가 존재하지 않기 때문에 이 때 중단해 주면 된다.


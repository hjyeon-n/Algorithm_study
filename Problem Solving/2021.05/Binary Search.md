# Binary Search

| 문제 번호                                    | 이름                        |
| -------------------------------------------- | --------------------------- |
| [1654](https://www.acmicpc.net/problem/1654) | [랜선 자르기](#랜선-자르기) |
| [2110](https://www.acmicpc.net/problem/2110) | [공유기 설치](#공유기-설치) |

<br>

<hr>

#### #랜선 자르기

[랜선 자르기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.05/Solution_1654.java)

이 문제는 주의해야 할 사항이 있다. 

1. 랜선의 길이는 231-1보다 작거나 같은 자연수라는 조건이 있어도 탐색 과정 중 이 중간값을 구해야 하기 때문에 결국 int 자료형의 범위를 넘을 수 있기 때문에 long으로 자료형을 바꿔서 풀어야 한다.
2. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다.

이 두 가지 조건을 제외하고 큰 문제는 없었다.

다만 내가 아직 이분탐색 문제에 익숙하지 않아서인지 s를 반환해야 하는지 e를 반환해야 하는지 잘 모를 때가 있다.

이 문제 같은 경우는 어차피 N 이상일 때 최댓값을 구해야 하므로 cnt가 N보다 크거나 같을 때 최댓값을 구하고 이 값을 반환해도 된다.

<br>

<hr>

#### #공유기 설치

[공유기 설치 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.05/Solution_2110.java)

문제 접근조차 어려워서 문제 질문 카테고리부터 확인했다.

처음에는 시작점과 끝점을 인덱스로 두고 시도해서 mid 값이 target 값보다 크면 true를 반환해서 공유기 수를 증가시키는 방식으로 진행했는데 target 값보다 크면 무조건 true를 반환하는 탓에 공유기 수가 너무 많이 늘어났고 문제를 풀기 전 봤던 질문 게시글과도 다른 방향이라서 문제 풀이를 참고해서 풀었다.

이 문제는 **최대 간격**을 구하고 있기 때문에 간격을 조금씩 늘려가면서 C개의 공유기로 만들 수 있는 최대 간격을 구하면 된다.

이때 간격을 늘릴수록 설치할 수 있는 공유기의 수는 적어지고, 간격을 좁힐수록 설치할 수 있는 공유기의 수는 많아진다는 점을 주의해야 한다.

그리고 항상 첫 번째 즉, 제일 왼쪽의 집엔 공유기가 설치될 것이다. [참고](https://www.acmicpc.net/board/view/31633)

그래서 시작점은 1, 마지막 점은 arr 배열의 마지막 값으로 두어 이분 탐색으로 간격을 구할 것이다. 

1. 가장 왼쪽 집은 공유기가 설치되기 때문에 공유기 수를 나타내는 값인 cnt를 1로 초기화하고 val은 arr[0]로 초기화한다.
2. mid 값이 gap에 해당하기 때문에 배열의 길이만큼 탐색하며 val + mid보다 크거나 같은 값이 있는지 확인한다. 만약 있으면 그곳에 공유기를 설치해야 하기 때문에 cnt를 증가시키고 val 값을 해당 배열의 값으로 초기화한다.
3. 만약 공유기의 수가 C보다 크거나 같다면 정답 후보가 될 수 있고 최대 간격을 구해야 하기 때문에 간격을 늘렸을 때도 C보다 크거나 같은지 확인하기 위해 s를 mid + 1로, 답을 나타내는 변수인 rslt에는 현재 mid 값을 저장한다.
4. 공유기의 수가 C보다 작다면 더이상 간격을 늘릴 수 없기 때문에 e를 mid - 1로 초기화한다.
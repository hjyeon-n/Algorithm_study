# Graph

| 문제 번호                                      | 이름                                                    |
| ---------------------------------------------- | ------------------------------------------------------- |
| [4485](https://www.acmicpc.net/problem/4485)   | [녹색 옷 입은 애가 젤다지?](#녹색-옷-입은-애가-젤다지?) |
| [11404](https://www.acmicpc.net/problem/11404) | [플로이드](#플로이드)                                   |
| [10282](https://www.acmicpc.net/problem/10282) | [해킹](#해킹)                                           |
| [2056](https://www.acmicpc.net/problem/2056)   | [작업](#작업)⭐                                          |

<br>

<hr>

#### #녹색 옷 입은 애가 젤다지?

[녹색 옷 입은 애가 젤다지? 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.05/Solution_4485.java)

다익스트라 문제이다. 문제를 보고 나서는 음... BFS처럼 풀면 안 되나 생각했는데 결국 아예 틀린 생각은 아니었다.

이전까지 풀었던 다익스트라 문제는 간선으로 연결된 정점들에 관한 문제라면 이 문제는 꽉 채워진 이차원 배열 문제였다. 즉, 모든 노드가 연결되어있다. 1차원 배열로 dist 배열을 선언했다면 이 문제는 1, 1에서 n, n으로 가야 하고 이건 단순히 정점들의 배열로 풀 수 없기 때문에 이차원 배열로 풀어야 한다.

<br>

<hr>

#### #플로이드

[플로이드 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.05/Solution_11404.java)

왜 골드4 문제이지 싶을 정도로 쉬웠다. 

기본적인 플로이드 워셜 문제이고 다만 출발지와 도착지가 같은 간선들이 여러 개 존재할 수 있기 때문에 최소 가중치를 갖는 간선을 저장해서 계산하면 된다.

<br>

<hr>

#### #해킹

[해킹 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.05/Solution_10282.java)

"어떤 컴퓨터 a가 다른 컴퓨터 b에 의존한다면, b가 감염되면 그로부터 일정 시간 뒤 a도 감염되고 만다." 이 부분의 문제 설명만 잘 읽는다면 크게 어려운 문제는 아니다. 보통은 a에서 b로 뻗어나오는 화살표 방향을 그린다면, 이 문제의 경우엔 a가 b에 의존하기 때문에 b에서 a로 뻗어나오는 모양을 가지고 있다. 즉, b가 감염돼야 a가 감염되는 것이다.

이 부분을 제외하고는 단순한 다익스트라 문제이다.

<br>

<hr>

⭐⭐⭐⭐⭐

#### #작업

[작업 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.05/Solution_2056.java)

기본적인 위상정렬 문제이다. 모든 작업을 완료하기 위해 필요한 최소 시간을 구해야 하기 때문에 오히려 모든 작업의 수행 시간 중 최댓값을 출력해야 한다.

위상정렬 문제는 진입차수 같은 걸 어떤 점을 기준으로 해야 하는지 헷갈리기 때문에 다시 풀어보는 게 좋을 것 같다.
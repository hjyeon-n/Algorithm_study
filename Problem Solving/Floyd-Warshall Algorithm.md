# Floyd-Warshall Algorithm 

### 플로이드 와샬 알고리즘? 🤔

플로이드 와샬 알고리즘은 최단 경로를 구하는 문제에서 자주 분류되는 알고리즘이다.

[다익스트라 알고리즘](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/Dijkstra%20Algorithm.md)에 대해서는 자주 들어봤는데 플로이드 와샬? 사실 이름부터 어려워 보인다.😵

다익스트라 알고리즘이 한 정점에서부터 모든 정점까지의 최단 경로를 구하는 문제라면, 플로이드 와샬 알고리즘은 **모든 정점에서 모든 정점으로의 최단 경로**를 구할 때 사용한다. 다익스트라 알고리즘에서는 가장 적은 비용을 하나씩 선택했다면, 플로이드 와샬 알고리즘은 **거쳐가는 정점**을 기준으로 알고리즘을 수행한다는 차이점이 있다.

<br>

### 작동 방식 🔥

![image](https://user-images.githubusercontent.com/62419307/97410122-02c60580-1942-11eb-89b0-84eaf96c562f.png)

이런 그래프가 있다고 하자. 우선, 이 그래프의 연결 비용은 아래와 같이 나타낼 수 있다.

|       | 1    | 2    | 3    | 4    |
| ----- | ---- | ---- | ---- | ---- |
| **1** | 0    | 5    | ∞    | 8    |
| **2** | 7    | 0    | 9    | ∞    |
| **3** | 2    | ∞    | 0    | 4    |
| **4** | ∞    | ∞    | 3    | 0    |

<br>

플로이드 와샬 알고리즘의 정의에 맞게 이제 정점을 거쳐가면서 최소 비용을 갱신해 보자.

즉, X에서 Y로 가는 경로의 최소 연결 비용을 구하고자 할 때

**X에서 Y로 가는 연결 비용 VS X에서 노트 N까지의 연결 비용 + 노드 N에서 Y까지의 연결 비용** 중 최솟값을 갱신하면 된다.

1. 1번 노드를 거쳐가는 경우

   |       | 1    | 2    | 3    | 4    |
   | ----- | ---- | ---- | ---- | ---- |
   | **1** | 0    | 5    | ∞    | 8    |
   | **2** | 7    | 0    | 9    | 15   |
   | **3** | 2    | 7    | 0    | 4    |
   | **4** | ∞    | ∞    | 3    | 0    |

   <br>

2.  2번 노드를 거쳐가는 경우

   |       | 1    | 2    | 3    | 4    |
   | ----- | ---- | ---- | ---- | ---- |
   | **1** | 0    | 5    | 14   | 8    |
   | **2** | 7    | 0    | 9    | 15   |
   | **3** | 2    | 7    | 0    | 4    |
   | **4** | ∞    | ∞    | 3    | 0    |

   <br>

3.  3번 노드를 거쳐가는 경우

   |       | 1    | 2    | 3    | 4    |
   | ----- | ---- | ---- | ---- | ---- |
   | **1** | 0    | 5    | 14   | 8    |
   | **2** | 7    | 0    | 9    | 13   |
   | **3** | 2    | 7    | 0    | 4    |
   | **4** | 5    | 10   | 3    | 0    |

   <br>

4.  4번 노드를 거쳐가는 경우

   |       | 1    | 2    | 3    | 4    |
   | ----- | ---- | ---- | ---- | ---- |
   | **1** | 0    | 5    | 11   | 8    |
   | **2** | 7    | 0    | 9    | 13   |
   | **3** | 2    | 7    | 0    | 4    |
   | **4** | 5    | 10   | 3    | 0    |

   <br>

```java
// K : 거쳐가는 노드
for (int k = 0; k < n; k++) {
    // i : 출발 노드
    for (i = 0; i < n; i++) {
        // j : 도착 노드
        for (int j = 0; j < n; j++) {
            // 거쳐가는 경우의 비용이 더 적을 때
            if (d[i][k] + d[k][j] < d[i][j]) {
                d[i][j] = d[i][k] + d[k][j];
            }
        }
    } 
}
```

[참고](https://blog.naver.com/ndb796/221234427842?viewType=pc)




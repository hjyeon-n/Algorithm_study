# BFS, DFS

| 문제 번호                                      | 이름                                  |
| ---------------------------------------------- | ------------------------------------- |
| [17836](https://www.acmicpc.net/problem/17836) | [공주님을 구해라!](#공주님을-구해라!) |

<br>

<hr>

#### #공주님을 구해라!

[공주님을 구해라! 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.01/Solution_17836.java)

정말 오래 걸렸는데 오래 걸린 이유도 출력 시 대문자인데 소문자로 출력해서였다...😂

그리고 처음 생각했을 때는 트램 없이 공주를 구했을 때, 그리고 트램을 찾은 뒤 공주를 구했을 때 값을 비교한 뒤 더 작은 값을 T와 비교하는 식으로 진행하려고 했는데 BFS 특성상 공주를 구하러 가는 도중에 트램을 찾을 수 있고 그렇게 되면 벽을 부술 수 있기 때문에 하나하나 신경 쓰기가 힘들 것 같았다.

전체적인 틀을 잡되, 어떻게 진행할까 고민하다가 질문 게시판의 어떤 코드를 보게 되었고 visited 배열을 3차원으로 선언해서 트램을 찾았을 때와 그렇지 않을 때를 구분해서 방문 여부를 체크하는 거에 착안해서 코드를 짰다.

그리고 트램을 찾았을 때는 boolean 변수로 status를 선언해서 이용하려고 했는데 그런 방법 말고 status를 Location 함수에 wall로 선언해서 이 값으로 3차원 배열의 인덱스 값을 이용할 수 있다는 점을 알게 되었다.

visited 함수를 int형으로 선언 후에 time 과 같은 별도의 변수 없이 마지막 배열의 값을 반환하려고 했는데 3차원 배열이기 때문에 쉽지 않았고, T를 넘었을 때는 더 볼 것도 없이 Fail이었기 때문에 이 부분도 수정하게 되었다.

1. 값을 입력 받는다.
2. 처음 방문한 점에 1을 넣어 방문 여부를 표시해 주고, 큐에 값을 넣어준다.
3. 큐가 빌 때까지 BFS를 진행한다.
4. 큐에서 원소 하나를 빼서 time의 값이 T보다 크면 continue로 넘어간다. (이때, 한 좌표마다 time 값이 있다는 걸 유념하자.)
5. 그리고 트램을 찾았을 때 wall 값을 1로 바꿔주고, 1일 때의 visited 값을 초기화 해 준다.
6. 네 방향 모두를 확인하면서 wall이 0일 때는 벽을 통과할 수 없기 때문에 조건문으로 map 값이 1이 아닐 때만 방문 여부를 표시하고 큐에 값을 넣어준다.
7. 만약, wall이 1이라면 이미 트램을 얻은 상태이기 때문에 벽에 구애 받지 않는다. 그렇기 때문에 방문 여부만 확인하고 방문할 수 있다.
   (상하좌우만 확인하기 때문에 그 전의 값으로 돌아갈 필요가 없어서 1일 때의 방문여부를 0일 때의 방문 여부로 초기화할 필요가 없다.)
8. time 값을 출력하면서 프로그램이 끝나지 않았다면, while문을 빠져나오게 될 것이다. 그러면 Fail을 출력한다.
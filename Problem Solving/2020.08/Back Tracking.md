# 백트래킹

| 문제 번호 | 이름                   |
| --------- | ---------------------- |
| 15649     | [N과 M (1)](N과-M-(1)) |
| 15650     | [N과 M (2)](N과-M-(2)) |
| 15651     | [N과 M (3)](N과-M-(3)) |
| 15652     | [N과 M (4)](N과-M-(4)) |

<br>

<hr>

#### #N과 M (1)

[N과 M (1) 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_15649.java)

백트래킹으로 풀어보는 첫 문제😲

개념도 잘 이해가 되지 않아서 다른 사람 풀이를 많이 참고해서 코드를 짜고, 디버깅을 몇 번이나 하고 나서야 조금 이해가 됐다.

문제를 읽자마자 순열이 생각났는데 순열과 아주 다른 문제는 아니었고, DFS로 순열을 풀이하는 문제라고 생각하니 덜 부담스러웠다.

<br>

백트래킹 문제인 만큼 말그대로 back해야 하기 때문에 **상태를 원래대로 되돌려줘야 한다.** 또한, m 만큼의 수를 구해야 하기 때문에 depth 변수를 선언해 m이 됐을 때 수를 출력해야 한다.

이 점을 제외하고는 단순 DFS와 큰 차이는 없다.

1. 값을 입력받고 메인함수에서 DFS를 호출한다.
2. N번만큼 반복문을 돌며 방문 여부를 확인한 뒤, 방문하지 않았으면 방문여부를 표시하고 arr[depth]에 i + 1을 넣어준다. <br>
   (1부터 N까지의 수 중에 중복 없이 M개를 골라야 하기 때문. 순열이라고 생각하면 쉬움.)
3. 재귀로 dfs를 수행하고 돌아온 뒤에 백트래킹해야 하기 때문에 방문 여부를 다시 false로 바꿔줌

<br>

재귀 문제는 풀 때는 힘들지만, 디버깅 했을 때는 아주 재밌는데 대충 일련의 과정을 쓴다면 예를 들어 N이 3, M이 1을 입력했다고 하자.

1. arr[depth] (이 때 depth는 0이라고 가정)에 만약 1이 들어가면 dfs를 수행하면서 depth가 1만큼 증가해 arr[depth + 1]에는 2가 들어간다.
2. M만큼 골랐기 때문에 조건문에 걸려 arr[]을 출력
3. 다시 1번의 dfs를 호출하는 다음 행으로 돌아와서 방문여부를 false로 바꿔준다.
4. 아직 n만큼 다 돌지 않았기 때문에 arr[1]을 채우기 위해 다시 반복한다.
5. 4번의 과정이 다 끝나면 arr[0]이 채워지는 곳으로 돌아가 이 또한 3번처럼 방문여부를 false로 처리한 뒤, 이 과정을 n번 반복한다.

<br>

<hr>

#### #N과 M (2)

[N과 M (2) 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_15650.java)

[N과 M (1)](N과-M-(1)) 이랑 아주 유사한 문제. 단, 이번 문제는 조합과 관련이 있다.

조합이라는 점도, 시작 인덱스가 달라야 한다는 점도 알고 있었는데 이걸 어떻게 구현해야 하나 끙끙댔다...😥 

개인적으로 너무너무 아쉬운 문제... 

<br>

오름차순으로 출력이 돼야 하기 때문에 다음에 올 값이 지금 오는 값보다는 커야 한다. 이를 위해서 N과 M(1) 문제와 다르게 DFS에 현재 위치를 저장하는 idx의 값도 같이 호출해야 한다. 

예를 들면 4 2 라는 입력이 들어왔을 때 현재 값이 1이라면 뒤에 올 수 있는 값은 2, 3, 4가 되겠고 현재 값이 2라면 뒤에 올 수 있는 값은 3, 4가 올 수 있다. 즉, 큰 수부터 탐색할 수 있도록 재귀 호출 또한 idx + 1로 호출해야 한다.

<br>

또한 이번 문제는 지난 문제와 달리 중복을 체크할 필요가 없기 때문에 방문 여부를 따지는 visited 배열이 필요없다. 

예를 들어 지난 문제의 경우엔 4 2 라는 입력이 들어왔을 때, arr[0]의 값이 1이면 arr[1]의 값은 2, 3, 4가 올 수 있고 arr[1]의 값이 2이면 arr[2]는 1, 3, 4가 올 수 있어 중복이 되는 경우가 있기 때문에 다시 visited 배열에서 false 상태로 되돌려줄 필요가 있었다. 

하지만 이번 문제의 경우, 중복이 되지 않기 때문에 visited 배열이 필요 없고, 4, 2라는 입력이 들어오더라도 arr[0]이 4라고 하면 arr[1]에 더 이상 채울 수 있는 값이 없어 m == depth 조건과 일치하지 않아 출력하지 않는다.

<br>

N이 4, M이 2가 입력됐을 때 디버깅 과정을 살펴 보자.

1. arr[depth] (현재 depth가 0이라고 가정) 에 i + 1(현재 i는 0이라고 가정)이 들어간다.
2. 재귀 호출을 할 때 i + 1의 값을 idx에 저장해 함께 호출한다.
3. arr[1]의 값은 0부터 시작하는 게 아니라, idx부터 시작하게 된다. 그렇기 때문에 항상 arr[1]은 arr[0]보다 값이 크다.

<br>

<hr>

#### #N과 M (3)

[N과 M (3) 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_15651.java)

[N과 M (1)](N과-M-(1)) 이랑 아주 유사한 문제.  이번 문제는 N과 M(1)에서 visited 배열로 방문했던 숫자는 다음 인덱스에서 방문하지 않았던 것과 달리, 다음 인덱스에서도 방문할 수 있게 방문 여부 확인 부분을 없애면 된다.

이 문제는 오히려 시간초과가 날 수 있어서 주의해야 하는 문제이고, StringBuffer 혹은 StringBuilder로 풀면 시간초과를 피할 수 있다. 

- StringBuffer 클래스 : 문자열 연산이 많은 Multi-Thread 환경
- StringBuilder 클래스 : 문자열 연산이 많은 Single-Thread 또는 Thread를 신경쓰지 않아도 되는 환경



두 방법 모두 사용해서 풀이해 봤는데, StringBuilder의 속도가 더 빨랐다.

![image](https://user-images.githubusercontent.com/62419307/89262935-58548400-d66b-11ea-959d-cb5990f9c97c.png)



순서대로 String - StringBuffer - StringBuilder

<br>

<hr>

#### #N과 M (4)

[N과 M (3) 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_15652.java)

[N과 M (2)](N과-M-(2)) 와 [N과 M (3)](N과-M-(3)) 을 섞은 문제라고 생각하면 아주 쉽다. 방문여부가 필요없고, 오름차순인 것을 고려하면 된다. 
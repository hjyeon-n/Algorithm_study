# 백트래킹

| 문제 번호 | 이름           |
| --------- | -------------- |
| 15649     | [N과 M](N과-M) |

#### #N과 M

[N과 M 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_15649.java)

백트래킹으로 풀어보는 첫 문제😲

개념도 잘 이해가 되지 않아서 다른 사람 풀이를 많이 참고해서 코드를 짜고, 디버깅을 몇 번이나 하고 나서야 조금 이해가 됐다.

문제를 읽자마자 순열이 생각났는데 순열과 아주 다른 문제는 아니었고, DFS로 순열을 풀이하는 문제라고 생각하니 덜 부담스러웠다.

<br>

백트래킹 문제인 만큼 말그대로 back해야 하기 때문에 **상태를 원래대로 되돌려줘야 한다.** 또한, m 만큼의 수를 구해야 하기 때문에 depth 변수를 선언해 m이 됐을 때 수를 출력해야 한다.

이 점을 제외하고는 단순 DFS와 큰 차이는 없다.

1. 값을 입력받고 메인함수에서 DFS를 호출한다.
2. N번만큼 반복문을 돌며 방문 여부를 확인한 뒤, 방문하지 않았으면 방문여부를 표시하고 arr[depth]에 i + 1을 넣어준다. <br>
   (1부터 N까지의 수 중에 중복 없이 M개를 골라야 하기 때문. 순열이라고 생각하면 쉬움.)
3. 재귀로 dfs를 수행하고 돌아온 뒤에 백트래킹해야 하기 때문에 방문 여부를 다시 false로 바꿔줌

<br>

재귀 문제는 풀 때는 힘들지만, 디버깅 했을 때는 아주 재밌는데 대충 일련의 과정을 쓴다면

예를 들어 N이 3, M이 1을 입력했다고 하자.

1. arr[depth] (이 때 depth는 0이라고 가정)에 만약 1이 들어가면 dfs를 수행하면서 depth가 1만큼 증가해 arr[depth + 1]에는 2가 들어간다.
2. M만큼 골랐기 때문에 조건문에 걸려 arr[]을 출력
3. 다시 1번의 dfs를 호출하는 다음 행으로 돌아와서 방문여부를 false로 바꿔준다.
4. 아직 n만큼 다 돌지 않았기 때문에 arr[1]을 채우기 위해 다시 반복한다.
5. 4번의 과정이 다 끝나면 arr[0]이 채워지는 곳으로 돌아가 이 또한 3번처럼 방문여부를 false로 처리한 뒤, 이 과정을 n번 반복한다.
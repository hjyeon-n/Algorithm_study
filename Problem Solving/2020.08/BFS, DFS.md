# BFS, DFS

### BFS와 DFS로 푼 문제

| 문제 번호 | 이름                    |
| --------- | ----------------------- |
| 14502     | [연구소](#연구소)       |
| 2468      | [안전 영역](#안전-영역) |

<br>

### BFS로 푼 문제

| 문제 번호 | 이름                      |
| --------- | ------------------------- |
| 7569      | [토마토](#토마토)         |
| 2644      | [촌수계산](#촌수계산)     |
| 5014      | [스타트링크](#스타트링크) |
| 2589      | [보물섬](보물섬)          |

<br>

<hr>

⭐⭐⭐⭐⭐

#### #연구소

[연구소 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.08/Solution_14502) 👩‍🔬

삼성 SW 역량 테스트 기출 문제. 처음에는 예제조차 이해가 안 돼서 나중에 풀어야지 하고 뒀던 문제인데 드디어 풀었다! 😉

이 문제를 위해서 백트래킹 문제들을 조금 풀어봤는데 큰 도움이 됐다. 하지만 코드 흐름은 어떻게 짜야 할지 감이 잘 안 잡혀서 다른 사람의 힌트를 조금 참고하고 풀었다. 

<br>

벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 하는데, 안전영역의 최댓값을 구해야 한다.

벽을 3개 세우는 경우는 다양하게 나올 수 있는데 1, 2, 3 영역이든 2, 1, 3 영역이든 결국 똑같은 의미이기 때문에 순서는 고려하지 않아도 된다. 따라서 조합을 통해서 3개를 뽑아내면 벽을 세우는 모든 경우를 구할 수 있게 된다. 조합은 백트래킹을 이용해서 풀었다.  3개의 벽을 세우고 나서 바이러스가 다 퍼졌을 때의 안전영역을 구해야 하기 때문에 DFS 혹은 BFS로 문제를 풀 수 있다. 

<br>

주의할 점은 조합을 통한 하나의 경우가 나왔을 때 이 이차원 배열을 이용해서 바로 BFS와 DFS로 바이러스가 퍼지는 과정을 거치게 되면 벽을 세우는 다른 경우는 구할 수 없기 때문에 바이러스가 퍼지는 과정을 거치기 전에 이차원 배열을 복사한 다른 배열로 BFS / DFS 해야 한다. 

<br>

<hr>

#### #안전 영역

[안전 영역 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.08/Solution_2468) 👩‍🚒

어떤 지역의 높이 정보가 주어졌을 때, 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 계산하면 되는 문제.

나는 지역의 높이 정보를 map[] [] 배열에 저장하고 물에 잠긴 지역들은 copy[] [] 배열에 저장했다. 높이는 1에서부터 100까지 올 수 있지만, 지역의 최대 높이 이상의 수는 모두 물에 잠기기 때문에 그 이상의 수는 의미가 없다. 따라서 지역의 높이를 입력 받으면서 최댓값을 구해 1에서부터 최댓값까지만 높이가 올 수 있게 했다.

<br>

높이를 1씩 증가시키면서 지역의 높이랑 비교하고 물에 잠기면 -1 아니면 1 값을 copy 배열에 저장해 copy 배열에 BFS/DFS를 해서 영역의 크기를 구했다. 그 중 가장 큰 값을 골라 출력했더니 어렵지 않게 해결할 수 있었다.

어려운 문제는 아니지만, 어떤 지역도 물에 잠기지 않을 수 있다는 건 주의해야 한다. 즉, 비가 오지 않을 수 있다는 점을 고려해야 한다. 

<br>

<hr>

#### #토마토

[토마토 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_7569.java  ) 

2차원 배열의 [토마토(7576)](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_7576.java)에서 3차원 배열로 바꿔주면 된다🍅

<br>

<hr>

#### #촌수계산

[촌수계산 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_2644.java)👨‍👩‍👧

[바이러스](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_2606) 문제처럼 visted 배열이 일차원이어야 하는 문제. 단, 바이러스 문제의 경우 1번 컴퓨터부터 시작해서 단순히 연결된 컴퓨터를 방문하고 수를 세면 되지만 촌수계산 문제는 시작점부터 끝점까지의 연결 수를 봐야 함.

1. 시작점에 연결되어 있는 모든 정점을 큐에 넣고  그 정점에서부터 도착점까지 몇 번에 걸쳐 가는지는 visited 배열을 이용하면 된다.
2. visited 배열에 수를 더할 때도 단순히 1을 더하는 게 아니라 시작점부터 끝점까지 연결이 돼야 한다는 점을 주의해서 visited[시작점]에 1을 더해야 한다. 
3. 모든 bfs가 끝난 후 visited[end] 값을 출력하면 된다. 이때 초기로 설정했던 0인 경우, 친척관계가 없기 때문에 -1을 출력하면 된다.

<br>

<hr>

#### #스타트링크

[스타트링크 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_5014.java)🏢

문제는 쉽게 풀었는데 출력문에서 실수해서 30분동안 고민했다. (바보...🤦‍♀️)

입력은 건물의 최대 높이, 현재 층, 목표 층, 올라갈 수 있는 수, 내려갈 수 있는 수 순서대로 나온다.

이 문제를 풀기위해서 필요한 조건 4가지는 이와 같다.

1. 현재 층에서 목표층까지 올라가려면 U층 만큼 올라갈 수 있고 이때 최대 높이를 넘어가면 안 된다.
2. 현재 층에서 목표층까지 내려갈 때 D층 만큼 내려갈 수 있고 이때 1이상이어야 한다. 
3. 현재층과 목표층이 같을 땐 0을 출력한다.
4. 만약 엘리베이터를 이용해 도달할 수 없을 땐, use the stairs를 출력한다.

<br>

BFS를 실행하기 전, 현재층과 목표층을 비교한 뒤 같으면 0을 출력하고 return했고 나머지 경우엔 방문여부를 표시하는 int형 visited 배열을 선언해 얼마 만큼 이용해야 하는지 수를 더해 구했다.

```
10 1 10 2 1
```

입력값이 들어왔을 때, 현재 위치가 1층이라고 하자. 그러면 내려갈 수는 없지만, 1 + U는 3이기 때문에 올라가고 그때는 1층에서 U층만큼 한 번 올라온 것이기 때문에 3층에 도달하기 위해서는 visited[1] + 1을 더해준 것과 같다. 만약 현재 위치가 4층이면 4 + U 즉, 6층에 도달하기 위해선 4층까지 도달하기 위해 필요한 수에 + 1을 해주면 6층까지 도달하기 위해 필요한 수가 나온다.

✔ 따라서 올라갈 때는 visited[x + U] = visited[x] + 1, 내려갈 때는 visited[x - D] = visited[x] + 1

만약 visited[목표층]이 0일 땐 G층까지 도달할 수 없다는 것이기 때문에 use the stairs를 출력하면 된다.

<br>

<hr>

#### #보물섬

[보물섬 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_2589.java)💎

다른 문제랑 큰 차이가 없어 보이지만 보물의 위치가 입력되지 않았다는 점에서 약간 다르다. 보물의 위치는 **"서로 간에 최단 거리로 이동하는데 있어 가장 긴 시간이 걸리는 육지 두 곳에 나뉘어 묻혀있다"**는 조건에 따라 최단 거리로 이동하되, 가장 오랜 시간이 걸리는 경우를 찾기 위해 BFS로 풀면 된다.

출발점은 반복문을 통해서 육지면서 아직 방문하지 않는 점으로 정하면 되지만, 끝점의 경우 출발점과 연결된 모든 육지가 끝점이 될 수 있다. 따라서 모든 점을 끝점이라고 생각하고 그 모든 정점에 도달하는 수를 visited 배열을 이용해 구하고 그 값이 최대일 경우가 바로 문제가 요구하는 보물의 위치가 될 것이고, 그와 동시에 보물까지 가는 최단 거리가 될 것이다.

<br>

즉, vistied 배열은 방문 여부 표시와 동시에 출발점에서 현재의 점까지 이동한 거리를 저장한다고 생각하면 된다. 예를 들어 1-2-3-4로 연결된 지점이 있다고 가정하자. 1에서 출발해 2까지 가는 수는 visited[1] + 1일 것이고, 3의 경우에는 2를 중간에 끼고 가야 하기 때문에 visited[2] + 1이 된다는 점을 이용하면 된다.

<br>

시작점을 잡고 작성된 visited 배열에서 최댓값을 찾아 최종 결과값이 될 변수 max와 비교한 뒤 max보다 크면 이 최댓값을 넣어주고 반복문을 통해 다음 시작점을 잡고 똑같이 BFS를 실행시키면 된다. 


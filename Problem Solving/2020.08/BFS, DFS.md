# BFS, DFS

### BFS와 DFS로 푼 문제

| 문제 번호 | 이름                        |
| --------- | --------------------------- |
| 14502     | [연구소](#연구소)⭐          |
| 2468      | [안전 영역](#안전-영역)     |
| 2583      | [영역 구하기](#영역-구하기) |
| 4963      | [섬의 개수](#섬의-개수)     |

<br>

### BFS로 푼 문제

| 문제 번호             | 이름                                              |
| --------------------- | ------------------------------------------------- |
| 7569                  | [토마토](#토마토)                                 |
| 2644                  | [촌수계산](#촌수계산)                             |
| 5014                  | [스타트링크](#스타트링크)                         |
| 2589                  | [보물섬](#보물섬)                                 |
| 3055                  | [탈출](#탈출)                                     |
| 2017 카카오 코드 예선 | [카카오 프렌즈 컬러링북](#카카오-프렌즈-컬러링북) |
| 7562                  | [나이트의 이동](#나이트의-이동)                   |
| 11403                 | [경로 찾기](#경로-찾기)                           |
| 2206                  | [벽 부수고 이동하기](#벽-부수고-이동하기)⭐        |

<br>

### DFS로 푼 문제

| 문제 번호 | 이름                                                         |
| --------- | ------------------------------------------------------------ |
| 1937      | [욕심쟁이 판다](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem Solving/2020.08/Dynamic Programming.md) (풀이는 DP에) |

<br>

<hr>

⭐⭐⭐⭐⭐

#### #연구소

[연구소 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.08/Solution_14502) 👩‍🔬

삼성 SW 역량 테스트 기출 문제. 처음에는 예제조차 이해가 안 돼서 나중에 풀어야지 하고 뒀던 문제인데 드디어 풀었다! 😉

이 문제를 위해서 백트래킹 문제들을 조금 풀어봤는데 큰 도움이 됐다. 하지만 코드 흐름은 어떻게 짜야 할지 감이 잘 안 잡혀서 다른 사람의 힌트를 조금 참고하고 풀었다. 

<br>

벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 하는데, 안전영역의 최댓값을 구해야 한다.

벽을 3개 세우는 경우는 다양하게 나올 수 있는데 1, 2, 3 영역이든 2, 1, 3 영역이든 결국 똑같은 의미이기 때문에 순서는 고려하지 않아도 된다. 따라서 조합을 통해서 3개를 뽑아내면 벽을 세우는 모든 경우를 구할 수 있게 된다. 조합은 백트래킹을 이용해서 풀었다.  3개의 벽을 세우고 나서 바이러스가 다 퍼졌을 때의 안전영역을 구해야 하기 때문에 DFS 혹은 BFS로 문제를 풀 수 있다. 

<br>

주의할 점은 조합을 통한 하나의 경우가 나왔을 때 이 이차원 배열을 이용해서 바로 BFS와 DFS로 바이러스가 퍼지는 과정을 거치게 되면 벽을 세우는 다른 경우는 구할 수 없기 때문에 바이러스가 퍼지는 과정을 거치기 전에 이차원 배열을 복사한 다른 배열로 BFS / DFS 해야 한다. 

<br>

<hr>

#### #안전 영역

[안전 영역 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.08/Solution_2468) 👩‍🚒

어떤 지역의 높이 정보가 주어졌을 때, 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 계산하면 되는 문제.

나는 지역의 높이 정보를 map[] [] 배열에 저장하고 물에 잠긴 지역들은 copy[] [] 배열에 저장했다. 높이는 1에서부터 100까지 올 수 있지만, 지역의 최대 높이 이상의 수는 모두 물에 잠기기 때문에 그 이상의 수는 의미가 없다. 따라서 지역의 높이를 입력 받으면서 최댓값을 구해 1에서부터 최댓값까지만 높이가 올 수 있게 했다.

<br>

높이를 1씩 증가시키면서 지역의 높이랑 비교하고 물에 잠기면 -1 아니면 1 값을 copy 배열에 저장해 copy 배열에 BFS/DFS를 해서 영역의 크기를 구했다. 그 중 가장 큰 값을 골라 출력했더니 어렵지 않게 해결할 수 있었다.

어려운 문제는 아니지만, 어떤 지역도 물에 잠기지 않을 수 있다는 건 주의해야 한다. 즉, 비가 오지 않을 수 있다는 점을 고려해야 한다. 

<br>

<hr>

#### #영역 구하기

[영역 구하기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.08/Solution_2583) 🚩

[단지번호붙이기](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_2667)와 유사한 문제. 단, 이 문제는 입력이 조금 까다롭다.

보통 프로그래밍에서 사용하는 배열은 일반 함수 좌표와 X와 Y의 위치가 바뀌어있는데, 이 문제는 일반 함수 좌표처럼 되어 있기 때문에 값을 그대로 입력 받는 게 아니라 X와 Y의 자리를 바꿔줘야 한다. 

처음에 입력 받는 좌표는 각각 Ax, Ay라고 정의했고 이후에 입력 받는 좌표는 Bx, By라고 정의했다. Ax와 Ay는 왼쪽 아래, Bx와 By는 오른쪽 위를 가리키고 있기 때문에 값이 항상 후자가 크다는 걸 생각해 보면 영역을 표시하기 위해 Ax는 Bx까지 영역을 색칠하고 마찬가지로 Ay는 By까지 색칠하면 된다.

이후 색칠하지 않은 영역을 BFS/DFS로 구하고 각 빈 영역의 크기를 리스트에 추가해, 오름차순 뒤 출력하면 정답이 된다.

<br>

<hr>

#### #섬의 개수

[섬의 개수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.08/Solution_4963) 🏝

어려운 문제는 전혀 아니었는데 범위 문제 때문에 의외로 시간이 많이 걸렸다...😥

간만에 푸는 문제라서 일부러 쉬운 문제로 골랐다. 단지 번호 붙이기 문제와 아주 흡사한 문제.

단, 이번에는 대각선 방향까지 고려해야 한다. 그리고 1, 1부터 배열이 시작된다는 점을 고려해서 배열 선언을 1만큼 더 크게 정의하고, 범위 또한 1이상 W, H 이하로 정하면 된다.

<br>

<hr>

#### #토마토

[토마토 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_7569.java  ) 

2차원 배열의 [토마토(7576)](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_7576.java)에서 3차원 배열로 바꿔주면 된다🍅

<br>

<hr>

#### #촌수계산

[촌수계산 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_2644.java)👨‍👩‍👧

[바이러스](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_2606) 문제처럼 visted 배열이 일차원이어야 하는 문제. 단, 바이러스 문제의 경우 1번 컴퓨터부터 시작해서 단순히 연결된 컴퓨터를 방문하고 수를 세면 되지만 촌수계산 문제는 시작점부터 끝점까지의 연결 수를 봐야 함.

1. 시작점에 연결되어 있는 모든 정점을 큐에 넣고  그 정점에서부터 도착점까지 몇 번에 걸쳐 가는지는 visited 배열을 이용하면 된다.
2. visited 배열에 수를 더할 때도 단순히 1을 더하는 게 아니라 시작점부터 끝점까지 연결이 돼야 한다는 점을 주의해서 visited[시작점]에 1을 더해야 한다. 
3. 모든 bfs가 끝난 후 visited[end] 값을 출력하면 된다. 이때 초기로 설정했던 0인 경우, 친척관계가 없기 때문에 -1을 출력하면 된다.

<br>

<hr>

#### #스타트링크

[스타트링크 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_5014.java)🏢

문제는 쉽게 풀었는데 출력문에서 실수해서 30분동안 고민했다. (바보...🤦‍♀️)

입력은 건물의 최대 높이, 현재 층, 목표 층, 올라갈 수 있는 수, 내려갈 수 있는 수 순서대로 나온다.

이 문제를 풀기위해서 필요한 조건 4가지는 이와 같다.

1. 현재 층에서 목표층까지 올라가려면 U층 만큼 올라갈 수 있고 이때 최대 높이를 넘어가면 안 된다.
2. 현재 층에서 목표층까지 내려갈 때 D층 만큼 내려갈 수 있고 이때 1이상이어야 한다. 
3. 현재층과 목표층이 같을 땐 0을 출력한다.
4. 만약 엘리베이터를 이용해 도달할 수 없을 땐, use the stairs를 출력한다.

<br>

BFS를 실행하기 전, 현재층과 목표층을 비교한 뒤 같으면 0을 출력하고 return했고 나머지 경우엔 방문여부를 표시하는 int형 visited 배열을 선언해 얼마 만큼 이용해야 하는지 수를 더해 구했다.

```
10 1 10 2 1
```

입력값이 들어왔을 때, 현재 위치가 1층이라고 하자. 그러면 내려갈 수는 없지만, 1 + U는 3이기 때문에 올라가고 그때는 1층에서 U층만큼 한 번 올라온 것이기 때문에 3층에 도달하기 위해서는 visited[1] + 1을 더해준 것과 같다. 만약 현재 위치가 4층이면 4 + U 즉, 6층에 도달하기 위해선 4층까지 도달하기 위해 필요한 수에 + 1을 해주면 6층까지 도달하기 위해 필요한 수가 나온다.

✔ 따라서 올라갈 때는 visited[x + U] = visited[x] + 1, 내려갈 때는 visited[x - D] = visited[x] + 1

만약 visited[목표층]이 0일 땐 G층까지 도달할 수 없다는 것이기 때문에 use the stairs를 출력하면 된다.

<br>

<hr>

#### #보물섬

[보물섬 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_2589.java)💎

다른 문제랑 큰 차이가 없어 보이지만 보물의 위치가 입력되지 않았다는 점에서 약간 다르다. 보물의 위치는 **"서로 간에 최단 거리로 이동하는데 있어 가장 긴 시간이 걸리는 육지 두 곳에 나뉘어 묻혀있다"**는 조건에 따라 최단 거리로 이동하되, 가장 오랜 시간이 걸리는 경우를 찾기 위해 BFS로 풀면 된다.

출발점은 반복문을 통해서 육지면서 아직 방문하지 않는 점으로 정하면 되지만, 끝점의 경우 출발점과 연결된 모든 육지가 끝점이 될 수 있다. 따라서 모든 점을 끝점이라고 생각하고 그 모든 정점에 도달하는 수를 visited 배열을 이용해 구하고 그 값이 최대일 경우가 바로 문제가 요구하는 보물의 위치가 될 것이고, 그와 동시에 보물까지 가는 최단 거리가 될 것이다.

<br>

즉, vistied 배열은 방문 여부 표시와 동시에 출발점에서 현재의 점까지 이동한 거리를 저장한다고 생각하면 된다. 예를 들어 1-2-3-4로 연결된 지점이 있다고 가정하자. 1에서 출발해 2까지 가는 수는 visited[1] + 1일 것이고, 3의 경우에는 2를 중간에 끼고 가야 하기 때문에 visited[2] + 1이 된다는 점을 이용하면 된다.

<br>

시작점을 잡고 작성된 visited 배열에서 최댓값을 찾아 최종 결과값이 될 변수 max와 비교한 뒤 max보다 크면 이 최댓값을 넣어주고 반복문을 통해 다음 시작점을 잡고 똑같이 BFS를 실행시키면 된다. 

<br>

<hr>

#### #탈출

[탈출 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_3055.java)🦔

귀여운 문제처럼 보이길래 도전! 했지만 오늘 풀었던 어떤 문제보다도 가장 오래 걸렸다... 😑

이 문제가 내게 어려웠던 이유는 물부터 먼저 채우고, 후에 고슴도치를 이동시켜야 하는 것은 알고 있었는데, BFS는 큐가 비워질 때까지 계속 진행이 되기 때문에 물 먼저, 고슴도치, 그리고 다시 물 채우기 .. 의 과정을 어떻게 해야 할지 감이 안 잡혔어서였다.

처음에는 큐 2개, map 2개, visited 2개를 쓰고 BFS 함수 또한 2개로 나눠서 물을 채우고, 고슴도치를 이동 시키는 과정을 진행했는데 일단 변수가 많아서 헷갈리기도 했고, 시간도 너무 오래걸렸다. 무엇보다 예제부터 틀린다는 게 제일 큰 문제였고... 😥

그래서 다른 사람 풀이를 참고하니 큐 2개를 쓰되, 큐가 비워질 때까지 시도하는 게 아니라 처음 들어왔을 때의 큐 사이즈만큼 BFS를 진행하면 되는 거였다. (여기서 너무 쇼킹해서 소리 지름😲)

<br>

1. map을 입력 받으면서 S일 때는 고슴도치 이동 경로가 될 큐인 queue에 해당 지점을 삽입하고, D일 때는 end_x, end_y에 각각 값을 넣어준다. 그리고 *일 때는 물의 경로가 될 큐인 water_queue에 해당 지점을 삽입한다.
2. BFS 함수를 호출한다.
3. BFS는 고슴도치가 D까지 이동해야 하는 문제이기 때문에 queue가 전부 비워질 때까지 진행하고, 물의 이동경로도 고려해야 하기 때문에 처음의 물 위치가 기록된 water_queue에서 water_queue의 사이즈만큼 BFS를 한다.
4.  3번에서 이동할 수 있는 경우는 S점이거나 빈 칸인 . 지점일 때이며, 물은 방문 여부를 표시하지 않아도 된다.
5. 4번의 과정이 전부 끝이나면 고슴도치의 이동과정을 확인하기 위해 queue의 사이즈만큼 BFS를 한다.
6. 5번에서 이동할 수 있는 경우는 돌이 있는 X와 물이 있는 * 지점을 제외해서 이동이 가능하고, 방문여부를 확인하기 위해 visited 값을 비교해야 한다.
7. 최소 경로를 구하고 있기 때문에 visited에 경로의 길이를 계산해 최종적으로 D의 위치의 visited 배열의 값을 출력하면 된다.

<br>

<hr>
#### #카카오 프렌즈 컬러링북
#### #카카오 프렌즈 컬러링북

[컬러링북 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.08/카카오프렌즈 컬러링북.java)

비교적 쉬운 문제였으나, 프로그래머스에서 처음 푸는 문제라 IDE가 익숙하지 않아 시간은 좀 걸렸다...

어피치가 귀여워서 일부러 골라서 풀었다🍑

[단지번호붙이기](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_2667)와 유사한 문제. 처음에는 같은 문제인 줄 알고 풀었는데 제대로 읽고 보니 **그림의 난이도를 영역의 수**라고 정의하고 있었다. 그래도 크게 차이는 없었다.

<br>

1. 0은 색칠하지 않은 영역이기 때문에 0이 아닌 수를 기준으로 색칠된 수를 찾아 그 정점부터 BFS / DFS를 한다.
2. 난이도가 같은 수를 기준으로 해야 하기 때문에 단지번호붙이기와 달리 nx, ny 인덱스를 가진 값이 기준값인 x, y 인덱스의 값과 같아야 같은 난이도임을 주의하고 이를 조건으로 두어 영역의 수를 카운트한다.
3. 색칠하지 않은 영역이 군데군데 있으므로 이를 위해 영역의 크기를 리스트 자료구조에 저장한다.
4. 1번의 반복문이 끝난 후, 리스트의 사이즈가 영역의 수 리스트를 오름차순 정렬한 뒤 가장 끝 값이 영역의 크기가 가장 큰 수가 될 것이다.

<br>

<hr>

#### #나이트의 이동

[나이트의 이동 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_7562.java)♟

체스에 대해서 하나도 모르지만 문제 설명에 나와있어서 쉽게 풀 수 있었다.

전형적인 BFS 문제이고 다만 이동 범위가 달라 위치를 잡는 전역변수 배열만 약간 고쳐주면 된다.

처음에는 어떻게 경로의 수를 셀지 고민했다... 간만에 푸는 것도 아니었는데 왜 고민했지 싶을 정도로 [미로탐색](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_2178.java)처럼 visited 함수에 방문할 때마다 1을 더해주어 경로의 수를 구하면 되는 문제였다. 미로탐색과 거의 흡사한 문제.

<br>

<hr>

#### #경로 찾기

[경로 찾기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_11403.java) 🔍

무방향 그래프는 몇 문제 푼 적이 있었는데 방향 그래프 문제는 처음 풀어보는 것 같다. 하지만 접근은 거의 비슷했다!

만약 정점 A와 연결된 정점 B가 있다고 가정해 보자. 이때,  정점 B는 정점 C와 연결되어있지만, 정점 A와 C 사이의 간선은 존재하지 않는다. 그렇다하더라도 A가 B와 연결돼 있고, B가 C와 연결돼 있기 때문에 A와 C가 연결됐다고 생각해야 한다. 

따라서 모든 정점마다 연결된 정점을 찾아가고, 다시 그 정점에서 연결된 정점들을 찾으면 한 정점에서 방문할 수 있는 정점들 모두를 구할 수 있게 된다.

1. 한 정점에서 방문 여부를 확인하기 때문에 visited 배열은 1차원 배열로 선언하고, map은 모든 정점들 사이의 간선을 표시해야 하기 때문에 2차원 배열로 선언한다.
2. 모든 정점마다 BFS를 해서 방문 여부를 확인해야 하기 때문에 반복문을 돌린다.
3. BFS 함수에서는 한 정점으로부터 연결된 모든 점을 찾고 방문 여부를 따져 visited 배열에 방문 여부를 표시하고, 큐에 삽입한다.
4. 큐에서 정점을 하나씩 poll해서 또 그 정점부터 연결된 정점들을 탐색한다.
5. BFS 과정이 끝날 때마다 2번으로 돌아가 visited 배열을 출력한다.

<br>

<hr>

⭐⭐⭐⭐⭐

#### #벽 부수고 이동하기

[벽 부수고 이동하기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_2206.java)

처음에는 백트래킹으로 접근하려고 했으나 최단 경로를 구하는 문제이기 때문에 BFS를 사용해야 하고, 그렇게 되면 백트래킹 방법으로 문제를 풀 수 없었다. DFS로 풀기에는 시간 초과가 날 것 같아 어떻게 풀지 고민을 했다.

또한 벽을 부수는 모든 경우의 수를 구해서 비교하는 것 또한 시간초과와 함께 좋은 방법이 아니라서 고민하다가 다른 사람의 풀이를 참고했다.

<br>

벽을 부수지 않은 경우와 벽을 부숴서 이동하는 경로를 따로 체크해야 하기 때문에 visited 배열을 3차원으로 선언해 마지막 인덱스에 벽을 부쉈는지, 부수지 않았는지를 검사하는 부분이 필요했다. 즉, 3차원 형식으로 visited[x] [y] [0]의 형태를 가지면 된다.

또한 Location 클래스에도 변수 crush를 선언해 벽을 부쉈는지의 여부를 체크할 수 있도록 한다.

처음에는 전역 변수 cnt를 선언해 최소 경로의 길이를 구하려고 했으나, 계속 엉뚱한 값이 나왔고 다른 사람 풀이처럼 Location에 이를 따로 저장하는 방식을 택했다. 즉, Location 클래스에 변수 depth를 선언해 길이를 저장할 수 있도록 한다.

(이 부분에 대해서는 좀 더 알아봐야겠다.)

<br>

1. 현재 영역이 벽이 아닌 경우에는 충돌여부와 관계없기 때문에 visited 배열에 방문 여부를 표시하고, 현재 좌표 값을 큐에 삽입한다. 
2. 현재 영역이 벽이고, 아직 벽을 부순 적이 없고, 아직 방문 여부가 없다면 visited 배열에 방문 여부를 표시하고, 현재 좌표 값을 큐에 삽입한다. 

<br>

2번의 경우, queue.add(new Location(nx, ny, 1, depth + 1)); 라고 하는 대신에 crush = 1; queue.add(new Location(nx, ny,  crush, depth + 1));로 하면 자꾸 "틀렸습니다" 가 떴다... 이것도 다시 생각해서 정리해야겠다. 😥






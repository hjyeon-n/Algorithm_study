# Dijkstra Algorithm (다익스트라 알고리즘)

그래프에서 정점끼리의 최단 경로를 구하는 문제 중, 다익스트라 알고리즘은 하나의 정점에서 다른 모든 정점까지의 최단 경로를 구하는 문제의 알고리즘이다. MST의 프림 알고리즘과 매우 흡사하다.

다익스트라 알고리즘의 기론 로직은 첫 정점을 기준으로 연결되어있는 정점들을 추가해 가며 최단 거리를 갱신하는 것이다. 정점을 잇기 전까지는 시작점을 제외한 정점들은 모두 무한대 값을 가진다. 

정점 A에서 정점 B로 이어지면 정점 B가 가지는 최단 거리는 시작점부터 정점 A까지의 최단 거리 + 점 A와 점B 간선의 가중치와 기존에 가지고 있던 정점 B의 최단 거리 중 작은 값이 B의 최단 거리가 된다.

<br>

![image](https://user-images.githubusercontent.com/62419307/91636300-6a430000-ea3a-11ea-940d-1620dc91ae21.png)

초기화된 그래프의 모습이다. 시작 정점이 0번으로 시작하고 다른 정점은 아직 방문하지 않았기 때문에 INF로 초기화하였다. 해당 표는 dist라 하고, 거리를 표현한다. 가중치는 d 배열로 표시하고 만약, 0과 1의 가중치를 표현하고자 할 때, d[0] [1]이라 표시한다.

 <br>

![image](https://user-images.githubusercontent.com/62419307/91636330-a6766080-ea3a-11ea-9b52-d3a69b12a9e7.png)

0번 정점에서 인접한 정점은 1, 2, 5 정점이고 각각의 정점으로 가는 거리는 INF로 초기화 되었기 때문에 각 간선의 가중치가 INF보다 작다. 따라서 가중치 값으로 표를 갱신한다.

<br>

![image](https://user-images.githubusercontent.com/62419307/91636383-010fbc80-ea3b-11ea-8894-2b62bde93765.png)

아직 방문하지 않은 정점 중 가중치가 가장 작은 정점 1부터 방문한다. 

dist[2]는 이전의 값이 9, 현재 값이 10이므로 9 < 10

따라서, 갱신하지 않고 넘어간다.

dist[3]의 경우 이전의 값이 INF,  dist[1] + d[1] [3] = 22이므로

22로 dist[3]을 갱신한다.

<br>

![image](https://user-images.githubusercontent.com/62419307/91636604-de7ea300-ea3c-11ea-9dbd-f7ca38d665a5.png)

1번 정점 다음으로 가중치가 작은 2번 정점을 방문한다. 

이전 dist[5]의 값은 14, 2번 정점에서 5번을 방문하면 dist[2] + d[2] [5]이 11이 되므로

dist[5]는 11로 갱신이 된다.

이전 dist[3]의 값은 22, 현재 값은 dist[2] + d[2] [3]은 20이므로

dist[3]은 20으로 갱신된다.

<br>

![image](https://user-images.githubusercontent.com/62419307/91636769-1e925580-ea3e-11ea-88dc-3f77520c2e12.png)

마지막으로 정점이 가장 작은 정점 5를 방문한다. (0번 정점에서 가중치가 작은 순으로 1, 2, 5를 방문하고 있다는 걸 잊지 말자!) 

dist[4]의 이전 값은 INF, 현재 값은 dist[5] + d[5] [4]는 20이기 때문에

dist[4]는 20으로 갱신한다.

<br>

![image](https://user-images.githubusercontent.com/62419307/91636923-72516e80-ea3f-11ea-833a-68e71ac16a4b.png)

0번 정점과 인접한 정점은 다 방문했고, 그 후에 1번 정점과 인접한 정점은 2번 정점과 3번 정점이 있다. 2번 정점은 이미 방문했기 때문에 3번 정점을 방문한다.

dist[4]의 이전 값은 20, 현재 값은 dist[3] + d[3] [4]은 26이기 때문에

dist[4]는 20으로 갱신된다.

<br>

![image](https://user-images.githubusercontent.com/62419307/91637225-04f30d00-ea42-11ea-9a21-058469b15d1e.png)

2번 정점과 인접한 정점은 모두 방문했기 때문에 5번 정점과 인접한 정점 4번 정점을 방문한다.

<br>

### 최단거리인 걸 어떻게 보장해? 🤷‍♀️

아직 방문하지 않은 정점들 중 가중치 값이 가장 작은 정점이 u고, 사실 dist[u]는 최단거리보다는 아직 크다고 가정하자. 이때 정점 u를 방문하면 dist[u] 값은 최단거리가 아니게 된다.

또한 dist[u]가 아직 최단거리가 아니라는 말은, 다른 임의의 정점 v를 거치는 경로를 통해 최단거리로 갱신될 수 있다는 말이 된다. 즉, dist[u] > dist[v] + d[v] [u]인 어떤 정점 v가 존재한다는 것이다.

그런데 **아직 방문하지 않은 정점 중에서** 가중치 값이 제일 작은 게 u라고 했으니까 v는 방문한 상태임을 의미한다.

그런데 v를 방문했을 때 dist[u]는 이미 dist[v] + d[v] [u]로 갱신되었을 것이다.

따라서 항상 최단거리임을 보장할 수 있다.

하지만 이와 같은 경우도 가중치가 0이상인 수, 즉 음수가 아닐 때만 적용이 가능하고 가중치가 음수인 경우에는 **벨만 포드 알고리즘**을 사용해야 한다.

<br>

### 어떻게 구현해야 하지? 👀

가장 주의해야 하는 부분은 아직 방문하지 않은 정점들 중에서 dist 값이 제일 작은 정점을 찾아 방문하는 부분이다.

그냥 dist 값들을 다 비교해서 찾다가는 매번 O(V)고, 루프는 V-1번 실행되니까 O(V^2)의 시간복잡도가 된다. 따라서 **우선순위 큐**를 사용해야 한다.

최소 힙을 하나 정의한다. 그리고 정점 u를 방문해서 인접한 정점 v의 거리를 갱신할 때마다 최소 힙에 **(dist[v], v) 쌍**을 넣는다.

pair는 첫 번째 인자의 대소 비교를 먼저 하므로, dist 값이 작으면 작을수록 우선순위 큐에서 먼저 나오게 된다.

dist 값이 제일 작은 걸 뽑아서, 그 두 번째 인자인 정점 번호를 사용하면 됩니다.

또한 v를 방문하기 전에 값이 여러 번 갱신될 수도 있고, 그럼 서로 다른 (d, v) 값들이 우선순위 큐 안에 존재할 수 있는데 이땐 제일 작은 d 값 하나만 뽑아서 쓰면 되고 우선순위 큐가 이걸 자동으로 해결해 준다.

다만, 아직 우선순위 큐에 남아있는 v 정점에 관한 쌍은 놔뒀다가 추후 top에서 나타나면 무시한다. 즉, 꺼낸 정점이 이미 방문한 곳이면 무시하고 다음 top을 꺼내면 된다.

이렇게 하면, 한 정점에 최대한 많은 갱신이 이루어진다고 해도 넉넉잡아 V^2번 갱신이 이루어져서 PQ에 한 순간에 V^2개의 정보가 들어있다고 해도 원래 연산에 O(logN)의 시간이 드는 우선순위 큐 입장에서는 **O(log(V^2)) = O(2logV) = O(logV)**.

즉, 최대 O(E)번 우선순위 큐에서 top을 꺼내는 연산 O(logV),

루프 전체를 통틀어서 인접한 정점으로의 거리를 갱신하는 부분도 최대 O(E)번 이루어질 것이므로

총 시간복잡도 합은 **O(ElogV)**이다.

여기서 O(E)라는 시간복잡도 또한 그래프를 **인접 리스트**로 구현했을 때를 말한다. 인접행렬로 구현했다면 매번 인접한 정점을 찾아야 하니 루프마다 O(V)의 시간이 소요되어서 총합 O(V^2)가 된다.

한 가지 예외처리를 해야 하는 경우가 있다.

그래프 자체가 연결 그래프가 아니거나, 아니면 유향 그래프에서 시작점에서 어떤 정점으로 못 갈 때는 루프를 꼭 V-1번 돌지 못한다. 중간에 우선순위 큐가 텅텅 비어버리게 되고 이때는 그냥 나와야 한다.

아직 방문하지 못한 정점들의 경우는 거리가 무한으로 남아 있고, 이는 시작점에서 그 정점으로 갈 수 없다는 뜻이 된다.

<br>

[참고1](https://m.blog.naver.com/kks227/220796029558)

[참고2](https://hsp1116.tistory.com/42)
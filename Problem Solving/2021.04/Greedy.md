# Greedy

| 문제 번호                                      | 이름                                |
| ---------------------------------------------- | ----------------------------------- |
| [1080](https://www.acmicpc.net/problem/1080)   | [행렬](#행렬)                       |
| [1946](https://www.acmicpc.net/problem/1946)   | [신입 사원](#신입-사원)             |
| [1449](https://www.acmicpc.net/problem/1449)   | [수리공 항승](#수리공-항승)         |
| [11497](https://www.acmicpc.net/problem/11497) | [통나무 건너뛰기](#통나무-건너뛰기) |

<br>

<hr>

#### #행렬

[행렬 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.04/Solution_1080.java)

실버2인데 왜 이렇게 어려운 문제지? 싶을 만큼 기존에 내가 알던 그리디 방식으로 생각하면 너무 어려워진다...

질문 카테고리에서 대충의 해결법을 찾아서 문제는 풀었지만 왜 그리디인지 잘 이해가 되지 않았다.

나는 그리디라면 최대한 많이 뒤집을 수 있는 영역을 그때마다 찾아야 한다고 생각했는데 (심지어 질문을 하신 분도 나와 같은 생각이었다😅) 의외로 아니었다.

이 문제의 목적은 행렬 A를 행렬 B로 바꾸는 것이기 때문에 행렬 A의 값이 B와 다르다면 반드시 뒤집어야 한다. 0과 1 두 가지 경우밖에 없는 뒤집기의 특성상 같은 영역을 2번 이상 뒤집는 건 의미가 없다. 다시 원래상태로 돌아오기 때문이다.

그래서 최적의 선택은 **반드시 뒤집어야 하는 칸을 뒤집되, 뒤집는 횟수를 최소화하는 것**이다. 그렇기 때문에 행렬을 순서대로 탐색하면서, "반드시 뒤집어야 하는 부분이 있으면" 뒤집는다. 

이 알고리즘이 결론적으로 그리디 알고리즘이 된다. 음 항상 그리디 알고리즘이라 하면 '거스름돈' 문제 유형만 생각했는데 좀 더 생각을 확장하는 연습을 해야겠다...! 😵

<br>

<hr>

#### #신입 사원

[신입 사원 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2021.04/Solution_1946)

이 문제는 문제 이해부터 무슨 말인지 이해가 안 돼서 질문 카테고리를 참고해서 이해했다... 💦

나는 서류 순위를 기준으로 해서 오름차순 정렬을 했다. 그러면 면접 순위만 비교해서 합격자가 최대 몇 명인지 구할 수 있다.

아래와 같은 예제가 있다고 가정하자.

```
3 6
7 3
4 2
1 4
5 7
2 5
6 1
```

<br>

위 예제는 아래와 같은 순서로 정렬된다. 이때, 서류 점수 1등인 *1 4*는 **다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는다.** 즉, 반드시 합격을 한다. 이 때 이 지원자보다 면접 등수가 높은 사람들을 선별하면 된다.

하지만, **어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다**는 조건에 의해 *7 3*은 절대로 선발될 수 없다. 왜냐하면 합격자인 *6 1*보다 서류 등수도 면접 등수도 모두 떨어지기 때문이다.

```
1 4
2 5
3 6
4 2
5 7
6 1
7 3
```

<br>

다른 풀이가 없을까 싶어서 다른 사람 풀이를 찾아봤는데 깔끔한 방법을 찾아냈다.

입력부터 서류 점수를 인덱스로 하는 일차원 배열을 선언 및 입력한다. 그러면 아래와 같이 배열이 구성된다.

```
4
5
6
2
7
1
3
```

그러면 아까처럼 Comparator 정렬을 하지 않고도 면접 점수만을 얻을 수 있다. 이제 첫 번째 값을 compare 값으로 두고 이 값보다 작은 값이 나왔을 때 compare 값을 갱신하고 answer 값을 증가시키면 된다.

예전에도 비슷한 문제를 풀고 이렇게도 풀 수 있구나 생각했는데 이번에도 당한 기분이다...! 이번에야말로 이 테크닉을 습득해야겠다!

두 풀이 모두 깃헙에 올렸으니 참고하면 된다! 😊

<br>

<hr>

#### #수리공 항승

[수리공 항승 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.04/Solution_1449.java)

워낙 그리디에 약해서 어려울까 봐 겁 먹었는데 아주 쉽게 풀었다.

길이가 L인 테이프로 구멍을 막으면 되는데 이때, 좌우 0.5만큼 간격을 더 줘야 한다. 즉, 1을 막기 위해서는 0.5부터 1.5까지 막아야 하는 것이다.

하나의 테이프로 여러 구멍을 막을 수 있도록 우선 값들을 정렬한 뒤 첫 번째 값에 L 만큼 더해 bound를 구했다. 이때 **bound보다 크거나 같으면** 테이프를 하나 더 써야 한다. 그 이유는 길이가 2인 테이프가 있을 때 1 2를 막고자 한다면 테이프로 0.5부터 1.5까지만 막을 수 있기 때문에 하나의 테이프가 더 필요하기 때문이다.

<br>

<hr>

#### #통나무 건너뛰기

[통나무 건너뛰기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.04/Solution_11497.java)

마지막 수와 첫 번째 수도 인접하다는 조건 때문에 오름차순으로 정렬을 하면 두 사이의 절댓값이 제일 커져버린다. 따라서 다른 방식의 정렬 방식을 생각해야 한다.

각 차이의 절댓값이 가장 작게 나오는 경우는 둘의 차이가 제일 작을 때이다. 이 경우를 생각해서 오름차순으로 배열을 정리한 뒤에 바로 옆 인덱스와 뒤에서 시작하는 인덱스에 값들을 넣어준다. 글로만 보면 이해가 쉽지 않으므로 그림을 그려서 설명하겠다.

아래와 같은 배열이 있다고 생각하자.

| 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- |
| 2    | 5    | 4    | 7    | 9    |

 <br>

오름차순으로 정렬하면 이와 같은 순서로 정렬된다.

| 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- |
| 2    | 4    | 5    | 7    | 9    |

<br>

새로운 배열 newArr을 선언해서 값들을 넣어줄 차례이다. 0번 인덱스의 값은 newArr 값에 그대로 복사한다. 그리고 1번 인덱스부터 차례대로 값을 넣어줄 것이다. 1번 인덱스에 넣을 값은 0번 인덱스의 값인 2와 절댓값 차이가 가장 작은 4가 된다.

| 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- |
| 2    | 4    |      |      |      |

<br>

그리고 마지막 수와 첫 번째 수가 인접하다는 조건 때문에 마지막 인덱스에는 2와 절댓값 차이가 그 다음으로 작은 5를 넣어준다. (사실 마지막 수가 4로, 1번 인덱스의 수가 5로 와도 상관 없다. 어차피 구하는 건 인접한 수의 차이이기 때문이고 이는 어떤 경우라도 동일하기 때문이다.)

| 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- |
| 2    | 4    |      |      | 5    |

<br>

이런 식으로 newArr을 전부 채울 수 있다.

| 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- |
| 2    | 4    | 7    | 9    | 5    |

<br>

이 문제를 풀 때는 설마 이렇게 푸는 건가 싶었는데 한 번 풀어보자 싶어서 풀어봤더니 맞는 풀이였다. 앞으로도 자신감 갖고 문제를 풀어야겠다! 💪
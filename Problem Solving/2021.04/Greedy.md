# Greedy

| 문제 번호                                    | 이름                        |
| -------------------------------------------- | --------------------------- |
| [1080](https://www.acmicpc.net/problem/1080) | [행렬](#행렬)               |
| [1946](https://www.acmicpc.net/problem/1946) | [신입 사원](#신입-사원)     |
| [1449](https://www.acmicpc.net/problem/1449) | [수리공 항승](#수리공-항승) |

<br>

<hr>

#### #행렬

[행렬 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.04/Solution_1080.java)

실버2인데 왜 이렇게 어려운 문제지? 싶을 만큼 기존에 내가 알던 그리디 방식으로 생각하면 너무 어려워진다...

질문 카테고리에서 대충의 해결법을 찾아서 문제는 풀었지만 왜 그리디인지 잘 이해가 되지 않았다.

나는 그리디라면 최대한 많이 뒤집을 수 있는 영역을 그때마다 찾아야 한다고 생각했는데 (심지어 질문을 하신 분도 나와 같은 생각이었다😅) 의외로 아니었다.

이 문제의 목적은 행렬 A를 행렬 B로 바꾸는 것이기 때문에 행렬 A의 값이 B와 다르다면 반드시 뒤집어야 한다. 0과 1 두 가지 경우밖에 없는 뒤집기의 특성상 같은 영역을 2번 이상 뒤집는 건 의미가 없다. 다시 원래상태로 돌아오기 때문이다.

그래서 최적의 선택은 **반드시 뒤집어야 하는 칸을 뒤집되, 뒤집는 횟수를 최소화하는 것**이다. 그렇기 때문에 행렬을 순서대로 탐색하면서, "반드시 뒤집어야 하는 부분이 있으면" 뒤집는다. 

이 알고리즘이 결론적으로 그리디 알고리즘이 된다. 음 항상 그리디 알고리즘이라 하면 '거스름돈' 문제 유형만 생각했는데 좀 더 생각을 확장하는 연습을 해야겠다...! 😵

<br>

<hr>

#### #신입 사원

[신입 사원 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2021.04/Solution_1946)

이 문제는 문제 이해부터 무슨 말인지 이해가 안 돼서 질문 카테고리를 참고해서 이해했다... 💦

나는 서류 순위를 기준으로 해서 오름차순 정렬을 했다. 그러면 면접 순위만 비교해서 합격자가 최대 몇 명인지 구할 수 있다.

아래와 같은 예제가 있다고 가정하자.

```
3 6
7 3
4 2
1 4
5 7
2 5
6 1
```

<br>

위 예제는 아래와 같은 순서로 정렬된다. 이때, 서류 점수 1등인 *1 4*는 **다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는다.** 즉, 반드시 합격을 한다. 이 때 이 지원자보다 면접 등수가 높은 사람들을 선별하면 된다.

하지만, **어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다**는 조건에 의해 *7 3*은 절대로 선발될 수 없다. 왜냐하면 합격자인 *6 1*보다 서류 등수도 면접 등수도 모두 떨어지기 때문이다.

```
1 4
2 5
3 6
4 2
5 7
6 1
7 3
```

<br>

다른 풀이가 없을까 싶어서 다른 사람 풀이를 찾아봤는데 깔끔한 방법을 찾아냈다.

입력부터 서류 점수를 인덱스로 하는 일차원 배열을 선언 및 입력한다. 그러면 아래와 같이 배열이 구성된다.

```
4
5
6
2
7
1
3
```

그러면 아까처럼 Comparator 정렬을 하지 않고도 면접 점수만을 얻을 수 있다. 이제 첫 번째 값을 compare 값으로 두고 이 값보다 작은 값이 나왔을 때 compare 값을 갱신하고 answer 값을 증가시키면 된다.

예전에도 비슷한 문제를 풀고 이렇게도 풀 수 있구나 생각했는데 이번에도 당한 기분이다...! 이번에야말로 이 테크닉을 습득해야겠다!

두 풀이 모두 깃헙에 올렸으니 참고하면 된다! 😊

<br>

<hr>

#### #수리공 항승

[수리공 항승 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.04/Solution_1449.java)

워낙 그리디에 약해서 어려울까 봐 겁 먹었는데 아주 쉽게 풀었다.

길이가 L인 테이프로 구멍을 막으면 되는데 이때, 좌우 0.5만큼 간격을 더 줘야 한다. 즉, 1을 막기 위해서는 0.5부터 1.5까지 막아야 하는 것이다.

하나의 테이프로 여러 구멍을 막을 수 있도록 우선 값들을 정렬한 뒤 첫 번째 값에 L 만큼 더해 bound를 구했다. 이때 **bound보다 크거나 같으면** 테이프를 하나 더 써야 한다. 그 이유는 길이가 2인 테이프가 있을 때 1 2를 막고자 한다면 테이프로 0.5부터 1.5까지만 막을 수 있기 때문에 하나의 테이프가 더 필요하기 때문이다.
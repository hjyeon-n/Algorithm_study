# Greedy

| 문제 번호                                    | 이름          |
| -------------------------------------------- | ------------- |
| [1080](https://www.acmicpc.net/problem/1080) | [행렬](#행렬) |

<br>

<hr>

#### #행렬

[행렬 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.04/Solution_1080.java)

실버2인데 왜 이렇게 어려운 문제지? 싶을 만큼 그리디로 생각하면 너무 어려워진다...

질문 카테고리에서 대충의 해결법을 찾아서 문제는 풀었지만 왜 그리디인지 잘 이해가 되지 않았다.

나는 그리디라면 최대한 많이 뒤집을 수 있는 영역을 그때마다 찾아야 한다고 생각했는데 (심지어 질문을 하신 분도 나와 같은 생각이었다😅) 의외로 아니었다.

이 문제의 목적은 행렬 A를 행렬 B로 바꾸는 것이기 때문에 행렬 A의 값이 B와 다르다면 반드시 뒤집어야 한다. 0과 1 두 가지 경우밖에 없는 뒤집기의 특성상 같은 영역을 2번 이상 뒤집는 건 의미가 없다. 다시 원래상태로 돌아오기 때문이다.

그래서 최적의 선택은 **반드시 뒤집어야 하는 칸을 뒤집되, 뒤집는 횟수를 최소화하는 것**이다. 그렇기 때문에 행렬을 순서대로 탐색하면서, "반드시 뒤집어야 하는 부분이 있으면" 뒤집는다. 

이 알고리즘이 결론적으로 그리디 알고리즘이 된다. 음 항상 그리디 알고리즘이라 하면 '거스름돈' 문제 유형만 생각했는데 좀 더 생각을 확장하는 연습을 해야겠다...! 😵


# BFS, DFS

### BFS로 푼 문제

| 문제 번호                                      | 이름                                   |
| ---------------------------------------------- | -------------------------------------- |
| [4179](https://www.acmicpc.net/problem/4179)   | [불!](#불!)                            |
| [14496](https://www.acmicpc.net/problem/14496) | [그대, 그머가 되어](그대,-그머가-되어) |

<br>

### DFS로 푼 문제

| 문제 번호                                    | 이름                        |
| -------------------------------------------- | --------------------------- |
| [1068](https://www.acmicpc.net/problem/1068) | [트리](#트리)               |
| [1967](https://www.acmicpc.net/problem/1967) | [트리의 지름](#트리의-지름) |

<br>

### BFS, DFS로 푼 문제

| 문제 번호                                      | 이름                    |
| ---------------------------------------------- | ----------------------- |
| [3187](https://www.acmicpc.net/problem/3187)   | [양치기 꿍](#양치기-꿍) |
| [13565](https://www.acmicpc.net/problem/13565) | [침투](#침투)           |

<br>

<hr>

#### #불!

[불! 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.04/Solution_4179.java)

[탈출](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.08/BFS%2C%20DFS.md#%ED%83%88%EC%B6%9C) 문제와 [불](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.11/BFS%2C%20DFS.md#%EB%B6%88) 문제와 아주 흡사하다. 사실 왜 이 문제만 골드4 문제인지도 모르겠다... 탈출 조건이 가장자리라서 그런가?

몇 번의 메모리 초과가 있었지만 어렵지 않게 해결할 수 있었다.

1. 값을 입력 받는다. J를 입력 받을 땐, J의 탈출 경로를 나타내는 큐 escape에 해당 좌표를 저장하고 map의 값은 '.'로 저장한다. 'F'일 때는 불이 퍼지는 경로인 fire 큐에 좌표를 저장한다.
2. bfs 탐색을 시작한다.
3. fire의 큐 사이즈만큼 탐색을 시작한다. **먼저 fire를 탐색하는 이유는 지훈이가 이동할 곳에 불이 있는지를 먼저 확인해 봐야 하기 때문이다.**
4. fire는 빈 칸일 때 map의 값을 'F'로 바꿔주고 fire 큐에 좌표 값을 넣어준다.
5. 지훈이가 이동할 경로를 파악하기 위해 마찬가지로 escape의 사이즈만큼 탐색을 시작한다. 빈 칸이고 아직 방문하지 않았다면 방문 여부를 표시하고 escape 큐에 좌표 값을 저장한다.
6. 만약, 지훈이가 이동할 칸이 map의 가장자리라면 탈출이 가능하므로 미리 나가는 값을 계산하기 위해 t에 1을 더한 뒤 출력하고 return하여 함수를 끝낸다.
7. 탐색이 끝났는데 escape가 비어있다면 더이상의 탈출 경로는 없다는 것이기 때문에 "IMPOSSIBLE"을 출력한다.

<br>

메모리 초과가 났던 부분은 5번 때문이었다. 5번에서는 방문 여부를 표시하지 않고 불이 퍼지는 공간에만 방문 여부를 체크했었다. 왜냐면 지훈이가 이동하는 경로에도 불이 이동할 수 있기 때문에 그렇게 푼 것이었는데 만약 방문 표시를 하지 않는다면 지훈이가 탈출할 경로를 탐색하던 중에 메모리 초과가 나게 된다. 

하지만 불 또한 같은 이유로 방문 여부가 필요했다. 그래서 지훈이가 위치하는 곳도 빈 칸으로 초기화하고 빈 칸인 경우에만 불이 퍼지게 했고 map의 값을 'F'로 초기화하여 방문 여부를 표시하는 방법을 썼다. 그리고 지훈이의 이동 경로는 visited 배열을 이용했다.

예전이라면 visited 함수를 두 개로 만들어야 하나 고민했겠지만 비슷한 유형의 문제를 많이 풀어서인지 쉽게 풀 수 있었다! 😏

<br>

<hr>

#### #양치기 꿍

[양치기 꿍 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2021.04/Solution_3187)

간만에 푼 쉬운 문제! 사실 이런 유형의 문제를 많이 풀기도 해서 풀이는 생략!

[양](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.12/BOJ.md#%EC%96%91) 문제와 아주 흡사하다.

<br>

<hr>

#### #트리

[트리 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.04/Solution_1068.java)

DFS가 약하기도 하고 트리 문제는 보기만 해도 소리 지르고 싶어서 내내 안 풀다가 마음 잡고 풀었던 문제.

사실 마음 잡고 풀 난이도는 아니다. 어렵지 않게 풀었다... 😙

<br>

이 문제는 제거될 노드의 자식 노드까지 전부 제거하는 게 포인트인데 이는 노드를 제거해서 그 노드에 대한 탐색을 진행하지 않으면 되기 때문에 어렵지 않게 해결할 수 있다. 다만, 문제에서 요구한 노드를 제거해서 **그 노드의 부모가 단일노드가 되었을 경우도 함께 고려해야 한다. **

1. 인접 리스트 형태로 그래프를 정의한다.
2. 리스트의 각 인덱스는 부모 인덱스를 뜻하고 자식 노드를 리스트에 추가한다. (즉, 이중리스트 형태로)
3. 부모가 -1이라면 해당 노드는 root 노드가 되기 때문에 root라는 변수를 따로 두어 노드 번호를 저장한다.
4. 만약 제거할 노드가 root라면 0을 출력한다.
5. root 노드부터 탐색을 시작한다.
6. 해당 노드에 대한 방문 여부를 표시한 뒤, 인접 노드들을 가지고 온다. 
7. 만약, 인접 노드 리스트 가운데 remove 노드가 있다면 해당 노드를 리스트에서 제거한다.
8. 리스트의 크기가 0이라면 단말 노드이기 때문에 answer를 증가시킨다.
9. 인접 노드 리스트만큼 탐색을 한다.

<br>

<hr>

#### #트리의 지름

[트리의 지름 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.04/Solution_1967.java)

나는 몰랐는데 예전에 풀었던 코딩테스트에서 이 문제랑 비슷한 문제가 나왔다고 해서 풀었다.

이 문제를 풀면서 느낀 건 저번에 코테에서 풀었던 문제 풀이는 완전 잘못 됐구나ㅎㅎ 싶었다. 💦

모든 경로를 탐색한 후 최댓값 두 개의 값을 지름이라고 하는 줄 알고 문제에 접근했는데 그게 아니고 가장 가중치가 높은 값과 그 노드에서 가장 멀리 떨어진 곳이 트리의 지름이 된다. 문제 설명은 [여기](https://m.blog.naver.com/PostView.nhn?blogId=occidere&logNo=220961873786&proxyReferer=https%3A%2F%2Fwww.google.com%2F)를 참고하면 된다.

1. ArrayList 배열을 선언한다.
2. 입력을 받는다. 이때 역방향으로도 진행해야 하기 때문에 부모-자식 뿐만 아니라 자식-부모도 표시해준다.
3. 방문 배열을 초기화하고 최댓값을 저장할 max 값도 0으로 초기화한다.
4. 루트노드는 항상 1이기 때문에 1과 현재 거리는 0이기 때문에 이를 기준으로 dfs 탐색을 한다.
5. d값(시작점에서 v까지 다다르기 위한 가중치의 합)이 max보다 크다면 max 값과 max_idx 값을 갱신한다.
6. v에 대한 인접 정점에 대해서 탐색한다. 이때, 방문하지 않은 정점만 방문 여부를 표시하고 dfs 탐색을 시작한다.
7. 메인으로 돌아와 max 값과 visited 배열을 초기화 하고 최댓값을 가지고 있는 노드 max_idx와 d는 0인 시작점으로 해서 다시 dfs 탐색을 시작한다.
8. max 값을 출력한다.

<br>

<hr>

#### #침투

[침투 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2021.04/Solution_13565)

기본적인 BFS, DFS 문제이다 제일 첫 단에서 0, 1과 차별되는 숫자를 넣어 전류가 통할 수 있는지 확인하면 된다. 나는 숫자 2로 이를 구분했다. BFS / DFS 탐색 후 마지막 단에서 2가 있으면 'YES' 아니면 'NO'다. 기본 문제라서 구체적인 풀이는 생략한다.

<br>

<hr>

#### #그대, 그머가 되어

[그대, 그머가 되어 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2021.04/Solution_14496)

문제 분류에 다익스트라라고 적혀있길래 뭔가 무서워서 한참동안 안 풀다가 드디어 풀었다. 🙄

사실 완전 기본적인 BFS 문제이다. 이런 유형의 문제는 따로 찾지 않더라도 많이 풀어봤기 때문에 풀이는 생략한다.

<br>

다익스트라로도 풀어봤는데 역시 쉽게 풀렸다. 문제는 우선순위 큐를 작성하는 데 있다. 

큐의 자료형이 객체일 때 Comparable 같은 기준이 필요하다. 이 문제는 아래와 같이 풀었다.

```java
PriorityQueue<Node> pq = new PriorityQueue<Node>((a , b) -> (a.d - b.d));
```

 이 의미는 a.d가 b.d보다 크면 1을 나타내고 1일 때는 위치를 바꿔주기 때문에 최소 힙이라는 것을 알 수 있다.
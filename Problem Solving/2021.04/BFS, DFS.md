# BFS, DFS

### BFS로 푼 문제

| 문제 번호                                    | 이름        |
| -------------------------------------------- | ----------- |
| [4179](https://www.acmicpc.net/problem/4179) | [불!](#불!) |

<br>

<hr>

#### #불!

[불! 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.04/Solution_4179.java)

[탈출](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.08/BFS%2C%20DFS.md#%ED%83%88%EC%B6%9C) 문제와 [불](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.11/BFS%2C%20DFS.md#%EB%B6%88) 문제와 아주 흡사하다. 사실 왜 이 문제만 골드4 문제인지도 모르겠다... 탈출 조건이 가장자리라서 그런가?

몇 번의 메모리 초과가 있었지만 어렵지 않게 해결할 수 있었다.

1. 값을 입력 받는다. J를 입력 받을 땐, J의 탈출 경로를 나타내는 큐 escape에 해당 좌표를 저장하고 map의 값은 '.'로 저장한다. 'F'일 때는 불이 퍼지는 경로인 fire 큐에 좌표를 저장한다.
2. bfs 탐색을 시작한다.
3. fire의 큐 사이즈만큼 탐색을 시작한다. **먼저 fire를 탐색하는 이유는 지훈이가 이동할 곳에 불이 있는지를 먼저 확인해 봐야 하기 때문이다.**
4. fire는 빈 칸일 때 map의 값을 'F'로 바꿔주고 fire 큐에 좌표 값을 넣어준다.
5. 지훈이가 이동할 경로를 파악하기 위해 마찬가지로 escape의 사이즈만큼 탐색을 시작한다. 빈 칸이고 아직 방문하지 않았다면 방문 여부를 표시하고 escape 큐에 좌표 값을 저장한다.
6. 만약, 지훈이가 이동할 칸이 map의 가장자리라면 탈출이 가능하므로 미리 나가는 값을 계산하기 위해 t에 1을 더한 뒤 출력하고 return하여 함수를 끝낸다.
7. 탐색이 끝났는데 escape가 비어있다면 더이상의 탈출 경로는 없다는 것이기 때문에 "IMPOSSIBLE"을 출력한다.

<br>

메모리 초과가 났던 부분은 5번 때문이었다. 5번에서는 방문 여부를 표시하지 않고 불이 퍼지는 공간에만 방문 여부를 체크했었다. 왜냐면 지훈이가 이동하는 경로에도 불이 이동할 수 있기 때문에 그렇게 푼 것이었는데 만약 방문 표시를 하지 않는다면 지훈이가 탈출할 경로를 탐색하던 중에 메모리 초과가 나게 된다. 

하지만 불 또한 같은 이유로 방문 여부가 필요했다. 그래서 지훈이가 위치하는 곳도 빈 칸으로 초기화하고 빈 칸인 경우에만 불이 퍼지게 했고 map의 값을 'F'로 초기화하여 방문 여부를 표시하는 방법을 썼다. 그리고 지훈이의 이동 경로는 visited 배열을 이용했다.

예전이라면 visited 함수를 두 개로 만들어야 하나 고민했겠지만 비슷한 유형의 문제를 많이 풀어서인지 쉽게 풀 수 있었다! 😏
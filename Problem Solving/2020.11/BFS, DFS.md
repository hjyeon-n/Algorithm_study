# BFS, DFS

#### BFS, DFS로 푼 문제

| 문제 번호 | 이름                                              |
| --------- | ------------------------------------------------- |
| 9205      | [맥주 마시면서 걸어가기](#맥주-마시면서-걸어가기) |

<br>

BFS로 푼 문제

| 문제 번호 | 이름          |
| --------- | ------------- |
| 2251      | [물통](#물통) |

<br>

<hr>

#### 맥주 마시면서 걸어가기

[맥주 마시면서 걸어가기 소스 코드](https://www.acmicpc.net/problem/9205)🍺

예에전에 풀려다가 귀찮아서 미룬 문제였다. 그냥 편의점 좌표를 기준으로 맥주가 다 떨어지는지 확인만 하면 되는 거 아닌가? 단순하게 생각했었다. 하지만 **편의점 좌표가 순서대로 나오지 않는 경우가 있었다.** 따라서 BFS와 DFS로 풀어야 하는 문제이다. 

<br>

1. 좌표에 따른 맨해튼 거리를 저장하는 dist, 방문 여부를 확인하는 visited 함수를 정의한다. 이때, dist의 경우에는 현재 좌표와 다음 좌표를 확인할 수 있어야 하기 때문에 이차원 배열로, visited의 경우엔 현재 좌표만을 기준으로 하기 때문에 일차원 배열로 선언한다.
2. n + 2만큼 좌표를 입력 받아야 하기 때문에 Location을 선언해 x, y를 저장할 수 있도록 하였고, 이 배열을 locArr에 저장했다.
3. 좌표의 수만큼 반복문을 돌려서 각각의 경로를 맨해튼 거리 계산법으로 구한 뒤, dist 배열에 저장한다.
4. bfs 함수를 호출한다.
5. 만약 현재 좌표가 n + 1. 즉, 페스티벌에 도착한다면 true를 반환한다. (n +1인 이유는 n + 2 크기의 배열에서 가장 마지막 인덱스는 n + 1이고, 이에 해당하는 값은 페스티벌에 대한 값이기 때문이다.)
6. dist의 크기만큼 반복문을 돌려서 모든 값을 확인해 보고, 1000보다 크거나 같다면, 50m당 맥주 한 병을 마시는 지금의 조건으로는 결국 편의점 혹은 도착지에 도달하기 전에 맥주가 동나게 되므로 그 값을 제외하는 조건을 포함시킨다.
7. 만약 6번 조합에 부합하다면 다시 큐에 넣고 위의 과정을 반복한다.

<br>

<hr>

#### 물통

[물통 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.11/Solution_2251.java)

처음엔 문제 이해가 안 돼서 나중에 풀어야지 했는데 어쩌다가 다른 블로그를 구경하다 보니 대충의 힌트를 얻게 돼서 풀게 됐다.

이 문제를 풀기 위해서 필요한 2가지 조건이 있다.

1. 물의 일부만을 옮기는 것이 아니라 물 전부를 옮겨야 한다.
2. 만약 물의 용량을 넘어가면, 남은 물은 그대로 남는다. 예를 들어 물의 용량이 8, 9, 10일 때 세 번째 물통이 가득찼다면 첫 번째 물통으로 물 전체를 옮기게 되면 넘치게 된다. 그러면 8만큼 채우고 세 번째 물통에 2만큼은 남게 된다.
3. 첫 번째 물통이 비었을 때, 마지막 물통의 물 양을 구하기 위해서는 크기가 정해져있지 않은 자료구조가 필요하기 때문에 리스트를 선언한다.

<br>

또한, 물통을 옮기는 경우는 A에서 B 또는 C, B에서 A 또는 C, C에서 A 또는 B로 옮기는 6가지의 경우만 있다. 이 경우만 고려하면 된다.

처음에는 정말로 6가지의 경우를 생각했는데 또 각각의 경우에서 파생될 수 있는 것들도 다 생각해야 하기 때문에 BFS 혹은 DFS로 문제를 풀어야 한다. 나는 BFS로 문제를 풀었다.

코드는 직관적이기 때문에 위의 2가지 조건만 유념하면 쉽게 이해할 수 있다. 따라서 자세한 풀이는 생략한다.




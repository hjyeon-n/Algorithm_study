# BFS, DFS

#### BFS, DFS로 푼 문제

| 문제 번호 | 이름                                              |
| --------- | ------------------------------------------------- |
| 9205      | [맥주 마시면서 걸어가기](#맥주-마시면서-걸어가기) |

<br>

#### BFS로 푼 문제

| 문제 번호 | 이름                                      |
| --------- | ----------------------------------------- |
| 2251      | [물통](#물통)                             |
| 1600      | [말이 되고픈 원숭이](#말이-되고픈-원숭이) |
| 5427      | [불](#불)                                 |

<br>

<hr>

#### 맥주 마시면서 걸어가기

[맥주 마시면서 걸어가기 소스 코드](https://www.acmicpc.net/problem/9205)🍺

예에전에 풀려다가 귀찮아서 미룬 문제였다. 그냥 편의점 좌표를 기준으로 맥주가 다 떨어지는지 확인만 하면 되는 거 아닌가? 단순하게 생각했었다. 하지만 **편의점 좌표가 순서대로 나오지 않는 경우가 있었다.** 따라서 BFS와 DFS로 풀어야 하는 문제이다. 

<br>

1. 좌표에 따른 맨해튼 거리를 저장하는 dist, 방문 여부를 확인하는 visited 함수를 정의한다. 이때, dist의 경우에는 현재 좌표와 다음 좌표를 확인할 수 있어야 하기 때문에 이차원 배열로, visited의 경우엔 현재 좌표만을 기준으로 하기 때문에 일차원 배열로 선언한다.
2. n + 2만큼 좌표를 입력 받아야 하기 때문에 Location을 선언해 x, y를 저장할 수 있도록 하였고, 이 배열을 locArr에 저장했다.
3. 좌표의 수만큼 반복문을 돌려서 각각의 경로를 맨해튼 거리 계산법으로 구한 뒤, dist 배열에 저장한다.
4. bfs 함수를 호출한다.
5. 만약 현재 좌표가 n + 1. 즉, 페스티벌에 도착한다면 true를 반환한다. (n +1인 이유는 n + 2 크기의 배열에서 가장 마지막 인덱스는 n + 1이고, 이에 해당하는 값은 페스티벌에 대한 값이기 때문이다.)
6. dist의 크기만큼 반복문을 돌려서 모든 값을 확인해 보고, 1000보다 크거나 같다면, 50m당 맥주 한 병을 마시는 지금의 조건으로는 결국 편의점 혹은 도착지에 도달하기 전에 맥주가 동나게 되므로 그 값을 제외하는 조건을 포함시킨다.
7. 만약 6번 조합에 부합하다면 다시 큐에 넣고 위의 과정을 반복한다.

<br>

<hr>

#### 물통

[물통 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.11/Solution_2251.java)

처음엔 문제 이해가 안 돼서 나중에 풀어야지 했는데 어쩌다가 다른 블로그를 구경하다 보니 대충의 힌트를 얻게 돼서 풀게 됐다.

이 문제를 풀기 위해서 필요한 2가지 조건이 있다.

1. 물의 일부만을 옮기는 것이 아니라 물 전부를 옮겨야 한다.
2. 만약 물의 용량을 넘어가면, 남은 물은 그대로 남는다. 예를 들어 물의 용량이 8, 9, 10일 때 세 번째 물통이 가득찼다면 첫 번째 물통으로 물 전체를 옮기게 되면 넘치게 된다. 그러면 8만큼 채우고 세 번째 물통에 2만큼은 남게 된다.
3. 첫 번째 물통이 비었을 때, 마지막 물통의 물 양을 구하기 위해서는 크기가 정해져있지 않은 자료구조가 필요하기 때문에 리스트를 선언한다.

<br>

또한, 물통을 옮기는 경우는 A에서 B 또는 C, B에서 A 또는 C, C에서 A 또는 B로 옮기는 6가지의 경우만 있다. 이 경우만 고려하면 된다.

처음에는 정말로 6가지의 경우를 생각했는데 또 각각의 경우에서 파생될 수 있는 것들도 다 생각해야 하기 때문에 BFS 혹은 DFS로 문제를 풀어야 한다. 나는 BFS로 문제를 풀었다.

코드는 직관적이기 때문에 위의 2가지 조건만 유념하면 쉽게 이해할 수 있다. 따라서 자세한 풀이는 생략한다.

<br>

<hr>

#### 말이 되고픈 원숭이

[말이 되고픈 원숭이](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.11/Solution_1600.java)🙉🙈🐎

귀여워서 푼 문제다. 이 문제는 [벽 부수고 이동하기](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.08/BFS%2C%20DFS.md#%EB%B2%BD-%EB%B6%80%EC%88%98%EA%B3%A0-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0)와 아주 유사한 문제다. 

문제를 읽었을 때, 어디서 많이 풀어봤던 문제인데... 하고 찾아봤다. 확실히 문제를 많이 풀어보면 이런 점에서 좋은 것 같다. 이번에도 저 문제 풀이를 보고 다시 감을 잡고 풀었다. 과거의 나 고맙다🌿

<br>

이 문제의 핵심은 단연 **원숭이가 말처럼 이동**하는 데에 있다. 벽 부수고 이동하기 문제와 달리, 이 스킬은 K번을 사용할 수 있다. 이 스킬 사용 여부를 따지기 위해 visited 배열을 3차원으로 정의한다. 차례대로 x 좌표, y 좌표, 스킬 사용 횟수를 기록한다.

그리고 무엇보다 **한 정점에 도착하는 경우가 같은 정점이라도 스킬을 사용했느냐 그렇지 않느냐에 따라 결과가 다를 수 있다.** 

즉, (X, Y)에 도달하기 위해 스킬을 0번 사용하거나 1번 사용하거나, 그 이상을 사용했을 때의 경우 모두 다를 수 있다는 의미이다. 그리고 **단순히 이동하는 것보다 스킬을 사용해서 이동하는 것이 더 빠르기 때문에 이점을 우선시해야 한다.**

<br>

1. 세로 길이가 H, 가로 길이가 W로 주어지기 때문에 H가 x의 크기, W가 y의 크기가 된다.
2. Location 객체를 선언한다. x와 y는 좌표 값을 나타내고, jump는 말처럼 이동하는 스킬 사용 횟수, depth 경로의 길이를 나타낸다.
3. x의 값이 H -1, y의 값이  W - 1이라면 끝까지 간 것이기 때문에 depth를 출력한다.  
4. 말처럼 이동하는 경우가 더 빠르기 때문에 스킬을 사용해서 이동했을 때를 먼저 갱신해 준다. 실행 전, 스킬 사용 횟수가 K보다 작은지 확인하고, jump와 depth를 하나 증가시켜 갱신해 준다.
5. 일반 이동의 경우에는 depth만 하나 증가시킨다.
6. 만약 끝까지 다다르지 못한 경우에는 -1을 출력해 준다.

<br>

<hr>

#### #불

[불 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.11/Solution_17406.java)🔥

보자마자 [탈출](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.08/BFS%2C%20DFS.md#%ED%83%88%EC%B6%9C) 문제와 비슷하다고 생각했는데, 사실상 물에서 불로 바뀐 것 말고는 모든 로직이 동일하다. 다만 탈출 문제에서는 도착지가 좌표로 주어졌는데 이번 문제에서는 가장자리 모두가 도착지가 될 수 있다.

<br>

1. map을 입력 받으면서 시작점은 경로를 저장하는 queue에, 불의 위치는 fire_queue에 저장한다.
2. min 값을 초기화 하고, bfs를 수행한다.
3. queue가 전부 빌 때까지 반복문을 수행한다. 이는 가능한 끝까지 도달할 수 있는 지점까지 탐색해 본다는 의미이다.
4. 현재 fire_queue의 크기만큼 반복문을 돌리면서 인접한 동서남북 방향에 빈 칸이나 시작점이 있는지 찾아낸다. 만약, 있다면 이를 *로 바꾸어 불이 퍼졌음을 표시한다.
5. size를 다시 현재 queue의 크기만큼 반복문을 돌리면서 빈 칸이 있는지 찾아내고, 있다면 이를 queue에 삽입한다. 또한 visited 배열에 1을 더해 경로의 길이를 더해주고 동시에 방문 여부를 표시한다.
6. 만약, 5번의 과정 중에 map의 가장자리 즉, x가 0이거나 h - 1, y가 0이거나 w - 1일 경우에 visited값과 min을 비교한다. (이는 queue에 있을 때만 거치는 과정이므로 queue에 있다는 것은 5번의 과정에서 이미 경로의 길이를 구했다는 의미랑 같으므로, 0이 되지 않을까 걱정하지 않아도 됨!)
# Programmers

| 문제 이름               | 문제 링크                                                    |
| ----------------------- | ------------------------------------------------------------ |
| [멀리 뛰기](#멀리-뛰기) | [멀리 뛰기](https://programmers.co.kr/learn/courses/30/lessons/12914) |
| [여행경로](#여행경로)⭐  | [여행경로](https://programmers.co.kr/learn/courses/30/lessons/43164?language=java) |

<br>

<hr>

#### #멀리 뛰기

[멀리 뛰기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.11/%EB%A9%80%EB%A6%AC%20%EB%9B%B0%EA%B8%B0.java)

간만에 Level3 문제에다가 DP 문제라서 바짝 긴장했는데 가만히 생각해 보니 설마 피보나치는 아니겠지...? 해서 풀었는데 너무 간단하게 맞아버렸다...😲 이런 문제는 너무 많이 풀어서 풀이는 생략!

<br>

<hr>

⭐⭐⭐⭐⭐

#### #여행경로

[여행경로 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.11/%EC%97%AC%ED%96%89%EA%B2%BD%EB%A1%9C.java)

역시 level3는 때깔부터 다르다...😥 

보자마자 DFS 문제구나 싶었는데 출발지와 도착지가 다 달라서 각각을 어떻게 방문할지가 문제였다. 

처음 생각했던 방식은 우선, ICN이 출발지인 티켓을 전부 찾고 도착지는 또다른 리스트로 묶은 뒤, 알파벳 순으로 정렬하고(이것도 comparator를 활용한다고 생각하니 더 까마득했다...) 방문 여부를 표시하면서 방문하는 방식이었다. 그래서 백트래킹이 필요하다고는 생각했는데 리스트로 묶고 묶다보면... 너무 엉망이 되고 감히 가늠조차 불가능해서 고민하다가 다른 사람 풀이를 참고했다.

나만 어려웠던 문제는 아니었는지 다른 사람들도 스스로 풀지 못했다는 사람이 많았다. 음 그런고로 나중에 꼭 다시 한 번 풀어봐야겠다.

<br>

1. 경로가 여러 개가 나올 수 있기 때문에 ArrayList를 선언한다. 그리고 방문 여부를 확인하기 위해 visited 배열을 선언한다.
2. 문제의 조건에 따라 경로의 시작은 ICN이기 때문에 tickets 배열을 탐색하여 출발지가 ICN인 티켓을 찾아서 그 티켓을 사용했다는 의미로 visited 배열을 true로 바꿔주고 경로가 시작됐기 때문에 routes에 현재 시작점을 더해준다. 그 후에 DFS를 수행한다.
3. DFS에서는 경로의 길이가 tickets의 길이와 같은지 비교한다. 모든 티켓을 다 사용해야 한다는 조건 때문에 만약, 경로가 끝났다면 티켓의 길이와 같을 것이다. 만약 같다면, list에 해당 경로인 routes를 추가해 준 뒤 반환한다.
4. tickets 길이만큼 돌면서 아직 사용하지 않았고, 현재 ticket의 도착지가 다시 시작지가 되는 티켓이 있는지 확인한다. 
5. 4번 조건에 부합한 티켓이 있다면 방문여부를 표시해 주고, 다시 DFS를 수행한다.
6. 모든 경우를 다 고려해야 하기 때문에 백트래킹을 위해 DFS 수행 후 방문 여부를 false로 초기화해준다.
7. routes 역시 해당 지점에 대한 건 빼줘야 하기 때문에 substring을 사용한다. 이때, 거치는 모든 지역의 이름은 3글자임을 주의하자.
8. 다시 2번의 메인으로 돌아가서 출발지가 ICN인 다른 경우도 생각해야 하기 때문에 백트래킹으로 다시 DFS를 수행한다.
9. 모든 경우를 다 고려했다면, 알파벳 순서대로 방문해야 한다는 문제 조건에 따라 sort 해 준 뒤, 가장 첫 번째 값을 반환해 준다.
# Programmers

| 문제 이름                                         | 문제 링크                                                    |
| ------------------------------------------------- | ------------------------------------------------------------ |
| [멀리 뛰기](#멀리-뛰기)                           | [멀리 뛰기](https://programmers.co.kr/learn/courses/30/lessons/12914) |
| [여행경로](#여행경로)⭐                            | [여행경로](https://programmers.co.kr/learn/courses/30/lessons/43164?language=java) |
| [가장 긴 팰린드롬](#가장-긴-팰린드롬)             | [가장 긴 팰린드롬](https://programmers.co.kr/learn/courses/30/lessons/12904) |
| [등굣길](#등굣길)                                 | [등굣길](https://programmers.co.kr/learn/courses/30/lessons/42898) |
| [문자열 내 p와 y의 개수](#문자열-내-p와-y의-개수) | [문자열 내 p와 y의 개수](https://programmers.co.kr/learn/courses/30/lessons/12916) |
| [점프와 순간 이동](#점프와-순간-이동)             | [점프와 순간 이동](https://programmers.co.kr/learn/courses/30/lessons/12980?language=java) |

<br>

<hr>

#### #멀리 뛰기

[멀리 뛰기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.11/%EB%A9%80%EB%A6%AC%20%EB%9B%B0%EA%B8%B0.java)

간만에 Level3 문제에다가 DP 문제라서 바짝 긴장했는데 가만히 생각해 보니 설마 피보나치는 아니겠지...? 해서 풀었는데 너무 간단하게 맞아버렸다...😲 이런 문제는 너무 많이 풀어서 풀이는 생략!

<br>

<hr>

⭐⭐⭐⭐⭐

#### #여행경로

[여행경로 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.11/%EC%97%AC%ED%96%89%EA%B2%BD%EB%A1%9C.java)

역시 level3는 때깔부터 다르다...😥 

보자마자 DFS 문제구나 싶었는데 출발지와 도착지가 다 달라서 각각을 어떻게 방문할지가 문제였다. 

처음 생각했던 방식은 우선, ICN이 출발지인 티켓을 전부 찾고 도착지는 또다른 리스트로 묶은 뒤, 알파벳 순으로 정렬하고(이것도 comparator를 활용한다고 생각하니 더 까마득했다...) 방문 여부를 표시하면서 방문하는 방식이었다. 그래서 백트래킹이 필요하다고는 생각했는데 리스트로 묶고 묶다보면... 너무 엉망이 되고 감히 가늠조차 불가능해서 고민하다가 다른 사람 풀이를 참고했다.

나만 어려웠던 문제는 아니었는지 다른 사람들도 스스로 풀지 못했다는 사람이 많았다. 음 그런고로 나중에 꼭 다시 한 번 풀어봐야겠다.

<br>

1. 경로가 여러 개가 나올 수 있기 때문에 ArrayList를 선언한다. 그리고 방문 여부를 확인하기 위해 visited 배열을 선언한다.
2. 문제의 조건에 따라 경로의 시작은 ICN이기 때문에 tickets 배열을 탐색하여 출발지가 ICN인 티켓을 찾아서 그 티켓을 사용했다는 의미로 visited 배열을 true로 바꿔주고 경로가 시작됐기 때문에 routes에 현재 시작점을 더해준다. 그 후에 DFS를 수행한다.
3. DFS에서는 경로의 길이가 tickets의 길이와 같은지 비교한다. 모든 티켓을 다 사용해야 한다는 조건 때문에 만약, 경로가 끝났다면 티켓의 길이와 같을 것이다. 만약 같다면, list에 해당 경로인 routes를 추가해 준 뒤 반환한다.
4. tickets 길이만큼 돌면서 아직 사용하지 않았고, 현재 ticket의 도착지가 다시 시작지가 되는 티켓이 있는지 확인한다. 
5. 4번 조건에 부합한 티켓이 있다면 방문여부를 표시해 주고, 다시 DFS를 수행한다.
6. 모든 경우를 다 고려해야 하기 때문에 백트래킹을 위해 DFS 수행 후 방문 여부를 false로 초기화해준다.
7. routes 역시 해당 지점에 대한 건 빼줘야 하기 때문에 substring을 사용한다. 이때, 거치는 모든 지역의 이름은 3글자임을 주의하자.
8. 다시 2번의 메인으로 돌아가서 출발지가 ICN인 다른 경우도 생각해야 하기 때문에 백트래킹으로 다시 DFS를 수행한다.
9. 모든 경우를 다 고려했다면, 알파벳 순서대로 방문해야 한다는 문제 조건에 따라 sort 해 준 뒤, 가장 첫 번째 값을 반환해 준다.

<br>

<hr>

#### #가장 긴 팰린드롬

[가장 긴 팰린드롬 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.11/%EA%B0%80%EC%9E%A5%20%EA%B8%B4%20%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC)

이번 문제는 시간 초과가 난 풀이도 같이 첨부했다. 이건 내가 처음에 풀었던 방식인데, 정확성은 만점이었으나 역시 시간초과가 나서 효율성에선 실패했다. 그래서 다른 풀이를 참고해서 효율성을 해결하긴 했지만, 아쉬움이 남아서 같이 업로드했다.

**실패한 풀이**

1. i는 처음부터 j는 i + 1부터 시작해서 s로 만들 수 있는 모든 부분 문자열을 만든다.
2. 만약 1번에서 만든 문자열의 처음과 끝이 같다면, 팰린드롬일 수도 있기 때문에 리스트에 추가한다.
3. 리스트의 사이즈가 1이상이면 짝수, 홀수를 구별해서 팰린드롬인지 확인한다.
4. 팰린드롬이 맞다면 max와 비교해서 더 큰 값을 max로 갱신한다.

<br>

**성공한 풀이**

가장 긴 팰린드롬의 길이를 구하는 것이 문제의 목적이기 때문에 가장 긴 팰린드롬이 될 수 있도록 문자열의 끝에서부터 하나씩 줄어가는 방식으로 문자열을 줄여갈 것이다. 그렇게 되면 max 값이 별도로 필요하지 않고, 반복되는 부분을 줄일 수 있기 때문에 효율적이다.

1. 문자열의 끝에서부터 시작한다. 시작점은 0부터 시작한다. 즉, 시작부터 가장 긴 부분 문자열을 만든다.
2. 팰린드롬 여부를 확인하기 위해 flag 변수를 true로 초기화한다.
3. 팰린드롬은 절반만 확인하면 되기 때문에 1번 문자열 길이의 절반만큼 반복문을 돌려 문자열 시작 부분과 끝 부분을 점차 비교해 나간다. 만약 다른 문자가 나오면 팰린드롬이 아니기 때문에 flag를 false로 갱신하고 break로 빠져나온다.
4. flag를 확인하고 true 값이라면 그 값이 바로 가장 긴 팰린드롬의 길이이기 때문에 이를 반환한다.

<br>

<hr>

#### #등굣길

[등굣길 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.11/%EB%93%B1%EA%B5%A3%EA%B8%B8.java)

진짜 오랜만에 푸는 알고리즘 문제. 일이 바빠서 조금 뜸해졌다.💦

DP 문제고, 무슨 문제인지는 기억이 잘 안 나지만 비슷한 문제를 푼 기억이 있다. 다만, 이번 문제는 물 웅덩이도 고려해야 한다.

처음에는 최단 경로라길래 Math.min을 사용해서 구하려고 했는데 자세히 보니 최단 경로의 개수였다. 즉, 왼쪽 방향과 아래쪽 방향에서 오는 경로의 수를 전부 더해주면 되는 문제이다.

1. 경로의 수가 많을 수 있기 때문에 long으로 선언한다.
2. 물 웅덩이는 -1로 표시한다. 이때 이차원 배열로 표현되어 있기 때문에 for문을 사용해서 각각의 좌표를 얻는다. 여기서 주의해야 할 점은 다른 문제와 달리 x좌표와 y좌표가 반대로 되어 있다. 즉, 행렬이 아니라 열행이기 때문에 좌표값을 바꿔줘야 한다.
3. 위쪽에 위치한 값들은 전부 최소 경로는 왼쪽에서 오는 방향 (항상 오른쪽으로 전진하기 때문)만 고려하면 되기 때문에 1이다.
4. 마찬가지로, 왼쪽에 위치한 값들 전부 위에서 오는 방향만 고려하면 되기 때문에 1이다.
5. x와 y가 1일 때는 전부 고려했으므로 2부터 각각의 길이까지 중첩 반복문을 돌면서 가운데에 있는 경로의 개수를 구해야 한다.
6. 만약, 현재 값이 물 웅덩이 즉, -1일 경우 이동할 수 없기 때문에 다음 순서로 넘어간다.
7. 만약 왼쪽, 위쪽에서 오는 값이 전부 -1이 아닐 경우 둘의 값을 더해준다.
8. 만약 왼쪽 혹은 위쪽 값이 물 웅덩이라면 다른 값을 가지고 온다.
9. 이때 map에 저장할 값은 1000000007을 나눈 나머지를 저장해서 수의 범위를 넘어가지 않게 주의한다.

<br>

<hr>

#### #징검다리 건너기

[징검다리 건너기](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.11/%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%20%EA%B1%B4%EB%84%88%EA%B8%B0)

예전에 풀었던 문제랑 비슷해서 가볍게 풀겠거니 했는데 효율성에서 다 틀렸다😢

일단 정확성은 만점이어서 깃헙에는 정답 코드와 같이 올리긴 했다. 효율성은 알고리즘 자체를 바꿔야 풀리는 경우가 많아서 고민하다가 카카오 기술 블로그에서 해설을 보고, 다른 사람 풀이를 참고했다.

처음에 풀었던 방식

1. 징검다리를 건널 수 없는 친구가 나올 때까지 계속 확인해 봐야 하기 때문에 무한 루프를 돈다.
2. 징검다리를 밟는 과정을 확인해야 하기 때문에 stones의 길이만큼 for문을 돈다.
3. 만약, 내구도가 0이 아니라면 밟을 수 있기 때문에 내구도를 1만큼 감소시키고, 건너뛸 수 있는 돌의 수인 cnt를 0으로 초기화 시킨다.
4. 내구도가 0이라면 해당 돌은 건너뛰어야 하기 때문에 cnt를 증가 시킨다.
5. 만약 cnt가 k 이상이라면 건너뛸 수 없기 때문에 flag 변수를 false로 한 뒤, 2번의 반복문에서 빠져나온다.
6. flag가 true라면 answer를 증가시키고, 아니라면 1번의 무한 루프에서 벗어난 뒤, answer를 출력한다.

<br>

![image](https://user-images.githubusercontent.com/62419307/100108567-4282fd00-2eae-11eb-8e02-0a74b2653290.png)

[출처 : 카카오 기술 블로그](https://tech.kakao.com/2020/04/01/2019-internship-test/)

<br>

1. 최솟값과 최댓값으로 중간값을 구해 탐색해야 하기 때문에 최솟값과 최댓값을 구한 후, 이진 탐색 함수를 호출한다.
2. 중간값을 구한 후, 그 중간값을 가지고 다리를 건널 수 있는지 판단하기 위해 isPossible을 호출한다.
3. M을 구하기 위해 중간값을 친구들이라고 생각해서 그만큼 다리의 내구도를 감소시킨다. 
4. 다리의 내구도가 1 이상인 다리를 만나면 cnt를 0으로 초기화한다.
5. 그리고 만약, 0인 징검다리가 k개 이상보다 연속해서 존재한다면 다리를 건널 수 없기 때문에 false를 반환한다.
6. 다시 binarySearch로 들어와서 true이면 친구들의 수를 더 늘려도 되기 때문에 l을 mid + 1로 옮겨준다.
7. false라면 친구들의 수를 줄여야 하기 때문에 r을 mid로 바꾼다.

<br>

<hr>

#### #문자열 내 p와 y의 개수

[문자열 내 p와 y의 개수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.11/%EB%AC%B8%EC%9E%90%EC%97%B4%20%EB%82%B4%20p%EC%99%80%20y%EC%9D%98%20%EA%B0%9C%EC%88%98)

조금 부끄럽지만... 레벨1의 문제다. 알바 다닌다는 핑계로 요즘 너무 공부를 안 한다...😢 더 힘내자.

이 문제는 1학년도 풀 만한 문제이지만 ver2의 다른 사람 풀이가 좋아서 올려두었다. 각각의 변수가 필요한지, 아니면 하나의 변수로 해결이 가능한지 좀 더 생각해 볼 만한 문제였다. 쉬운 난이도일 수록 사람들마다 방식이 달라서 새로 배우는 재미가 쏠쏠하다. 풀이는 생략!

<br>

<hr>

#### #점프와 순간 이동

[점프와 순간 이동 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.11/%EC%A0%90%ED%94%84%EC%99%80%20%EC%88%9C%EA%B0%84%20%EC%9D%B4%EB%8F%99.java)

1칸을 이동하거나 0칸을 이동할 수 있다는 건 이진법을 의미하기 때문에 주어지는 수를 이진수로 변환한 뒤, 1의 개수를 세면 된다.
# Programmers

| 문제 이름                             | 문제 링크                                                    |
| ------------------------------------- | ------------------------------------------------------------ |
| [멀리 뛰기](#멀리-뛰기)               | [멀리 뛰기](https://programmers.co.kr/learn/courses/30/lessons/12914) |
| [여행경로](#여행경로)⭐                | [여행경로](https://programmers.co.kr/learn/courses/30/lessons/43164?language=java) |
| [가장 긴 팰린드롬](#가장-긴-팰린드롬) | [가장 긴 팰린드롬](https://programmers.co.kr/learn/courses/30/lessons/12904) |

<br>

<hr>

#### #멀리 뛰기

[멀리 뛰기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.11/%EB%A9%80%EB%A6%AC%20%EB%9B%B0%EA%B8%B0.java)

간만에 Level3 문제에다가 DP 문제라서 바짝 긴장했는데 가만히 생각해 보니 설마 피보나치는 아니겠지...? 해서 풀었는데 너무 간단하게 맞아버렸다...😲 이런 문제는 너무 많이 풀어서 풀이는 생략!

<br>

<hr>

⭐⭐⭐⭐⭐

#### #여행경로

[여행경로 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.11/%EC%97%AC%ED%96%89%EA%B2%BD%EB%A1%9C.java)

역시 level3는 때깔부터 다르다...😥 

보자마자 DFS 문제구나 싶었는데 출발지와 도착지가 다 달라서 각각을 어떻게 방문할지가 문제였다. 

처음 생각했던 방식은 우선, ICN이 출발지인 티켓을 전부 찾고 도착지는 또다른 리스트로 묶은 뒤, 알파벳 순으로 정렬하고(이것도 comparator를 활용한다고 생각하니 더 까마득했다...) 방문 여부를 표시하면서 방문하는 방식이었다. 그래서 백트래킹이 필요하다고는 생각했는데 리스트로 묶고 묶다보면... 너무 엉망이 되고 감히 가늠조차 불가능해서 고민하다가 다른 사람 풀이를 참고했다.

나만 어려웠던 문제는 아니었는지 다른 사람들도 스스로 풀지 못했다는 사람이 많았다. 음 그런고로 나중에 꼭 다시 한 번 풀어봐야겠다.

<br>

1. 경로가 여러 개가 나올 수 있기 때문에 ArrayList를 선언한다. 그리고 방문 여부를 확인하기 위해 visited 배열을 선언한다.
2. 문제의 조건에 따라 경로의 시작은 ICN이기 때문에 tickets 배열을 탐색하여 출발지가 ICN인 티켓을 찾아서 그 티켓을 사용했다는 의미로 visited 배열을 true로 바꿔주고 경로가 시작됐기 때문에 routes에 현재 시작점을 더해준다. 그 후에 DFS를 수행한다.
3. DFS에서는 경로의 길이가 tickets의 길이와 같은지 비교한다. 모든 티켓을 다 사용해야 한다는 조건 때문에 만약, 경로가 끝났다면 티켓의 길이와 같을 것이다. 만약 같다면, list에 해당 경로인 routes를 추가해 준 뒤 반환한다.
4. tickets 길이만큼 돌면서 아직 사용하지 않았고, 현재 ticket의 도착지가 다시 시작지가 되는 티켓이 있는지 확인한다. 
5. 4번 조건에 부합한 티켓이 있다면 방문여부를 표시해 주고, 다시 DFS를 수행한다.
6. 모든 경우를 다 고려해야 하기 때문에 백트래킹을 위해 DFS 수행 후 방문 여부를 false로 초기화해준다.
7. routes 역시 해당 지점에 대한 건 빼줘야 하기 때문에 substring을 사용한다. 이때, 거치는 모든 지역의 이름은 3글자임을 주의하자.
8. 다시 2번의 메인으로 돌아가서 출발지가 ICN인 다른 경우도 생각해야 하기 때문에 백트래킹으로 다시 DFS를 수행한다.
9. 모든 경우를 다 고려했다면, 알파벳 순서대로 방문해야 한다는 문제 조건에 따라 sort 해 준 뒤, 가장 첫 번째 값을 반환해 준다.

<br>

<hr>

#### #가장 긴 팰린드롬

[가장 긴 팰린드롬 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.11/%EA%B0%80%EC%9E%A5%20%EA%B8%B4%20%ED%8C%B0%EB%A6%B0%EB%93%9C%EB%A1%AC)

이번 문제는 시간 초과가 난 풀이도 같이 첨부했다. 이건 내가 처음에 풀었던 방식인데, 정확성은 만점이었으나 역시 시간초과가 나서 효율성에선 실패했다. 그래서 다른 풀이를 참고해서 효율성을 해결하긴 했지만, 아쉬움이 남아서 같이 업로드했다.

**실패한 풀이**

1. i는 처음부터 j는 i + 1부터 시작해서 s로 만들 수 있는 모든 부분 문자열을 만든다.
2. 만약 1번에서 만든 문자열의 처음과 끝이 같다면, 팰린드롬일 수도 있기 때문에 리스트에 추가한다.
3. 리스트의 사이즈가 1이상이면 짝수, 홀수를 구별해서 팰린드롬인지 확인한다.
4. 팰린드롬이 맞다면 max와 비교해서 더 큰 값을 max로 갱신한다.

<br>

**성공한 풀이**

가장 긴 팰린드롬의 길이를 구하는 것이 문제의 목적이기 때문에 가장 긴 팰린드롬이 될 수 있도록 문자열의 끝에서부터 하나씩 줄어가는 방식으로 문자열을 줄여갈 것이다. 그렇게 되면 max 값이 별도로 필요하지 않고, 반복되는 부분을 줄일 수 있기 때문에 효율적이다.

1. 문자열의 끝에서부터 시작한다. 시작점은 0부터 시작한다. 즉, 시작부터 가장 긴 부분 문자열을 만든다.
2. 팰린드롬 여부를 확인하기 위해 flag 변수를 true로 초기화한다.
3. 팰린드롬은 절반만 확인하면 되기 때문에 1번 문자열 길이의 절반만큼 반복문을 돌려 문자열 시작 부분과 끝 부분을 점차 비교해 나간다. 만약 다른 문자가 나오면 팰린드롬이 아니기 때문에 flag를 false로 갱신하고 break로 빠져나온다.
4. flag를 확인하고 true 값이라면 그 값이 바로 가장 긴 팰린드롬의 길이이기 때문에 이를 반환한다.
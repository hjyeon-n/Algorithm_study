# Implementation

| 문제 번호                                      | 이름                             |
| ---------------------------------------------- | -------------------------------- |
| [17406](https://www.acmicpc.net/problem/17406) | [배열 돌리기 4](#배열-돌리기-4)⭐ |
| [16926](https://www.acmicpc.net/problem/16926) | [배열 돌리기 1](#배열-돌리기-1)  |
| [2607](https://www.acmicpc.net/problem/2607)   | [비슷한 단어](#비슷한-단어)      |

<br>

<hr>

⭐⭐⭐⭐⭐


#### 배열 돌리기 4

[배열 돌리기 4 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.11/Solution_17406.java)

삼성 A형 기출문제이다. 모르고 풀었는데 코테에서 많이 나오는 유형이라고 하니 잘 알아두자!

생각보다 배열 돌리는 문제는 조금 까다로운 것 같다... [미세먼지 안녕!](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.10/Implementation.md#%EB%AF%B8%EC%84%B8%EB%A8%BC%EC%A7%80-%EC%95%88%EB%85%95)에서도 헤맸는데 이번에도 조금 헷갈렸다.😢

이 문제가 까다로운 이유가 있다.

1. 회전 연산의 모든 경우를 **순열로 구해서 확인해야 한다.**
2. 겉에 있는 배열 뿐만 아니라 내부에 있는 배열도 함께 돌려야 한다.
3. 2번을 해결하기 위해 중단 조건을 잘 정해야 한다.

<br>

그리고 내가 제대로 지키지 않아서 헤맸던 부분도 있다.

1. 회전 연산 하나가 완료되면 다음 회전 연산을 수행하기 전, **배열을 원본으로 돌려야 한다.**
2. 회전 연산 하나가 끝났다고 해서 최솟값을 구하는 것이 아니라 순열 결과값에 따른 모든 회전 연산을 수행한 후, 최솟값을 구해야 한다.

특히 난 2번 때문에 오랜 시간동안 헤맸다.

<br>

이제 문제 풀이다! 😋

1. 원본 배열은 항상 기억하고 있어야 하기 때문에 원본 배열만을 저장하는 copyA를 정의하고, 초기화한다.
2. 회전 연산은 K개이기 때문에 이것들을 별도로 저장하는 객체를 생성하고 배열에 각각의 값을 저장한다.
3. 나올 수 있는 모든 경우의 수를 고려하기 위해 백트래킹을 이용해 순열의 값을 구한다.
4. dfs 함수에서 base condition을 만났을 때, 즉, 뽑고자 하는 수만큼 수를 다 뽑았을 때, 이에 해당하는 값은 인덱스에 해당하므로 이를 이용해 2번에 생성해둔 배열에서 값을 꺼내 rotate 함수를 호출한다.
5. rotate 함수에서는 시계방향으로 배열을 회전시키고, 항상 정사각형을 만들어 회전을 시켜야 하므로 처음에 주어진 시작점과 끝점을 각각 대각선 방향으로 늘리거나 줄여 같은 값에 도달한다면 모든 배열을 처리한 것이므로 하나의 회전 수행을 완료한 것이다.
6. 4번의 한 가지 경우에 대해서 모든 회전 연산을 수행한 뒤, getMin 함수를 호출해 최솟값을 찾아낸다.

<br>

<hr>

#### 배열 돌리기 1

[배열 돌리기 1 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.11/Solution_16926.java)

[배열 돌리기 4](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.11/Implementation.md#%EB%B0%B0%EC%97%B4-%EB%8F%8C%EB%A6%AC%EA%B8%B0-4)와 달리 반시계 방향으로 돌려야 한다. 그리고 순열 등 부차적인 것은 없고 오로지 배열 회전만 신경 쓰면 된다.

생각보다 시간이 오래 걸렸는데, 반시계라서 조금 더 헷갈렸고 또한 **내부 배열도 회전시켜줘야 했기 때문이다.**

내부 배열은 크기가 어느정도 나올지 예상할 수 없기 때문에 N과 M 중 크기가 작은 것을 기준으로 2로 나눠 그 값만큼만 내부 배열이 나온다는 것을 유념하고 해결하면 된다. 다른 부분은 주석처리했기 때문에 풀이는 생략!

<br>

<hr>

#### 비슷한 단어

[비슷한 단어 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.11/Solution_2607.java)

간단하게 단어들의 문자들이 같은 경우를 구하라고 했으면 실버5나 브론즈로 내려갔을 것 같은데 이 문제는 **한 단어에서 한 문자를 더하거나, 빼거나, 하나의 문자를 다른 문자로 바꾸어 나머지 한 단어와 같은 구성을 갖게 되는 경우**를 구해야 한다.

나는 첫 번째 단어를 기준으로 **해시 자료구조를 활용해 어떤 문자가 있는지, 또한 그 개수가 몇 개인지 저장하는 방법**을 사용했다.

1. num을 입력 받고, num 만큼 문자열이 등장하기 때문에 num만큼의 String 배열 arr을 선언한다.
2. 해시 자료구조를 활용해 해당하는 문자를 찾고, 개수를 변경할 것이기 때문에 원본 해시를 저장할 필요성이 있다. 그래서 copy 해시맵을 선언해 원본을 저장해 둔다.
3. 배열의 1번 인덱스부터 나머지 인덱스에 해당하는 문자열을 전부 비교해야 하기 때문에 반복문을 활용한다.
4. 3번의 반복문 안에서 각각에 해당하는 문자열의 길이만큼 반복문을 돌며 해시와 비교해야 한다. 이때, 기준이 되는 첫 번째 문자열 (여기서는 str)과 2개 이상의 차이가 날 수 있기 때문에 diff라는 int형 변수를 선언한다. 그리고 str과 문자열의 길이가 2이상이 날 경우, 비슷한 단어가 될 조건을 벗어나기 때문에 이를 먼저 제외한다.
5. str에 등장하지 않는 문자열이 현재 문자열에서는 등장할 수 있기 때문에 문자열의 길이만큼 visited 배열을 선언해 방문 여부를 확인한다.
6. 문자가 해시맵 안에 존재하면 그 값을 가져와 0 이상인지 확인한다. 만약, 0이상이면 그 값에서 1을 빼서 갱신해 주고, 0 이하라면 문자 개수에서 차이가 난다는 의미이기 때문에 diff를 하나 증가시킨다.
7. 만약 문자가 해시맵 안에 존재하지도 않는다면, diff를 증가시킨다.
8. 6, 7번 모두 해당하는 문자에 대해서 방문 여부를 표시해 준다.
9. 해시맵을 전부 확인한 뒤, 방문하지 않는 문자가 있는지 확인하고 만약 있다면 해당하는 개수만큼 diff를 증가시킨다.
10. 또한, str의 길이가 더 길 경우 현재 문자열의 길이만큼 빼서 diff에 더해준다.
11. diff가 1 이하이면 비슷한 단어이기 때문에 cnt를 증가시킨다.
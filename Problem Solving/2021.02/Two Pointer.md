# Two Pointer

| 문제 번호                                    | 이름                                         |
| -------------------------------------------- | -------------------------------------------- |
| [2003](https://www.acmicpc.net/problem/2003) | [수들의 합 2](#수들의-합-2)                  |
| [2470](https://www.acmicpc.net/problem/2470) | [두 용액](#두-용액)                          |
| [2467](https://www.acmicpc.net/problem/2467) | [용액](https://www.acmicpc.net/problem/2467) |
| [3273](https://www.acmicpc.net/problem/3273) | [두 수의 합](#두-수의-합)                    |

<br>

<hr>

#### #수들의 합 2

[수들의 합 2 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.02/Solution_2003.java)

프로그래머스의 [보석 쇼핑](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2021.02/Programmers.md#%EB%B3%B4%EC%84%9D-%EC%87%BC%ED%95%91)을 풀기 위해서 비슷하지만 더 쉬운 문제인 이 문제를 풀었다.

투 포인터는 시작점과 끝점을 의미하는 포인터들이 오른쪽으로 이동해 나가면서 원하는 답을 얻을 수 있는 알고리즘이다.  즉, 일종의 범위를 지정하는 방식이다.

흡사 이분탐색처럼 진행한다.

1. 수들의 합이 얻고자 하는 값 M보다 크거나 같다면 시작점의 포인터인 s가 오른쪽으로 이동해야 한다. 그리고 해당 값을 합에서 빼준다.
2. 만약 e가 끝까지 다다랐다면 break한다. (이 조건이 두 번째에 온 이유는 첫 번째에 오게 되면 마지막 수를 확인하지 못하기 때문이다.)
3. sum이 M보다 작다면 e를 오른쪽으로 이동시켜 범위를 넓혀준다.

이 순서로 진행이 되며 만약 sum이 M과 같다면 cnt를 증가시켜 답을 구한다.

<br>

<hr>

#### #두 용액

[두 용액 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.02/Solution_2470.java)

투 포인터 문제 유형이지만 이분탐색으로 풀었다.

서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어야 하는데 그냥 완전탐색으로 풀면 시간초과가 난다. 따라서 이분탐색의 방법으로 문제를 풀었다.

1. 이분탐색을 위해 배열을 오름차순으로 정렬해준다.
2. 정답이 될 시작점과 끝점을 각각 rslt_start, rslt_end로 정의한다.
3. 배열의 길이만큼 해당 원소에 대해 특성값이 0이거나 그에 가장 근접한 값이 나올 만한 수를 탐색한다.
4. start를 0으로, end를 N - 1 즉, 배열의 끝에 둔다. 그리고 부호가 반대면 특성값 0이 되고 그 값이 바로 답이기 때문에 val이라고 따로 두어 해당 원소의 반대 부호를 가진 수를 정의한다.
5. start가 end보다 작거나 같을 때까지 이분 탐색한다.
6. arr[mid]가 val이라면 특성값이 바로 0이기 때문에 break해서 반복문을 빠져나간다.
7. 그렇지 않으면 mid 값을 바꿔나가면서 특성값을 0과 가장 근접하게 만들만한 범위를 찾는다.
8. 반복문을 빠져나와서 만약 start가 N - 1 보다 크다면 끝까지 다다른 거고 마찬가지로 end가 0보다 작을 경우에는 범위를 넘어선 것이기 때문에 보정해준다.
9. start가 end보다 크면 start와 end를 서로 바꿔준다.
10. start와 end 사이의 범위가 생기게 되고 이 범위들의 수 중에서 특성값을 0과 가깝게 만들 만한 수가 있기 때문에 완전 탐색 방법으로 수를 찾는다. 이때 범위는 줄어들었기 때문에 시간초과는 나지 않는다.
11. 그리고 그 값이 min보다 작다면 그 값이 특성값을 0에 가장 가깝게 만드는 수 즉, 답이기 때문에 오름차순으로 정렬해서 이를 출력한다.

<br>

<hr>

#### #용액

[용액 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.02/Solution_2467.java)

두 용액과 같은 문제이다. 풀이는 생략!

<br>

<hr>

#### #두 수의 합

[두 수의 합 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.02/Solution_3273.java)

제일 처음 풀어 본 투 포인터 문제라고 기억한다. 처음엔 완전 탐색으로 시도했다가 당연히 시간초과 맞고 투 포인터가 어떤 거고 어떻게 동작하는지 검색하고 풀었던 문제다. 

정렬을 한 뒤에 시작점을 start, 끝점을 end라고 두고 start가 end보다 작으면 while 반복문을 돌 수 있도록 했다.

1. sum이랑 x가 같다면 문제에서 요구하는 정수 쌍이기 때문에 cnt를 늘려준다.
2. sum이 x보다 작거나 같다면 start를 오른쪽으로 이동시킨다.
3. sum이 x보다 크다면 end를 왼쪽으로 이동시킨다.
# Programmers

| 문제 이름                                                 | 문제 링크                                                    |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| [N개의 최소공배수](#N개의-최소공배수)                     | [N개의 최소공배수](https://programmers.co.kr/learn/courses/30/lessons/12953) |
| [더 맵게](#더-맵게)                                       | [더 맵게](https://programmers.co.kr/learn/courses/30/lessons/42626) |
| [디스크 컨트롤러](#디스크-컨트롤러)                       | [디스크 컨트롤러](https://programmers.co.kr/learn/courses/30/lessons/42627) |
| [메뉴 리뉴얼](#메뉴-리뉴얼)                               | [메뉴 리뉴얼](https://programmers.co.kr/learn/courses/30/lessons/72411) |
| [방문 길이](#방문-길이)                                   | [방문 길이](https://programmers.co.kr/learn/courses/30/lessons/49994) |
| [보석 쇼핑](#보석-쇼핑)                                   | [보석 쇼핑](https://programmers.co.kr/learn/courses/30/lessons/67258) |
| [숫자의 표현](#숫자의-표현)                               | [숫자의 표현](https://programmers.co.kr/learn/courses/30/lessons/12924) |
| [신규 아이디 추천](#신규-아이디-추천)                     | [신규 아이디 추천](https://programmers.co.kr/learn/courses/30/lessons/72410) |
| [이중 우선순위 큐](#이중-우선순위-큐)                     | [이중 우선순위 큐](https://programmers.co.kr/learn/courses/30/lessons/42628) |
| [이진 변환 반복하기](#이진-변환-반복하기)                 | [이진 변환 반복하기](https://programmers.co.kr/learn/courses/30/lessons/70129) |
| [정수 내림차순으로 배치하기](#정수-내림차순으로-배치하기) | [정수 내림차순으로 배치하기](https://programmers.co.kr/learn/courses/30/lessons/12933) |
| [정수 제곱근 판별](#정수-제곱근-판별)                     | [정수 제곱근 판별](https://programmers.co.kr/learn/courses/30/lessons/12934) |
| [행렬의 덧셈](#행렬의-덧셈)                               | [행렬의 덧셈](https://programmers.co.kr/learn/courses/30/lessons/12950) |

<br>

<hr>

#### #N개의 최소공배수

[N개의 최소공배수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/N%EA%B0%9C%EC%9D%98%20%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98.java)

한참동안 문제 풀이를 귀찮아서 미뤘더니 지난 7월과 모양이 비슷해졌다... 와르르 쓰는 모양새가 말이다.

똑같은 내가 풀었는데 시간이 조금만 지나도 너무 생경해진다... 이건 또 어떻게 풀었더라. 😫

<br>

최소공배수를 어떻게 구하는지 생각해서 코드로 나타내면 되는데 최소공배수는 모든 수가 한꺼번에 나누어지는 수가 나올 때만 나누는 게 아니라 어떤 수이더라도 나누어 떨어지는 수가 있다면 그 수로 나눠야 한다. 이 과정을 newArr라는 새로운 int형 배열로 표현하였다.

1. n으로 나눠서 어떤 수가 나누어 떨어지는 즉, 공배수를 구할 때 n은 2 이상이어야 하는데 그 수가 계속 증가하는 게 아니라 다시 2가 될 수도 더 큰 수가 될 수도 있기 때문에 제일 큰 루프문으로 무한 반복문을 묶는다.
2. 공배수가 나누려는 값보다 커지진 않기 때문에 배열을 오름차순으로 정렬하고 그 마지막 값을 max 값으로 잡는다.
3. n이 max보다 크거나 같을 때까지 반복하는 루프문을 만든다.
4. 3번의 반복문에서 arr의 크기만큼 돌면서 n으로 나눠지는 수가 있는지 검사한다. 이때 만약 나누어지는 수가 있다면 flag 값을 true로 둔다. 나누어지든 그렇지 않든 newArr 값에 나눈 값, 아니면 그대로의 값을 넣는다.
5. 만약 4번에서 나온 flag 값이 true이면 최소공배수인 answer 값에 n만큼 곱해주고 3번의 반복문을 빠져나온다. 그렇지 않다면 다시 n을 늘려서 나누어 떨어지는 수가 있는지 체크한다.
6. status 값을 false로 둬서 arr 값이 모두 1인지 확인한다. 만약 하나라도 1이 아니라면 아직 최소공배수는 나오지 않은 것이기 때문에 1번의 반복문으로 돌아간다. 그렇지 않다면, 반복문을 빠져나와 answer를 반환한다.

<br>

<hr>

#### #더 맵게

[더 맵게 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EB%8D%94%20%EB%A7%B5%EA%B2%8C.java) 🌶

프로그래머스에서 처음 푸는 우선순위 큐 문제. 쉽게 풀었다.

여러가지 자료구조를 배우면서 문제를 풀 수 있는 방법의 폭이 넓어진다는 걸 배운다 오호~

가장 맵지 않은 것과 두 번째로 맵지 않은 것을 구하기 위해서는 작은 수가 우선순위가 더 높아서 먼저 나올 수 있도록 우선순위 큐를 사용한다.

1. 우선순위 큐를 선언하고 배열의 수를 차례대로 입력한다.
2. 큐의 사이즈가 1보다 커야 문제를 진행할 수 있고, front 값이 K 이상이라면 문제의 조건에 이미 부합하기 때문에 이 조건들을 확인한다.
3. 만약 큐의 사이즈가 1보다 작거나 같다면 스코빌 지수를 K 이상으로 만들 수 없기 때문에 (K 이상이라면 2번의 조건에서 걸러진다.) -1을 반환하고 끝낸다.
4. 큐에서 값 2개를 뽑아 문제의 조건대로 가장 맵지 않은 음식과 두 번째로 맵지 않은 음식에 2를 곱해 더한 값을 다시 큐에 넣어준다.
5. 이때 최소 횟수를 구해야 하기 때문에 반복문이 반복될 때마다 answer 값을 늘려준다.

<br>

<hr>
#### #디스크 컨트롤러

[디스크 컨트롤러 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EB%94%94%EC%8A%A4%ED%81%AC%20%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC.java)

진짜 오랜 시간동안 고민했다. 수행시간이 빠른 것부터 정렬하자. 아니다 시작점이 빠른 것부터 정렬하자. 이런저런 생각 때문에 문제 풀다가도 다시 풀고 다시 풀고.. 이래서 머리 터지기 직전이라 다른 사람 풀이를 참고했다... 😭 (눈물 한바가지)

1. 작업 처리 시점을 오름차순으로 정렬하는 우선순위 큐를 선언한다.
2. 시작 시간을 기준으로 배열을 오름차순으로 정렬한다.
3. 시작할 수 있는 작업이 있다면 모두 큐에 넣는다.
4. 만약 큐가 비어있다면 현재 시간은 배열이 가리키는 시작 시점이다.
5. 큐가 비어있지 않다면 큐에서 값을 빼서 작업시간만큼 answer에 더해주고, 소요시간만큼 time을 더해서 현재 시간을 바꿔준다.
6. answer의 평균값을 구해 반환한다.

<br>

<hr>

#### #메뉴 리뉴얼

[메뉴 리뉴얼 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EB%A9%94%EB%89%B4%20%EB%A6%AC%EB%89%B4%EC%96%BC.java)

카카오 2021 공채 문제이다. 하반기 첫 코딩테스트이기도 했는데 그땐 시간초과로 이 문제를 못 풀었더랬다...

아쉬움이 남은 문제였는데 이번에는 한방에 풀었다. 뭐지.. 테스트케이스가 달라졌을까. 이전 코드가 기억나지 않아서 무슨 차이가 있는지 모르겠다...

1. 메뉴에 나오는 알파벳들을 가지고 조합을 구하기 위해, 등장하는 알파벳을 선별해야 한다. 이를 위해 Set 자료구조를 사용해서 orders 배열을 순회하면서 한 번 이상 등장한 알파벳을 선별한다.
2. set을 배열로 바꾸기 위해서 tmp라는 ArrayList를 선언하고 이를 다시 배열로 바꿔준다. 알파벳을 오름차순으로 정렬해야 하기 때문에 배열을 sort해준다.
3. course 배열 원소만큼 메뉴를 구상해야 하기 때문에 2번에서 구한 arr에서 그 수만큼 뽑아내는 조합의 과정을 거쳐야 한다. 이를 course의 길이만큼 반복문을 돌린다. 조합은 백트래킹으로 진행한다.
4. 만약 course에 해당하는 원소만큼 뽑았을 때, 결과 문자들이 orders에 포함되는지 확인한다. 이때 문자들이 각각 흩어진 경우가 있기 때문에, (예를 들어 ACE와 ADE에서 AE라는 메뉴를 뽑아낼 수 있지만 AE라는 문자열은 어디에도 포함되지 않는다.) 문자 각각이 포함되는지 확인해야 한다.
5. 만약 포함이 된다면, cnt를 늘려준다.
6. cnt가 max 값보다 크고 cnt가 2보다 크다면 이전에 기록했던 메뉴 리스트는 사라지고 새로운 메뉴 리스트가 나오게 된다. 따라서 list를 새로 정의하고 문자들을 문자열로 만들어 list에 add한다.
7. 만약 cnt가 2보다 크고 max와 같다면 기존의 메뉴 리스트에 또 추가되는 경우이다. 따라서, 똑같이 문자열로 만들어 list에 추가한다.
8. 다시 메인으로 돌아와서 오름차순으로 정렬해 준 뒤, 반환한다.

<br>

좀 복잡하게 푼 것 같기도 하다... 다른 사람 풀이를 참고해서 더 좋은 풀이가 없는지 고민해 봐야겠다.😎

<br>

<hr>
#### #방문 길이

[방문 길이 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EB%B0%A9%EB%AC%B8%20%EA%B8%B8%EC%9D%B4.java)

이 문제의 핵심은 한 영역이 아니라 선분 즉, '길이'의 방문 여부를 체크해야 한다는 것이다. 또한 방문했다면 그 명령은 무시되어야 한다.
이 점을 제외하고는 까다로운 문제는 아니었다.

AB든 BA든 결국 같은 선을 의미하기 때문에 어떤 한 좌표에서 다른 인접한 좌표까지 가는 선의 모양을 나타내기 위해 str1과 str2로 나누었다. String 자료형의 ArrayList를 선언해 str1과 str2가 포함된다면 이미 방문한 선이고 그렇지 않다면 list에 add해서 방문 여부를 표시하는 방식으로 문제를 풀었다. 

<br>

<hr>

#### #보석 쇼핑

[보석 쇼핑 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EB%B3%B4%EC%84%9D%20%EC%87%BC%ED%95%91.java) 💎

어려운 문제를 풀어야겠다고 다짐해서 이 문제를 풀었는데 사실상 어려운 문제는 아니었다.

투 포인터 유형의 문제인데 아직 낯선 알고리즘이라 백준에서 기초 문제를 푼 뒤에 풀었다. 그리고 기초 문제랑 크게 난이도가 다르지 않았다. 아마 투 포인터라는 개념 때문에 난이도가 높게 설정된 게 아닐까...? 라는 생각 중... 🙄

1. 모든 종류의 보석을 적어도 하나 이상은 포함해야 하기 때문에 보석의 종류부터 알아야 한다. 따라서 Set 자료구조를 사용해서 보석의 종류를 알아낸다. 그리고 size라는 변수를 선언해 보석의 종류의 수를 저장한다. 최소 범위를 구하기 위해 min이라는 비교 변수 또한 정의해야 한다.
2. 짧은 구간은 여러 번 나올 수 있기 때문에 ArrayList를 선언해 시작점과 끝점을 기록한다. 또한 모든 종류의 보석이 포함됐는지 확인하기 위해 HashMap 자료구조를 사용한다. 시작점은 s, 끝점은 e로 표현하며 둘 다 0으로 초기화한다.
3. map의 사이즈가 size보다 클 때, 처음과 끝에 위치한 포인터 중, 시작점에 있는 포인터가 왼쪽으로 이동해야 한다. 즉, 보석이 그만큼 줄어들어야 하기 때문에 해당하는 보석의 수를 하나 줄인다. 만약, 그 개수가 하나밖에 없었다면 map에서 아예 삭제해 준다.
4. 만약, e가 끝까지 다다랐다면 break해서 빠져나와야 한다. 이때 이 조건이 두 번째에 위치한 이유는 끝점까지 전부 살펴 봐야 하는데 이 조건이 처음에 위치한다면 s가 변경되지 않은 채로 break돼서 답이 달라질 수 있기 때문이다. 세 번째 조건은 e를 오른쪽으로 이동시키기 때문에 범위를 벗어날 수 있기 때문에 두 번째 조건에 해당한다.
5. 끝점인 e를 오른쪽으로 한 칸 이동하게 하고, 즉 범위가 늘어난다는 의미이기 때문에 map에 해당하는 보석의 수를 1만큼 늘려준다. 만약 원래 존재하지 않은 보석이라면 새로 map에 추가해준다.
6. size와 map의 사이즈가 똑같다면 모든 보석을 적어도 하나 이상 포함하고 있다는 의미이기 때문에 답의 조건에 해당한다. 하지만 가장 짧은 길이라는 조건 때문에 범위와 min 값을 비교해 min보다 작다면 새로 초기화해 주고, list에 범위를 추가한다.
7. 모든 과정이 끝이 나면 list의 제일 첫 번째 원소가 시작점이 가장 작을 것이므로 그 값을 반환한다. (시작점은 진행하면서 점점 커져가기 때문에)

<br>

<hr>

#### #숫자의 표현

[숫자의 표현 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EC%88%AB%EC%9E%90%EC%9D%98%20%ED%91%9C%ED%98%84.java)

어렵게 생각해서 이상하게 풀다가 사실 초간단한 문제인 걸 알고 엄청나게 현타왔던 문제...💦

연속된 숫자라는 조건이 있기 때문에 중첩반복문을 쓰면서 안쪽 루프문의 반복인자가 첫 번째 루프문의 반복인자보다 1보다 더 커야 한다는 조건 말고는 간단한 문제였다. 하나씩 증가해 가면서 n이랑 비교하면 된다. 만약 같다면 answer 값을 하나 증가시켜주고 n보다 더 커진다면 더 이상 n이 될 확률은 0이기 때문에 break한다. 

<br>

<hr>

#### #신규 아이디 추천

[신규 아이디 추천 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EC%8B%A0%EA%B7%9C%20%EC%95%84%EC%9D%B4%EB%94%94%20%EC%B6%94%EC%B2%9C.java)

2021 카카오 공채 1번 문제였다. 코테 당시에도 어렵지 않게 풀었다. 역시 문자열 문제는 파이썬을 이길 수 없다고 개인적으로 생각하지만... 난 자바를 주력 언어로 하니까 이런 문제에도 익숙해지도록 많이 연습해야겠다. 💪

1. 소문자로 바꿔주기 위해 toLowerCase 함수를 사용했다.
2. 어떠한 패턴을 제외하고 모든 문자를 삭제하기 위해 정규표현식을 사용했다. 제일 오래 걸렸던 부분이다.
3. 연속된 마침표를 찾기 위해 flag 변수를 두어 등장했을 때 true로 바꾸고 만약 true인 상태에서 또 마침표가 등장한다면 그 부분은 건너 뛰어서 새로운 문자열을 만든다.
4. 문자열의 처음이나 끝에 마침표가 있으면 제거해 주기 위해 substring을 사용한다. 다만 길이가 1보다 크거나 같을 때 가능하다.
5. 문자열의 길이가 0인지 확인해서 만약 그렇다면 a를 넣어준다.
6. 길이가 16 이상이라면 substring을 사용해서 첫 15개의 글자 빼고 모두 제거한다. 이때, 끝에 마침표가 존재한다면 이 마침표는 제거해서 총 14개의 글자를 만들어준다.
7. 만약, 글자가 2 이하라면 while 반복문을 사용해서 길이 3을 만들어 준다.

<br>

<hr>

#### #이중 우선순위 큐

[이중 우선순위 큐 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EC%9D%B4%EC%A4%91%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90.java)

레벨 3이라서 겁먹었는데 어려운 문제는 아니었다. 사실 백준에서 풀다가 너무 안 풀려서 내가 잘못 풀었나 하고 프로그래머스에서 제출했더니 바로 맞았다...🤷‍♀️

큐는 덱과 같이 양쪽으로 입출력이 불가능하기 때문에 최솟값을 저장하는 큐와 최댓값을 저장하는 큐 2가지를 정의했다. 그래서 이중 우선순위 큐일까...? 🤔

1. 문제에서 주어진 operation의 길이만큼 반복문을 진행한다.
2. 명령문이 I일 때 큐에 그냥 집어넣으면 되므로 두 개의 큐에 offer해준다. (이때, add와 offer가 궁금하다면 [여길](https://github.com/hjyeon-n/BE_TIL/blob/master/Spring%EC%9D%98%20%EC%9D%B4%EA%B2%83%EC%A0%80%EA%B2%83/JAVA%20%EB%A9%94%EC%86%8C%EB%93%9C%20%EC%A0%95%EB%A6%AC.md#Queue) 참조하면 된다.)
3. 만약 D라면 제거 연산이기 때문에 큐의 사이즈가 1 이상인지 확인한다.
4. D 1 이라면 최댓값을 삭제해야 하기 때문에 maxQ에서 값을 poll 한다. 하지만 minQ에서는 가장 마지막 값이 최댓값이기 때문에 Stack을 정의해서 마지막 값이 나올 때까지 큐에서 값을 빼내서 stack에 저장한다. 이때, 최댓값과 같은 값이 여러 개 나올 수 있고 그 경우 먼저 나온 값을 제거해야 하기 때문에 최댓값과 값이 같다면 하나만 빼주고 나머지는 모두 스택에 넣어준다.
5. 스택의 값들을 다시 minQ에 삽입한다.
6. D -1일 때는ㅇ 반대로 진행해 주면 된다.
7. 만약 하나의 큐가 비었더라면 문제의 조건대로 0, 0을 반환하고 그렇지 않으면 각자의 큐에서 값을 빼내 반환한다.

<br>

<hr>

#### #이진 변환 반복하기

[이진 변환 반복하기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EC%9D%B4%EC%A7%84%20%EB%B3%80%ED%99%98%20%EB%B0%98%EB%B3%B5%ED%95%98%EA%B8%B0.java)

두 번에 걸쳐 이 문제를 풀었는데 처음엔 이상하게 접근해서 너무 안 풀리다가 다음날에 보니 이게 뭐지 싶게 10분도 안 걸려서 풀었다.

1. 이진변환의 횟수를 conversion, 제거된 0의 개수들은 sum이라고 정의한다.
2. 만약, s가 1이라면 break 되는 무한루프문을 만든다.
3. s의 길이만큼 현재 0의 개수를 세준다. 그리고 이를 sum에 더해준다.
4. 그리고 s의 길이에서 0의 개수를 뺀 뒤 그 값을 이진화한다. 이때 toBinaryString 함수를 사용한다.
5. 반복문이 진행될 때마다 conversion 변수의 값을 하나씩 증가시킨다.
6. conversion과 sum을 차례대로 넣어 answer를 반환한다.

<br>

<hr>

#### #정수 내림차순으로 배치하기

[정수 내림차순으로 배치하기 소스 코드]()

엄청나게 쉬운 문제. n을 받으면 자릿수의 숫자들로 내림차순으로 정렬하면 된다.

1. 각각의 자릿수를 구하기 위해서 10으로 나누는 과정을 반복한다.
2. 1번의 값을 list에 넣어준다.
3. list를 내림차순으로 정렬한다.
4. 이 숫자 값들은 +를 쓰면 더해지기 때문에 각각을 문자열로 바꿔서 list를 순회하면서 하나의 값으로 만들어준다.
5. 4번의 결과값을 Long형으로 바꿔 반환한다.

<br>

<hr>

#### #행렬의 덧셈

[행렬의 덧셈 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%ED%96%89%EB%A0%AC%EC%9D%98%20%EB%8D%A7%EC%85%88.java)

풀이하기 민망한 문제... 생략합니다...

<br>

<hr>

#### #정수 제곱근 판별

[정수 제곱근 판별 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EC%A0%95%EC%88%98%20%EC%A0%9C%EA%B3%B1%EA%B7%BC%20%ED%8C%90%EB%B3%84.java)

풀이를 쓰기엔 내가 부끄럼이 많다... 곧이곧대로 푸는 문제

<br>


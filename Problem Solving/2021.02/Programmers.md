# Programmers

| 문제 이름                                                 | 문제 링크                                                    |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| [N개의 최소공배수](#N개의-최소공배수)                     | [N개의 최소공배수](https://programmers.co.kr/learn/courses/30/lessons/12953) |
| [더 맵게](#더-맵게)                                       | [더 맵게](https://programmers.co.kr/learn/courses/30/lessons/42626) |
| [디스크 컨트롤러](#디스크-컨트롤러)                       | [디스크 컨트롤러](https://programmers.co.kr/learn/courses/30/lessons/42627) |
| [메뉴 리뉴얼](#메뉴-리뉴얼)                               | [메뉴 리뉴얼](https://programmers.co.kr/learn/courses/30/lessons/72411) |
| [방문 길이](#방문-길이)                                   | [방문 길이](https://programmers.co.kr/learn/courses/30/lessons/49994) |
| [보석 쇼핑](#보석-쇼핑)                                   | [보석 쇼핑](https://programmers.co.kr/learn/courses/30/lessons/67258) |
| [숫자의 표현](#숫자의-표현)                               | [숫자의 표현](https://programmers.co.kr/learn/courses/30/lessons/12924) |
| [신규 아이디 추천](#신규-아이디-추천)                     | [신규 아이디 추천](https://programmers.co.kr/learn/courses/30/lessons/72410) |
| [이중 우선순위 큐](#이중-우선순위-큐)                     | [이중 우선순위 큐](https://programmers.co.kr/learn/courses/30/lessons/42628) |
| [이진 변환 반복하기](#이진-변환-반복하기)                 | [이진 변환 반복하기](https://programmers.co.kr/learn/courses/30/lessons/70129) |
| [정수 내림차순으로 배치하기](#정수-내림차순으로-배치하기) | [정수 내림차순으로 배치하기](https://programmers.co.kr/learn/courses/30/lessons/12933) |
| [정수 제곱근 판별](#정수-제곱근-판별)                     | [정수 제곱근 판별](https://programmers.co.kr/learn/courses/30/lessons/12934) |
| [행렬의 덧셈](#행렬의-덧셈)                               | [행렬의 덧셈](https://programmers.co.kr/learn/courses/30/lessons/12950) |

<br>

<hr>

#### #N개의 최소공배수

[N개의 최소공배수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/N%EA%B0%9C%EC%9D%98%20%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98.java)

한참동안 문제 풀이를 귀찮아서 미뤘더니 지난 7월과 모양이 비슷해졌다... 와르르 쓰는 모양새가 말이다.

똑같은 내가 풀었는데 시간이 조금만 지나도 너무 생경해진다... 이건 또 어떻게 풀었더라. 😫

<br>

최소공배수를 어떻게 구하는지 생각해서 코드로 나타내면 되는데 최소공배수는 모든 수가 한꺼번에 나누어지는 수가 나올 때만 나누는 게 아니라 어떤 수이더라도 나누어 떨어지는 수가 있다면 그 수로 나눠야 한다. 이 과정을 newArr라는 새로운 int형 배열로 표현하였다.

1. n으로 나눠서 어떤 수가 나누어 떨어지는 즉, 공배수를 구할 때 n은 2 이상이어야 하는데 그 수가 계속 증가하는 게 아니라 다시 2가 될 수도 더 큰 수가 될 수도 있기 때문에 제일 큰 루프문으로 무한 반복문을 묶는다.
2. 공배수가 나누려는 값보다 커지진 않기 때문에 배열을 오름차순으로 정렬하고 그 마지막 값을 max 값으로 잡는다.
3. n이 max보다 크거나 같을 때까지 반복하는 루프문을 만든다.
4. 3번의 반복문에서 arr의 크기만큼 돌면서 n으로 나눠지는 수가 있는지 검사한다. 이때 만약 나누어지는 수가 있다면 flag 값을 true로 둔다. 나누어지든 그렇지 않든 newArr 값에 나눈 값, 아니면 그대로의 값을 넣는다.
5. 만약 4번에서 나온 flag 값이 true이면 최소공배수인 answer 값에 n만큼 곱해주고 3번의 반복문을 빠져나온다. 그렇지 않다면 다시 n을 늘려서 나누어 떨어지는 수가 있는지 체크한다.
6. status 값을 false로 둬서 arr 값이 모두 1인지 확인한다. 만약 하나라도 1이 아니라면 아직 최소공배수는 나오지 않은 것이기 때문에 1번의 반복문으로 돌아간다. 그렇지 않다면, 반복문을 빠져나와 answer를 반환한다.

<br>

<hr>

#### #더 맵게

[더 맵게 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EB%8D%94%20%EB%A7%B5%EA%B2%8C.java)

프로그래머스에서 처음 푸는 우선순위 큐 문제. 쉽게 풀었다.

여러가지 자료구조를 배우면서 문제를 풀 수 있는 방법의 폭이 넓어진다는 걸 배운다 오호~

가장 맵지 않은 것과 두 번째로 맵지 않은 것을 구하기 위해서는 작은 수가 우선순위가 더 높아서 먼저 나올 수 있도록 우선순위 큐를 사용한다.

1. 우선순위 큐를 선언하고 배열의 수를 차례대로 입력한다.
2. 큐의 사이즈가 1보다 커야 문제를 진행할 수 있고, front 값이 K 이상이라면 문제의 조건에 이미 부합하기 때문에 이 조건들을 확인한다.
3. 만약 큐의 사이즈가 1보다 작거나 같다면 스코빌 지수를 K 이상으로 만들 수 없기 때문에 (K 이상이라면 2번의 조건에서 걸러진다.) -1을 반환하고 끝낸다.
4. 큐에서 값 2개를 뽑아 문제의 조건대로 가장 맵지 않은 음식과 두 번째로 맵지 않은 음식에 2를 곱해 더한 값을 다시 큐에 넣어준다.
5. 이때 최소 횟수를 구해야 하기 때문에 반복문이 반복될 때마다 answer 값을 늘려준다.

<br>

<hr>

#### #메뉴 리뉴얼

[메뉴 리뉴얼 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EB%A9%94%EB%89%B4%20%EB%A6%AC%EB%89%B4%EC%96%BC.java)

카카오 2021 공채 문제이다. 하반기 첫 코딩테스트이기도 했는데 그땐 시간초과로 이 문제를 못 풀었더랬다...

아쉬움이 남은 문제였는데 이번에는 한방에 풀었다. 뭐지.. 테스트케이스가 달라졌을까. 이전 코드가 기억나지 않아서 무슨 차이가 있는지 모르겠다...

1. 메뉴에 나오는 알파벳들을 가지고 조합을 구하기 위해, 등장하는 알파벳을 선별해야 한다. 이를 위해 Set 자료구조를 사용해서 orders 배열을 순회하면서 한 번 이상 등장한 알파벳을 선별한다.
2. set을 배열로 바꾸기 위해서 tmp라는 ArrayList를 선언하고 이를 다시 배열로 바꿔준다. 알파벳을 오름차순으로 정렬해야 하기 때문에 배열을 sort해준다.
3. course 배열 원소만큼 메뉴를 구상해야 하기 때문에 2번에서 구한 arr에서 그 수만큼 뽑아내는 조합의 과정을 거쳐야 한다. 이를 course의 길이만큼 반복문을 돌린다. 조합은 백트래킹으로 진행한다.
4. 만약 course에 해당하는 원소만큼 뽑았을 때, 결과 문자들이 orders에 포함되는지 확인한다. 이때 문자들이 각각 흩어진 경우가 있기 때문에, (예를 들어 ACE와 ADE에서 AE라는 메뉴를 뽑아낼 수 있지만 AE라는 문자열은 어디에도 포함되지 않는다.) 문자 각각이 포함되는지 확인해야 한다.
5. 만약 포함이 된다면, cnt를 늘려준다.
6. cnt가 max 값보다 크고 cnt가 2보다 크다면 이전에 기록했던 메뉴 리스트는 사라지고 새로운 메뉴 리스트가 나오게 된다. 따라서 list를 새로 정의하고 문자들을 문자열로 만들어 list에 add한다.
7. 만약 cnt가 2보다 크고 max와 같다면 기존의 메뉴 리스트에 또 추가되는 경우이다. 따라서, 똑같이 문자열로 만들어 list에 추가한다.
8. 다시 메인으로 돌아와서 오름차순으로 정렬해 준 뒤, 반환한다.

<br>

좀 복잡하게 푼 것 같기도 하다... 다른 사람 풀이를 참고해서 더 좋은 풀이가 없는지 고민해 봐야겠다.😎

<br>

<hr>

#### #정수 내림차순으로 배치하기

[정수 내림차순으로 배치하기 소스 코드]()

엄청나게 쉬운 문제. n을 받으면 자릿수의 숫자들로 내림차순으로 정렬하면 된다.

1. 각각의 자릿수를 구하기 위해서 10으로 나누는 과정을 반복한다.
2. 1번의 값을 list에 넣어준다.
3. list를 내림차순으로 정렬한다.
4. 이 숫자 값들은 +를 쓰면 더해지기 때문에 각각을 문자열로 바꿔서 list를 순회하면서 하나의 값으로 만들어준다.
5. 4번의 결과값을 Long형으로 바꿔 반환한다.

<br>

<hr>

#### #행렬의 덧셈

[행렬의 덧셈 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%ED%96%89%EB%A0%AC%EC%9D%98%20%EB%8D%A7%EC%85%88.java)

풀이하기 민망한 문제... 생략합니다...

<br>

<hr>

#### #정수 제곱근 판별

[정수 제곱근 판별 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.02/%EC%A0%95%EC%88%98%20%EC%A0%9C%EA%B3%B1%EA%B7%BC%20%ED%8C%90%EB%B3%84.java)

풀이를 쓰기엔 내가 부끄럼이 많다... 곧이곧대로 푸는 문제

<br>


# Graph

| 문제 번호                                      | 이름                                |
| ---------------------------------------------- | ----------------------------------- |
| [1916](https://www.acmicpc.net/problem/1916)   | [최소비용 구하기](#최소비용-구하기) |
| [14395](https://www.acmicpc.net/problem/14395) | [4연산](#4연산)                     |

<br>

<hr>

#### #최소비용 구하기

[최소비용 구하기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.02/Solution_1916.java)

그래프 이론에 관한 문제를 풀어 보고 싶어서 도전했던 문제이다. 물론, 아직 다익스트라를 구현하는 데 어려움이 있어서 다른 사람 풀이를 많이 참고했다.

다익스트라의 기본 문제인 만큼 잘 익혀서 다른 문제는 스스로 풀어 봐야겠다.

1. 가중치를 INF로 초기화한다.
2. 각 정점에 인접한 점들을 ArrayList로 나타내기 위해 반복문을 돌면서 모든 정점에 ArrayList를 정의한다.
3. 인접한 점들과 가중치를 입력한다.
4. 최소비용을 구하기 위해서 우선순위 큐를 사용한다. 
5. 큐가 빌 때까지 진행하며 최소 비용을 dist에 저장해 나가는 방식이다.
6. 만약 현재 dist의 값이 새로운 경로의 가중치 값보다 작다면 갱신될 수는 없기 때문에 다시 반복문을 시작한다.
7. 아니라면, 해당 정점에 대한 모든 인접한 정점들을 탐색해서 dist의 값보다 어떤 정점을 경유하고 가는 경로가 더 최소비용이라면 dist를 초기화해주고 이를 다시 우선순위 큐에 넣는다.

<br>

이 문제를 풀기 위해서는 무엇보다 다익스트라 알고리즘에 대한 이해가 필요한데 예전에 [여기](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/Dijkstra%20Algorithm.md)에 정리해 두었으니 다시 읽으면 좋을 것 같다! 😉

<br>

➕ 2021년 4월 15일 추가

ver2라고 새롭게 푼 버전을 추가했다. 이 버전은 스스로 얼렁뚱땅 풀었는데 우선순위 큐가 아니라 큐로 풀었다.

큐로도 풀 수 있는데 왜 우선순위 큐로 풀었어야 했는지 검색해 봤는데 사실상 **우선순위 큐**로 푸는 게 맞다. ver2처럼 새로운 정점을 단순히 큐에 저장하고 빼낼 게 아니라 큐에 저장했다가 가중치가 낮은 값을 먼저 빼내야 하는 최소 힙 성질을 가져야 하기 때문이다.

운이 좋게도 이 문제는 메모리 제한이 그렇게 빡센 건 아니라서 큐로도 잘 풀렸던 것 같다. 비록 ver2가 언제 틀릴지 모르겠지만 참고하자는 마음에서 추가했다...! 😂

<br>

<hr>

#### #4연산

[4연산 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.02/Solution_14395.java)

간만에 풀었던 BFS 문제이다. 처음에는 이걸 어떻게 해야 하지 싶었는데 그냥 말그대로 4연산 전부 해 보고 그 결과값을 큐에 넣고 다시 4연산을 하는 방식으로 진행한다. 따라서 범위 문제와 변수형 타입을 잘 생각해야 한다.

1. s와 t를 입력 받고 만약 처음부터 같다면 0을 출력하고 끝낸다.
2. 그렇지 않다면 bfs를 진행한다.
3. 4연산의 결과가 커질 수 있기 때문에 Long형으로 선언한다.
4. 어떤 연산의 결과가 동일할 수도 있기 때문에 중복을 피하기 위해 HashSet을 선언해 방문 표시를 한다. 연산은 list에 넣는다.
5. 만약 val이 t와 같다면 정답이 되는 경우의 수이기 때문에 list에 추가한다.
6. 연산의 결과가 문제에서 요구하는 수의 범위보다 작거나 같고 set에 포함되지 않았을 때 방문 표시를 해주고 큐에 결과 값과 연산들을 넣는다.
7. 만약 bfs 탐색이 끝났는데 list의 크기가 0이라면 한 번도 연산의 결과가 t와 같지 않은 것이기 때문에 -1을 출력하고 그렇지 않으면 list를 정렬해 제일 첫 번째 값을 출력한다.


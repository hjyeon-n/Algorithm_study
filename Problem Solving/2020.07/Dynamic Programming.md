# Dynamic Programming

| 문제 번호 | 이름                                                         |
| --------- | ------------------------------------------------------------ |
| 11726     | [2xN 타일링](#2xN-타일링)                                    |
| 11727     | [2xN 타일링2](#2xN-타일링2)                                  |
| 2193      | [이친수](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_2193.java) |
| 11057     | [오르막 수](#오르막-수)                                      |
| 2579      | [계단 오르기](#계단-오르기)                                  |
| 9461      | [파도반 수열](#파도반-수열)                                  |
| 1912      | [연속합](#연속합)                                            |
| 2156      | [포도주 시식](#포도주-시식)                                  |
| 11052     | [카드 구매하기](#카드-구매하기)                              |
| 10844     | [쉬운 계단 수](#쉬운-계단-수)                                |
| 11053     | [가장 긴 증가하는 부분 수열](#가장-긴-증가하는-부분-수열)    |
| 9095      | [1, 2, 3 더하기](#1,-2,-3-더하기)                            |
| 1793      | [타일링](#타일링)                                            |
| 11722     | [가장 긴 감소하는 부분 수열](#가장-긴-감소하는-부분-수열)    |
| 1010      | [다리 놓기](#다리-놓기)                                      |
| 11055     | [가장 큰 증가 부분 수열](#가장-큰-증가-부분-수열)            |
| 15988     | [1, 2, 3 더하기 3](#1,-2,-3-더하기-3)                        |
| 14501     | [퇴사](#퇴사)                                                |
| 1463      | [1로 만들기](#1로-만들기)                                    |
| 2163      | [초콜릿 자르기](#초콜릿-자르기)                              |
| 1932      | [정수 삼각형](#정수-삼각형)                                  |
| 2225      | [합분해](#합분해)                                            |
| 1149      | [RGB 거리](#RGB-거리)                                        |
| 1003      | [피보나치 함수](#피보나치-함수)                              |
| 9251      | [LCS](#LCS)                                                  |
| 9465      | [스티커](#스티커)                                            |

<br>

<hr>


#### #2xN 타일링

[2xN 타일링 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_11726)

난 직접 그려보면서 규칙을 발견한 뒤 식을 세워 풀었지만, 그럴 필요없이 경우의 수를 생각하면 금방 풀 수 있는 문제.

타일이 2x1, 1x2 두 개의 종류만 있기 때문에 마지막에 올 수 있는 경우도 2x1 타일 하나 혹은 1x2 타일 2개만 올 수 있다.  

마지막에 2x1 타일이 왔을 경우, **나머지 타일의 개수는 n-1**

1x2 타일이 왔을 경우, **나머지 타일의 개수는 n-2**

✔ 따라서 점화식은 dp[n] = dp[n - 1] + dp[n- 2]. 피보나치 수와 똑같은 식이 나오게 된다.

<br>

<hr>


#### #2xN 타일링2

[2xN 타일링2 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_11727)

2xN 타일링과 유사한 문제. 타일이 2x1, 1x2, 2x2 세 개의 종류가 있다. 마지막 위치에도 이 3개의 타일 중 하나가 올 수 있다.

마지막에 2x1,타일이 왔을 경우, **나머지 타일의 개수는 n-1**

1x2, 2x2 타일이 왔을 경우, **나머지 타일의 개수는 (n-2) * 2**

✔ 따라서 점화식은 dp[n] = dp[n - 1] + dp[n- 2] * 2

문제 조건에 따라 큰 수가 나올 수 있기 때문에 10007로 모듈러 연산을 해야 한다.

<br>

<hr>


#### #이친수

[이친수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_2193.java)

이 문제도 규칙을 발견하기 위해 직접 자릿수가 1개일 때, 2개일 때 등을 구한 뒤 식을 세워 풀었다.

이친수는 2가지 중요한 규칙이 있다.

1. 0으로 시작하지 않는다.
2. 1이 연속하지 않는다.

이 규칙들을 적용하면, n번째 자리에 0이 올 때 n-1번째 자리에 0이나 1이 와도 상관 없지만 n번째 자리에 1이 오면 무조건 0이 와야 하기 때문에 dp[n-2]를 더하면 된다.

✔ 따라서 점화식은 dp[n] = dp[n - 1] + dp[n - 2]

결과값이 크기 때문에 int형이 아닌 long형을 줘야 하는 것도 주의해야 한다.

<br>

<hr>


#### #오르막 수

[오르막 수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11057.java) 

앞의 수가 0이 나올 수 있고, 뒤에 있는 수는 오르막 수여야 하기 때문에 같거나 커야 한다는 게 이 문제의 핵심이다.

dp 배열을 2차원 배열로 선언해 자릿수와 뒤에 올 수 있는 수(0~9)를 인덱스로 해서 문제를 풀면 된다.

1. 값을 입력 받는다.
2. 자릿수를 올리는 for문 안에 경우의 수(0 ~ 9) for문이 위치한다. 0이 오면 0 ~ 9까지, 1이 오면 1~ 8까지 경우를 다 합해줘야 하기 때문에 안에 또 하나의 for문을 만들어 3중 반복문을 만든다.

3. dp[구하고자 하는 자릿수] [0 ~ 9]를 모두 더한다.

<br>

<hr>


#### #계단 오르기 ⭐

[계단 오르기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_2579.java)

계단 오르기 문제 조건

1. 한 계단이나 두 계단을 동시에 오를 수 있다.
2. 단, 3개의 계단을 연속으로 밟을 수는 없다.
3. 마지막 계단은 반드시 밟아야 한다.

<br>

이 조건들을 충족하기 위해서 현재 n번째 계단일 때 dp[n]을 구하기 위해서는

1. n - 2번째 계단을 밟은 경우(즉, 두 계단을 오른 경우) = dp[n - 2]
2. n - 1번째 계단을 밟은 경우(즉, 한 계단을 오른 경우이며 연속으로 밟을 수는 없기 때문에 n - 1 계단의 전전 계단을 고려해야 한다) = dp[n - 3] + stair[n - 1]

이 값들 중 큰 값을 구해 현재 계단 점수를 더하면 된다.

✔ 점화식 dp[n] = stair[n] + Math.max(dp[n - 2] , dp[n - 3] + stair[n - 1])

<br>

<hr>


#### #파도반 수열

[파도반 수열 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_9461.java)

문제에 이미 문제를 해결하기 위한 규칙이 나열돼 있어서 쉽게 풀었던 문제😏

P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9 < 이 규칙을 자세히 보면 dp[4] = dp[1] + dp[2]라는 점을 알 수 있다. 나머지도 다 같은 규칙을 따르고 있다.

따라서 1부터 3까지의 dp 배열은 1로 초기화 해준 뒤, 4부터 값을 구하면 된다.

✔ 점화식은 dp[n] = dp[n - 3] + dp[n - 2]

<br>

<hr>


#### #연속합

[연속합 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_1912.java)

어려운 문제도 아니었는데 풀고 나서는 자존감이 올라갔던 문제😎

이 문제는 dp를 n번째 인덱스에서 arr[n]과 dp[n - 1] + arr[n]의 최댓값을 구해서 풀면 된다. (음수가 있기 때문에 합이 항상 큰 값을 나타내는 것은 아니다)

✔ 점화식은 dp[n] = Math.max(arr[n], dp[n - 1] + arr[n])

<br>

<hr>


#### #포도주 시식 ⭐

[포도주 시식 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_2156.java) 🍷

왜 이 문제가 이렇게 어려웠는지...😫 [계단 오르기](#계단-오르기)와 비슷하면서도 어려웠다.

계단 오르기처럼 3개가 연속되는 것을 피하면 되지만 포도주 시식의 경우, 현재 포도주를 아예 마시지 않는 경우까지 고려해야 한다.

즉, 경우의 수는 이렇게 나타낼 수 있다.

1. 포도주를 마시지 않을 때 → OOX
2. 현재 포도주를 마실 때 → OXO
3. 연속해서 포도주를 마실 때 → XOO

<br>

각각의 경우에 대한 점화식은 이렇게 나타낼 수 있다.

1. 포도주를 마시지 않기 때문에 이전의 dp값을 그대로 가져온다.

   ✔ dp[n] = dp[n - 1]

2. 한 번 연속한 경우기 때문에 dp[n - 2]에 현재 포도주를 더해준다.

   ✔ dp[n] = dp[n - 2] + arr[n]

3. 두 번 연속한 경우기 때문에 dp[n - 3]에 이전 포도주와 현재 포도주를 더해준다.

   ✔ dp[n] = dp[n - 3] + arr[n - 1] + arr[n]

<br>

이 3가지 경우 중 가장 큰 값을 고르면 정답이다.

✔ 최종 점화식은 dp[n] = Math.max(dp[n - 1], Math.max(dp[n - 2] + arr[n], dp[n - 3] + arr[n - 1] + arr[n]))

<br>

<hr>


#### #카드 구매하기 ⭐

[카드 구매하기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11052.java) 🃏

이 문제도 나에겐 너무 어려웠다...😭 카드의 가치를 수량만큼 나눠야 하나? 하는 생각에 엄청 헤맸다. 그리고 dp 점화식 하나만 생각하려고 온갖 애를 썼는데 이중 반복문을 쓰면 다른 경우들도 생각할 수 있다는 걸 깨달았다... (바보🤪)

<br>

이 문제는 최저 금액으로 카드를 사려는 게 아니라 최대한 많은 금액으로 원하는 카드 개수만큼 사는 게 목적이다. 또한 카드를 구매하는 경우도 다양하게 나뉜다. 

만약 5개를 구매한다고 하면

- 1개가 들어있는 카드팩을 5개 사는 경우
- 2개가 들어있는 카드팩 1개와 3개가 들어있는 카드팩을 1개 사는 경우
- 5개가 들어있는 카드팩 1개를 사는 경우
- ...

등의 여러가지 경우가 나올 수 있다. 따라서 dp도

- 1개를 구매하기 위한 최댓값 + 4장 팩값
- 2개를 구매하기 위한 최댓값 + 3장 팩값
- ...

등으로 나올 수 있다.

✔ 따라서 최종 점화식은 dp[i] = Math.max(dp[i\], dp[i - j] + arr[j]) 이 때 i는 카드의 개수만큼 반복하고, j는 1부터 i까지 반복한다.

<br>

<hr>


#### #쉬운 계단 수

[쉬운 계단 수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_10844.java) 

[오르막 수](#오르막-수) 와 비슷한 문제. 단, 이 문제는 오르막 수와 달리 단순히 오름차순이 아니라 각 자릿수의 숫자가 1씩 차이가 나야 하고, 뒷자리 수가 앞자리 수보다 1씩 차이가 나면 작아도 상관이 없다.

dp 배열을 2차원 배열로 선언해서 i 자리에는 자릿수, j에는 끝자리의 수가 들어갈 수 있게 하였다.

예를 들어 dp[2] [3]은 2자리의 수이고 j는 끝자리이기 때문에 23, 43이 들어올 수 있다. 

✔ 따라서 점화식은 dp[n] [m] = dp[n - 1] [m - 1] + dp[n - 1] [m + 1]이다.



하지만 m이 9가 되는 경우에 dp[m + 1]에 의해 인덱스를 벗어나기 때문에 m이 9일 때는 dp[n] [m] = dp[n - 1] [m - 1]

마찬가지로 m이 0이 되는 경우엔 dp[m - 1]에 의해 인덱스를 벗어나기 때문에 m이 0일 때는 dp[n] [m] = dp[n - 1] [m + 1] 

<br>

<hr>


#### #가장 긴 증가하는 부분 수열 ⭐

[가장 긴 증가하는 부분 수열 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11053.java)

이 문제는 중첩 반복문을 이용해서 풀었다. 배열의 길이만큼 i가 돌고 i를 끝이라고 생각해서 j를 배열의 처음부터 i까지 반복해서 arr[i]와 arr[j]를 비교하는 과정으로 구현했다.

수열의 길이를 구하는 문제이기 때문에 dp는 모두 1로 초기화했다. 반복문을 돌면서 증가하는 부분이고, i가 가리키고 있는 길이와 j의 길이를 비교해 더 큰 값을 dp 값에 넣어주면 된다.

✔ dp[i] = Math.max(dp[i], dp[j] + 1)

<br>

<hr>


#### #1, 2, 3 더하기

[1, 2, 3 더하기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_9095.java)

dp 공부 시작한지 얼마 안 됐을 때 풀었던 문제.

- 1을 1, 2, 3 더하기로 나타내려면 1 → 1가지
- 2를 나타내면 2, 1 + 1 → 2가지
- 3을 나타내면 3, 1 + 1 +1, 2 + 1, 1 + 2 -> 4가지

이 3가지 경우는 미리 초기화했다. 

4일 때 나올 수 있는 경우는 1 + **1 + 1 + 1**, 1 + **1 + 2**, 1 + **2 + 1**, 1 + **3** ... 의 경우가 있다. 

위의 식들과 비교했을 때 1을 두고 나머지 합이 3이 될 수 있게 하기 위해선 dp[3]이 필요하고, 마찬가지로 2가 되려면 dp[2], 1이 되게 하려면 dp[1]이 필요하다. 

✔ 점화식은 dp[n] = dp[n - 3] + dp [n - 2] + dp[n - 1]

<br>

<hr>


#### #타일링

[타일링 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_1793.java)

이 문제는 큰 수가 나올 수 있기 때문에 long이나 int가 아니라 BigInteger를 사용해야 하는 문제이다.

나머지는 [2XN 타일링](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_11726) 과 유사한 문제이다.

문제는 2×n 직사각형을 2×1과 2×2 타일로 채우는 방법의 수를 구하라고 했지만, 예시 그림을 보면 2×1과 2×2 타일 그리고 1x2타일도 고려하는 듯.

✔ 따라서 점화식은 dp[n] = 2 * dp[n - 2] + dp[n - 1]

<br>

<hr>


#### #가장 긴 감소하는 부분 수열

[가장 긴 감소하는 부분 수열 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11722.java)

[가장 긴 증가하는 부분 수열](#가장-긴-증가하는-부분-수열) 에서 arr의 크기를 비교하는 부등호만 바꿔주면 된다.

<br>

<hr>


#### #다리 놓기

[다리 놓기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_1010.java)

동쪽에 있는 M이 항상 N보다 크거나 같고, 서로 겹치지 않게 서쪽의 사이트와 동쪽의 사이트를 연결하려고 할 때 경우의 수를 구해야 한다.

서로 겹칠 수 없다는 조건이 있기 때문에 서쪽의 하나의 다리가 이미 결정됐다고 가정하고, 나머지 다리의 경우의 수를 구하는 식으로 dp점화식을 구할 수 있다.

예를 들어 N이 2라고 하면 M은 N보다 크거나 같기 때문에 N 이상의 수가 와야 한다.

M이 2인 경우에 dp[2] [2]는 겹칠 수 없기 때문에 한 가지 경우가 나오게 된다.

M이 3인 경우에 dp[2] [3]은 하나의 다리가 이미 결정됐다고 가정하면, dp[1] [3] (하나의 다리가 연결될 수 있는 경우의 수)과 dp[2] [2] (하나가 이미 결정됐다고 가정한 후 남은 다리를 만들 수 있는 경우의 수)로 경우가 나뉘게 된다. 

✔ 따라서 점화식은 dp[n] [m] = dp[n - 1] [m - 1] + dp[n] [m - 1]

<br>

<hr>


#### #1, 2, 3 더하기 3

[1, 2, 3 더하기 3 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_15988.java)

[1, 2, 3 더하기](#1,-2,-3-더하기) 랑 거의 똑같은 문제. 모듈러 연산과 반복 케이스가 있다는 점 말고는 풀이는 똑같다.

<br>

<hr>


#### #퇴사 ⭐

[퇴사 소스 코드]()

호기롭게 풀려고 시도했다가 깨갱한 문제...😂

몰랐는데 삼성 SW 역량 테스트 기출 문제였다. 난이도를 보면 어려운 문제는 아니었던 것 같은데 의외로 끙끙대면서 풀었다.

<br>

퇴사하는 날이 이미 정해졌기 때문에 퇴사 날보다 더 오래 걸리는 상담을 하면 안 된다. 따라서 퇴사일부터 1일차까지 반복 인자 i를 가지고 반복문을 돌려야 한다. 또한 중간에 퇴사 날보다 오래 걸리는 상담이 있을 수 있기 때문에 i + arr_t[] (걸리는 기간)의 값을 더해 퇴사일보다 작아야만 dp 값을 계산할 수 있게 해야 한다. 만약 이보다 큰 경우, dp[i] = dp[i + 1]로 값을 넣어준다. (반복문이 n에서 1로 가는 점을 고려)

현재 위치의 상담을 하고 받을 수 있는 금액과 상담일이 다 끝났을 때의 일자(즉, T 기간이 흐른 후)에 받을 수 있는 금액을 더한 뒤, 오늘의 상담을 포기하고 다음날 상담을 했을 때 받을 수 있는 금액과 비교하면 최대 수익을 얻을 수 있다.

✔ dp[i] = Math.max(arr_p[i] + dp[day], dp[i + 1]);

<br>

<hr>


#### #1로 만들기

[1로 만들기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_1463)

무려 2018년에 풀었던 문제... 사실 수업 시간에 교수님과 함께 풀었어서 전혀 기억이 나지 않았다.

그땐 너무 어려워서 큰일났다 싶었는데 지금은 다 알겠다!!! 이 수준은 아니지만 음! 그렇군 하는 수준까지는 왔다😺

<br>

문제에서 사용하는 연산은 이와 같다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

<br>

처음엔 그리디 알고리즘처럼 최대한 빨리 1로 만들기 위해서는 가장 큰 수인 3으로 나누는 게 빠르다고 생각했다. 하지만 10의 경우에는 우선 1을 빼고 나서 3으로 나누는 순서가 더 빨리 만들 수 있었다. 따라서 3가지 경우를 전부 따져보고 최소가 되는 경우에 dp에 넣어야 한다.

1을 빼는 경우엔 dp[i] = dp[i - 1] + 1

2로 나누어 떨어지는 경우엔 dp[i] = Math.min(dp[i / 2] + 1, dp[i])

3으로 나누어 떨어지는 경우엔 dp[i] = Math.min(dp[i / 3] + 1, dp[i])

<br>

<hr>


#### #초콜릿 자르기

[초콜릿 자르기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_2163.java)

사실 이 문제는 DP로 풀지 않고 N*M - 1을 하면 쉽게 풀 수 있지만 DP 카테고리에 있는 만큼 DP로 풀었다.

<br>

N과 M이 입력됐을 때 N * M 크기의 초콜릿을 쪼개서 1 * 1의 초콜릿 조각으로 만들 수 있는 최소 쪼개기 횟수를 구하는 게 문제다.

난 N이 1일 때와 그렇지 않을 때를 구분해서 풀었다.

N이 1이라면 쪼개기 횟수는 M 만큼일 테고, 이를 점화식으로 나타내면

✔ dp[1] [j] = dp[1] [j - 1] + 1

N이 1이 아니라면 i를 1로 만들기 위해 계속 쪼개는 과정을 반복했고 그 후에 다시 위의 식으로 문제를 해결했다.

✔ dp[i] [y] = dp[i - 1] [y] + y;

<br>

<hr>


#### #정수 삼각형

[정수 삼각형 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_1932.java)

규칙을 도출해 내다가 머리가 쪼개지는 줄 알았다...😖

지금 생각해 보면 간단한 문제. 

현재 행은 이전의 행에서의 최댓값을 구해 현재 값을 저장하면 문제가 의도하는 최댓값을 찾아갈 수 있다. 즉, 이전 행이 없는 첫 번째 행을 제외하고는 두 번째 행부터 이전의 행 값 중 최댓값을 찾아서 현재 값을 더해주면 된다. [참고](https://fbtmdwhd33.tistory.com/49)

<br>

 두 번째 방법은 대각선의 경우를 생각하면 된다. 왼쪽 대각선은 항상 j가 1이 될 것이고 오른쪽 대각선은 항상 i와 j가 같을 것이다. 가운데 값은 이 중 최댓값을 구해서 더해주면 된다. [참고](https://mingyeongun-dev.tistory.com/29)

<br>

<hr>


#### #합분해

[합분해 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_2225.java)

개인적으로 너무 재밌었던 문제 😊

N과 K가 입력 되었을 때, 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하면 된다. 

나는 직접 규칙을 찾아가면서 풀었다.

예를 들어 N이 4, K가 2라고 하자.  그러면 경우의 수는 이렇게 나온다.

1. 0 + 4
2. 1 + 3
3. 2 + 2
4. 3 + 1
5. 4 + 0

결국 하나의 수를 정해뒀다고 가정하고 나머지 수가 올 수 있는 경우의 수를 생각하는 방식인데, 이미 한 가지 수를 확정 지으면서 K가 하나 감소했기 때문에 하나의 수만을 골라 N을 만들기 위해서는 방법은 단 하나 뿐이다.

✔ 따라서 점화식은 dp[i] [j] += dp[m] [j - 1] m은 0에서 i만큼, j는 2에서 k만큼 반복해서 구하면 된다.

<br>

<hr>

#### #RGB 거리

[RGB 거리 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_1149.java)

두 번째 줄부터의 입력은 각각 R, G, B로 집을 칠할 때의 비용을 나타낸다.

첫 번째 집을 칠할 때, R, G, B 중 최솟값으로 집을 칠하게 되고 두 번째 집을 칠할 때 첫 번째 집을 칠한 최솟값과 두 번째 집을 칠한 비용을 더하는 과정을 반복하면 된다. 이를 점화식으로 나타내면 dp[n] = dp[n - 1] + a[n] (a[n]은 최솟값).

하지만 항상 첫 번째의 최솟값이 모든 경우의 최솟값을 보장할 수 없으므로 첫 번째 집 또한 모든 경우를 고려해 봐야 한다.

빨간색으로 칠할 때는 초록색과 파란색으로 칠했을 때의 최솟값을 생각하면 되고, 이런 식으로 다른 색들도 경우들을 고려해서 문제를 풀 수 있다.

[참고](https://m.blog.naver.com/occidere/220785383050)

<br>

<hr>

#### #피보나치 함수

[피보나치 함수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_1003.java)

이번에는 bottom-up 방식이 아닌 memoization을 이용한 top-down 방식으로 문제를 풀었다.

memoization을 처음 배웠을 땐 이게 뭔가 싶었는데 지금도 약간은 뭐라고...?😵 이긴 하지만 전보다는 이해가 잘 되는 느낌.



피보나치 함수는 자기 자신을 중복 호출하는데 이를 재귀로 풀면 시간초과가 난다. 따라서 중복 호출 부분을 Memoization 해 두면 저장된 값을 이용해서 시간을 단축할 수 있다.

<br>

![image](https://user-images.githubusercontent.com/62419307/89437059-07837f00-d782-11ea-9e31-0e956f51f0c2.png)

예를 들어, fib(6)을 호출하게 되면 fib(3)이 4번이나 중복되어 계산된다.  따라서 fib(3)이 호출 되었을 때 memo에 해당 값이 저장되어 있는지 확인한다. 만약 값이 없다면 memo에 값을 저장하고, 값이 있으면 이미 저장된 값을 이용하면 중복 호출을 막을 수 있다.

<br>

<hr>

#### #LCS

[LCS 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_9251.java)

예전에 강의자료가 남아 있어서 그걸 참고하면서 풀었던 문제. 오히려 그때는 이해가 쉬웠는데 다시 보니 이해가 안 돼서 다른 분의 풀이도 참고했다.



이 문제는 원리만 알면 점화식을 구하는 건 어렵지 않다.

|       |  T   |  H   |  E   |  N   |
| :---: | :--: | :--: | :--: | :--: |
| **T** |  1   |  1   |  1   |  1   |
| **H** |      |      |      |      |
| **A** |      |      |      |      |
| **N** |      |      |      |      |

1. T와 T를 비교한다. → LCS 길이는 1
2.  T와 TH를 비교한다. → LCS 길이는 1 ... (생략)





|       |  T   |  H   |  E   |  N   |
| :---: | :--: | :--: | :--: | :--: |
| **T** |  1   |  1   |  1   |  1   |
| **H** |  1   |  2   |  2   |  2   |
| **A** |      |      |      |      |
| **N** |      |      |      |      |

1. TH와 T를 비교한다. → 다르므로 크기가 더 큰 LCS인 1을 가지고 온다.
2. TH와 TH를 비교한다. → 같으므로 LCS 길이는 2가 된다. ...(생략)





|       |  T   |  H   |  E   |  N   |
| :---: | :--: | :--: | :--: | :--: |
| **T** |  1   |  1   |  1   |  1   |
| **H** |  1   |  2   |  2   |  2   |
| **A** |  1   |  2   |  2   |  2   |
| **N** |  1   |  2   |  2   |  3   |

만약 THA와 TH를 비교한다고 했을 때, A와 H는 서로 다르기 때문에 하나는 버려야 한다. 이때 LCS를 구하는 것이기 때문에 TH와 TH를 비교하는 경우와 THA와 T를 비교하는 경우 중 더 긴 LCS의 길이가 THA와 TH의 LCS 길이가 된다.

✔ 점화식은 가리키는 문자가 같지 않을 때 c[i] [j] = Math.max(c[i - 1] [j], c[i] [j - 1]), 같을 때는 c[i] [j] = c[i - 1] [j - 1] + 1

<br>

<hr>

#### #스티커

[스티커 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_9465.java)

나에겐 꽤 어려웠다...😇 상냥아 그냥 좋은 스티커 사...

스티커를 떼어내서 얻을 수 있는 점수 중 최댓값을 구하는 문제. 단, 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 나는 숲을 보는 능력이 부족해서 그런지 몇 가지 경우를 구하긴 했는데 그 부분에 대해서 식으로 옮긴다거나 더 큰 경우로 확장할 생각은 못하고 허둥대다가 다른 사람의 풀이를 참고했다.

<br>

이 문제는 크게 3가지 경우가 있다.

1. 떼지 않고 넘어간 경우 dp[0] [0]
2. 위 쪽을 떼어낸 경우 dp[0] [1]
3. 아래 쪽을 떼어낸 경우 dp[0] [2]

<br>

따라서 점화식은

1. 어떤 경우가 와도 상관이 없으므로 dp[n] [0] = Math.max(dp[n - 1] [0], Math.max(dp[n - 1] [1], dp[n - 1] [1]))
2. 위 쪽을 떼어냈기 때문에 위 쪽의 경우만 빼면 된다 dp[n] [1] = Math.max(dp[n - 1] [0], dp[n - 1] [2]) + arr[0] [n]
3. 아래 쪽을 떼어냈기 때문에 아래 쪽만 빼면 된다. dp[n] [2] = Math.max(dp[n - 1] [0], dp[n - 1] [1]) + arr[0] [n]
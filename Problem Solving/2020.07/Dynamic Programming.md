# Dynamic Programming

| 문제 번호 | 이름                                                         |
| --------- | ------------------------------------------------------------ |
| 11726     | [2xN 타일링](#2xN-타일링)                                    |
| 11727     | [2xN 타일링2](#2xN-타일링2)                                  |
| 2193      | [이친수](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_2193.java) |
| 11057     | [오르막 수](#오르막-수)                                      |
| 2579      | [계단 오르기](#계단-오르기)                                  |
| 9461      | [파도반 수열](#파도반-수열)                                  |
| 1912      | [연속합](#연속합)                                            |
| 2156      | 포도주 시식                                                  |
| 11052     | 카드 구매하기                                                |
| 10844     | 쉬운 계단 수                                                 |
| 11722     | 가장 긴 감소하는 부분 수열                                   |
| 9095      | 1, 2, 3 더하기                                               |
| 1793      | 타일링                                                       |
| 11053     | 가장 긴 증가하는 부분 수열                                   |
| 1010      | 다리 놓기                                                    |
| 11055     | 가장 큰 증가 부분 수열                                       |
| 15988     | 1, 2, 3 더하기                                               |
| 14501     | 퇴사                                                         |
| 1463      | 1로 만들기                                                   |
| 2163      | 초콜릿 자르기                                                |
| 1932      | 정수 삼각형                                                  |
| 2225      | 합분해                                                       |
| 1149      | RGB 거리                                                     |
| 1003      | 피보나치 함수                                                |
| 9251      | LCS                                                          |
| 9465      | 스티커                                                       |
| 1730      | 판화                                                         |

<br>

<hr>

#### #2xN 타일링

[2xN 타일링 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_11726)

난 직접 그려보면서 규칙을 발견한 뒤 식을 세워 풀었지만, 그럴 필요없이 경우의 수를 생각하면 금방 풀 수 있는 문제.

타일이 2x1, 1x2 두 개의 종류만 있기 때문에 마지막에 올 수 있는 경우도 2x1 타일 하나 혹은 1x2 타일 2개만 올 수 있다.  

마지막에 2x1 타일이 왔을 경우, **나머지 타일의 개수는 n-1**

1x2 타일이 왔을 경우, **나머지 타일의 개수는 n-2**

✔ 따라서 점화식은 dp[n] = dp[n - 1] + dp[n- 2]. 피보나치 수와 똑같은 식이 나오게 된다.

<br>

<hr>

#### #2xN 타일링2

[2xN 타일링2 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_11727)

2xN 타일링과 유사한 문제. 타일이 2x1, 1x2, 2x2 세 개의 종류가 있다. 마지막 위치에도 이 3개의 타일 중 하나가 올 수 있다.

마지막에 2x1,타일이 왔을 경우, **나머지 타일의 개수는 n-1**

1x2, 2x2 타일이 왔을 경우, **나머지 타일의 개수는 (n-2) * 2**

✔ 따라서 점화식은 dp[n] = dp[n - 1] + dp[n- 2] * 2

문제 조건에 따라 큰 수가 나올 수 있기 때문에 10007로 모듈러 연산을 해야 한다.

<br>

<hr>

#### #이친수

[이친수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_2193.java)

이 문제도 규칙을 발견하기 위해 직접 자릿수가 1개일 때, 2개일 때 등을 구한 뒤 식을 세워 풀었다.

이친수는 2가지 중요한 규칙이 있다.

1. 0으로 시작하지 않는다.
2. 1이 연속하지 않는다.

이 규칙들을 적용하면, n번째 자리에 0이 올 때 n-1번째 자리에 0이나 1이 와도 상관 없지만 n번째 자리에 1이 오면 무조건 0이 와야 하기 때문에 dp[n-2]를 더하면 된다.

✔ 따라서 점화식은 dp[n] = dp[n - 1] + dp[n - 2]

결과값이 크기 때문에 int형이 아닌 long형을 줘야 하는 것도 주의해야 한다.

<br>

<hr>

#### #오르막 수

[오르막 수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11057.java) 

앞의 수가 0이 나올 수 있고, 뒤에 있는 수는 오르막 수여야 하기 때문에 같거나 커야 한다는 게 이 문제의 핵심이다.

dp 배열을 2차원 배열로 선언해 자릿수와 뒤에 올 수 있는 수(0~9)를 인덱스로 해서 문제를 풀면 된다.

1. 값을 입력 받는다.
2. 자릿수를 올리는 for문 안에 경우의 수(0 ~ 9) for문이 위치한다. 0이 오면 0 ~ 9까지, 1이 오면 1~ 8까지 경우를 다 합해줘야 하기 때문에 안에 또 하나의 for문을 만들어 3중 반복문을 만든다.

3. dp[구하고자 하는 자릿수] [0 ~ 9]를 모두 더한다.

<br>

<hr>

#### #계단 오르기

[계단 오르기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_2579.java)

계단 오르기 문제 조건

1. 한 계단이나 두 계단을 동시에 오를 수 있다.
2. 단, 3개의 계단을 연속으로 밟을 수는 없다.
3. 마지막 계단은 반드시 밟아야 한다.



이 조건들을 충족하기 위해서 현재 n번째 계단일 때 dp[n]을 구하기 위해서는

1. n - 2번째 계단을 밟은 경우(즉, 두 계단을 오른 경우) = dp[n - 2]
2. n - 1번째 계단을 밟은 경우(즉, 한 계단을 오른 경우이며 연속으로 밟을 수는 없기 때문에 n - 1 계단의 전전 계단을 고려해야 한다) = dp[n - 3] + stair[n - 1]

이 값들 중 큰 값을 구해 현재 계단 점수를 더하면 된다.

✔ 점화식 dp[n] = stair[n] + Math.max(dp[n - 2] , dp[n - 3] + stair[n - 1])

<br>

<hr>

#### #파도반 수열

[파도반 수열 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_9461.java)

문제에 이미 문제를 해결하기 위한 규칙이 나열돼 있어서 쉽게 풀었던 문제😏

P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9 < 이 규칙을 자세히 보면 dp[4] = dp[1] + dp[2]라는 점을 알 수 있다. 나머지도 다 같은 규칙을 따르고 있다.

따라서 1부터 3까지의 dp 배열은 1로 초기화 해준 뒤, 4부터 값을 구하면 된다.

✔ 점화식은 dp[n] = dp[n - 3] + dp[n - 2]

<br>

<hr>

#### #연속합

[연속합 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_1912.java)

어려운 문제도 아니었는데 풀고 나서는 자존감이 올라갔던 문제😎

이 문제는 dp를 n번째 인덱스에서 arr[n]과 dp[n - 1] + arr[n]의 최댓값을 구해서 풀면 된다. (음수가 있기 때문에 합이 항상 큰 값을 나타내는 것은 아니다)

✔ 점화식은 dp[n] = Math.max(arr[n], dp[n - 1] + arr[n])

 
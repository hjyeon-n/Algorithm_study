# BFS / DFS 문제

### BFS와 DFS로 푼 문제

| 문제 번호 | 이름                                  |
| --------- | ------------------------------------- |
| [1012](https://www.acmicpc.net/problem/1012)      | [유기농 배추](#유기농-배추)           |
| [2667](https://www.acmicpc.net/problem/2667)      | [단지 번호 붙이기](#단지-번호-붙이기) |
| [10026](https://www.acmicpc.net/problem/10026)     | [적록색약](#적록색약)                 |
| [2606](https://www.acmicpc.net/problem/2606)      | [바이러스](#바이러스)                 |

<br>

### BFS로 푼 문제

| 문제 번호 | 이름                    |
| --------- | ----------------------- |
| [2178](https://www.acmicpc.net/problem/2178)      | [미로 탐색](#미로-탐색) |
| [7576](https://www.acmicpc.net/problem/7576)      | [토마토](#토마토)       |

<br>

### DFS로 푼 문제

| 문제 번호 | 이름                                  |
| --------- | ------------------------------------- |
| [11724](https://www.acmicpc.net/problem/11724)     | [연결 요소의 개수](#연결-요소의-개수) |

<br>

<hr>

#### #유기농 배추

[유기농 배추 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_1012 ) 🥬

단지 번호 붙이기와 유사한 문제.  2차원 배열인 map을 생성해 0은 배추가 심어져 있지 않은 땅, 1은 배추가 심어져 있는 땅을 나타낸다. boolean 타입의 visited 배열을 생성해 map 방문 여부를 표시한다. 

1. map을 for문으로 돌면서 배추가 있고, 아직 방문하지 않은 지점에 대해 BFS(DFS)를 수행하면서 영역의 수를 카운트해 준다. 
2. 해당 영역의 탐색이 끝나면 다시 메인 함수의 for문으로 돌아감
3.  리스트 형태로 카운트한 수를 추가한 후 출력하면 된다.

<br>

<hr>

#### #단지 번호 붙이기

[단지 번호 붙이기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_2667  ) 🏡

처음으로 풀었던 DFS, BFS 문제. 처음엔 어려워서 자괴감이 들었지만 지금은 얼추 해낸다💦

2차원 배열인 map을 생성해 0은 집이 없는 곳, 1은 집이 있는 곳을 나타낸다. boolean 타입의 visited 배열을 생성해 map 방문 여부를 표시한다. 

1. map을 for문으로 돌면서 집이 있고, 아직 방문하지 않은 지점에 대해 BFS(DFS)를 수행하면서 영역의 수를 카운트해 준다. 
2. 해당 영역의 탐색이 끝나면 다시 메인 함수의 for문으로 돌아감
3.  리스트 형태로 카운트한 수를 추가한 후 출력하면 된다.

<br>

<hr>

#### #적록색약

[적록색약 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_10026   ) 👀

개인적으로 자존감 올려주는 고마운 문제였다🌞

이 문제는 다른 것보다 배열 입력 시에 주의해야 한다. charAt을 사용해 String을 char 원소 하나하나로 쪼개서 받아야 한다.

1. 적록색약이 아닌 사람은 cnt, 적록색약인 사람은 cnt_RG로 나눠 전역변수로 선언
2. boolean 타입의 visited 배열을 선언하고 false로 초기화
3. 방문하지 않은 곳에 대해 BFS(DFS) 수행
4. 적록색약이 아닌 사람부터 cnt 출력
5. 다시 visted를 초기화한 뒤 BFS 수행
6. 적록색약인 사람 cnt_RG 출력

<br>

<hr>

#### #바이러스

[바이러스 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_2606) 😈

무방향 그래프이기 때문에 map[x] [y] 뿐만 아니라 map[y] [x]도 같이 표시해야 한다. 그 외에는 이제까지 풀었던 BFS, DFS 문제와 달리 visted 배열이 일차원인 점을 제외하고는 딱히 어려운 문제는 아니었다.

1. 값을 입력 받고 map을 초기화해 준다.
2. 컴퓨터의 수를 구하기 위해 선언한 cnt 변수를 0으로 초기화 한다.
3. 1번 컴퓨터부터 전파되는 것이기 때문에 시작은 1로 한다.
4. n번 만큼의 반복문을 돌면서 1번 컴퓨터와 연결돼 있고, 방문하지 않은 컴퓨터를 찾고 큐에 넣는다.

<br>

<hr>

#### #미로 탐색

[미로 탐색 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_2178.java) 😣

가장 기본적인 BFS 문제. 하지만 처음엔 BFS를 직접 구현해 본 적이 없어서 많이 어려웠다.😫

최단 경로를 구해야 하기 때문에 DFS가 아니라 BFS를 이용해야 한다 [참고]([https://velog.io/@skyepodium/BFS%EB%8A%94-%EB%82%AF%EC%84%A4%EC%96%B4%EC%84%9C](https://velog.io/@skyepodium/BFS는-낯설어서))

1. 값을 입력 받고 map을 초기화한다.
2. BFS를 시작하는데, 처음은 1,1 로 시작한다.
3. 영역이 벗어나지 않는 선에서 상하좌우를 보면서 값이 1이고 방문하지 않았으면 방문한 뒤 큐에 넣어준다. map의 값도 현재 기준이 되는 map의 값에 +1을 해준다.
4. 3번의 과정을 큐가 완전히 비워질 때까지 반복한다.
5. map[n] [m]값이 결과값이 된다.

<br>

<hr>

#### #토마토

[토마토 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_7576.java) 🍅

7569번의 [토마토](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_7569.java)의 이차원 배열 버전 문제이다. 한 마디로 더 쉬움!

이 문제는 단순히 BFS 뿐만 아니라 토마토가 이미 익어있는 상황, 다 익을 수 없는 상황을 고려해야 한다.

다 익을 때까지의 최소 날짜를 출력해야 하기 때문에 visited 배열은 단순히 boolean 타입이 아니라 일자를 저장해야 하기 때문에 int형으로 선언해야 한다. 그리고 BFS를 돌 때마다 해당 visited 값에 + 1을 해준다.

1. 전부 익은 토마토가 나올 수 있기 때문에 flag 변수를 1로 둔다.
2. 토마토를 입력 받으면서 토마토가 전부 1인지를 검사한다. 만약 하나라도 1이 아니면 flag 변수를 0으로 초기화한다.
3. 입력이 끝난 후, flag 변수를 확인해 1이면 0을 출력하고 return한다.
4. 반복문을 돌면서 익은 토마토의 위치를 찾아낸 뒤 BFS 한다.
5. BFS 함수에서 상하좌우를 돌면서 방문한 적이 없는 익지 않은 토마토를 발견했을 때, 이를 큐에 넣어주고 해당 visted 값에 + 1을 해준다.
6. 큐가 비워질 때까지 5번의 과정을 반복한다.
7. BFS가 전부 끝이 나면 visited 배열을 확인해 방문하지 않은 점이 있는지 검사하고 해당 위치의 map에서 익지 않은 토마토가 있으면 모든 토마토가 익은 것은 아니기 때문에 0을 출력하고 끝낸다.
8. 토마토가 전부 익었으면, visited 배열에서 최댓값을 확인하고 이를 출력한다.

<br>

<hr>

#### #연결 요소의 개수

[연결 요소의 개수 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11724.java) 👣

무방향 그래프이기 때문에 map[x] [y] 뿐만 아니라 map[y] [x]에도 연결 여부를 표시해야 한다.

1. 값을 입력 받고 무방향 그래프인 점을 주의해서 map[x] [y]와 map[y] [x]에 연결 여부를 1로 표시한다.
2. n 만큼 돌면서 방문하지 않은 정점이 있는지 확인하고 방문하지 않았을 때에 연결 요소의 개수를 세는 cnt를 증가시켜주고 DFS 한다.
3. DFS는 방문 여부를 표시해 주고, 해당 정점에서 다른 정점 사이에 연결 여부를 확인하기 위해 반복문을 돌면서 방문 여부와 연결 여부를 확인한다.
4. 이 과정이 전부 끝나면 cnt를 출력한다.

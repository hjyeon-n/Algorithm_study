# Greedy Algorithm

| 문제 번호 | 이름                        |
| --------- | --------------------------- |
| 11399     | [ATM](#ATM)                 |
| 11047     | [동전 0](#동전-0)           |
| 1931      | [회의실 배정](#회의실-배정) |
| 5585      | 거스름돈                    |
| 2217      | 로프                        |
| 2812      | 크게 만들기                 |
| 1092      | 배                          |

<br>

<hr>

#### #ATM

[ATM 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11399.java  )

자존감 올려주는 문제💪

사람이 돈을 인출하는 데 필요한 시간의 합의 최솟값을 구하기 위해서는 시간이 적게 걸리는 사람 순으로 정렬을 하면 된다.

1. 사람 수와 걸리는 시간을 입력 받기

2. 소요 시간을 배열에 저장한 뒤 정렬

3. 앞사람의 걸리는 시간만큼 더해줘야 하기 때문에 sum 배열을 선언

4. 두 번째 사람의 소요 시간(sum[1]) = 첫 번째 사람의 소요 시간(sum[0]) + 두 번째 사람의 소요시간(arr[1])<br>

   세 번째 사람의 소요 시간(sum[2]) = 두 번째 사람의 소요시간(sum[1]) + 세 번째 사람의 소요시간(arr[2]) <br>

   ... <br>

   이런 식의 논리가 전개되도록 loop 짜기

5. 최종값인 rslt는 sum의 값을 더하면 구할 수 있다.

<br>

<hr>

#### #동전 0

[동전 0 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11047.java )

최소의 동전을 사용해 그 값을 k원으로 만들기 위해서는 가치가 높은 동전을 이용하면 된다.

1. 오름차순으로 입력을 받아 배열에 저장
2. 배열의 가장 끝 원소가 가장 가치가 높은 동전이기 때문에 역순으로 계산
3. 동전의 개수를 구하기 위해 k원을 동전의 가치만큼 나눠 그 몫을 동전의 수를 세는 rslt에 더해줌
4. k원을 앞서 구한 동전의 가치만큼 제외해야 하기 때문에 3번의 나머지로 k를 다시 초기화

<br>

<hr>

#### #회의실 배정

[회의실 배정 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_1931.java   )

문제를 잘 읽어야 한다. '최대 사용할 수 있는 회의의 최대 개수'를 구해야 하기 때문에 시작시간이나 소요 시간을 기준으로 정렬하는 것이 아니라 끝나는 시간을 기준으로 정렬해야 회의를 최대한 많이 할 수 있다.

무엇보다 Comparator를 사용해 한 인덱스를 기준으로 다른 인덱스의 값들을 정렬하는 게 가장 어려웠다...😫



1. 시작 시간과 끝나는 시간을 각각 arr1[], arr2[]에 입력 받는다.
2. 종료 시간이 같을 경우 시작시간으로 정렬하고, 그렇지 않으면 종료 시간 기준으로 정렬한다.
3. 정렬 후, 종료 시간과 다음의 시작 시간을 비교
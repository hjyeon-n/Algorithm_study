# Data Structure

| 문제 번호 | 이름      |
| --------- | --------- |
| 2493      | [탑](#탑) |

<br>

<hr>

#### #탑

[탑 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.10/Solution_2493)

시간초과가 날 것 같긴 했지만 처음에는 완전탐색으로 풀었다. 물론 예상대로 시간초과가 났고, 스택을 사용해서 문제를 다시 풀었다.

처음에는 스택을 뭐 어떡하라고? 했는데 다른 사람의 아이디어를 봤더니 금방 이해하고 풀었다.

처음 푼 버전은 더 생각해 보기 싫어서 대충 짰더니 중복 코드가 조금 있어서 다시 고쳐 푼  두 번째 버전도 같이 올려두었다.😊

<br>

문제의 아이디어는 간단하다. 왼쪽으로 신호를 쏘고 현재 신호를 쏜 탑보다 큰 탑을 발견하면 더 볼 필요도 없이 그 탑이 신호를 수신하게 된다. 이 말은 **결국 첫 번째 탑이 두 번째 탑보다 작다면 어차피 N번째 탑에서 쏘는 신호는 첫 번째 탑과 상관없이 두 번째 탑이 신호를 수신하게 된다는 것이다.** 그러면 첫 번째 탑은 고려대상이 아니므로 스택에서 아예 pop하면 된다. 만약 이해가 안 된다면 [이 풀이를 참고!](https://m.blog.naver.com/gkfla1017/221583283807) 

<br>

1. 값을 입력 받는다.
2. 스택은 별도의 인덱스가 없기 때문에 Point라는 별도의 클래스를 선언해 값과 인덱스 값을 함께 저장할 수 있도록 한다.
3. 배열의 크기만큼 반복문을 돌면서 수신되는 탑을 찾는다.
4. 만약 스택이 비어있지 않으면 스택의 첫 번째 값과 현재 값을 비교한다.
5. 만약 스택의 값이 더 크다면 그 값이 수신 받을 탑이기 때문에 탑의 인덱스를 출력한다. 또한 탑을 오른쪽으로 세워나가는 과정이기 때문에 그 탑의 값도 스택에 삽입한다. 예를 들어 현재 값이 5고 스택에 있던 값이 9라면 5도 삽입해서 9와 5로 만들어준다. 이 이유는 만약 3이라는 값이 들어왔을 땐 가장 처음되는 수신될 탑이 9가 아니라 5가 돼야 하기 때문이다.
6. 스택의 값이 작다면 pop해준다. 
7. 스택의 값이 비어있다면 현재 값을 넣어주고 수신 받을 탑은 존재하지 않았기 때문에 0을 출력한다.
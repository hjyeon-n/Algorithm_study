# BFS, DFS

#### BFS, DFS로 푼 문제

| 문제 번호 | 이름                                  |
| --------- | ------------------------------------- |
| 11725     | [트리의 부모 찾기](#트리의-부모-찾기) |

<br>

#### BFS로 푼 문제

| 문제 번호 | 이름                         |
| --------- | ---------------------------- |
| 14503     | [로봇 청소기](#로봇-청소기)⭐ |

<br>

#### DFS로 푼 문제

| 문제 번호 | 이름                    |
| --------- | ----------------------- |
| 15686     | [치킨 배달](#치킨-배달) |

<br>

<hr>

#### #트리의 부모 찾기

[트리의 부모 찾기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.10/Solution_11725)

평소에 인접행렬로 풀다가 인접 리스트로 풀었다. 사실 인접행렬로 풀면 런타임 에러가 난다.😜

그럼에도 시간이 오래 걸리길래 평소에 쓰던 `System.out.print`대신에 `StringBuffer`나 `BufferedWriter`를 써봤다. `StringBuffer` 속도가 더 빠르기 때문에 코드엔 `StringBuffer` 로 사용했다. 해설은 DFS 방법으로 설명하겠다.

<br>

1. ArrayList를 2차원 리스트로 만들어주기 위해 ArrayList<ArrayList< Integer>>의 형식으로 선언한다.
2. 반복문을 통해서 입력을 받으면서 부모 리스트에는 자식 노드를 추가하고, 자식 리스트에도 부모 노드를 추가한다.
3. 1이 루트 노드이기 때문에 1부터 탐색을 시작한다.
4. 1이랑 인접한 노드를 방문하기 위해서 정점 1에 대한 인접 리스트에서 노드를 하나씩 꺼낸 뒤, 방문 여부를 표시하고 answer를 채운다.
5. 4번의 과정을 끝낸 뒤, answer를 출력한다.

<br>

<hr>

⭐⭐⭐⭐⭐

#### #로봇 청소기

[로봇 청소기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_14503.java)

기본적으로 삼성 SW 기출 문제는 실제 문제에 비해 난이도가 낮게 잡혀있는 것 같다😂 체감 골드4였는데...🙄

예전부터 풀려고 시도는 했었으나, 문제가 너무 이해가 되지 않았다. 특히 이 부분... "왼쪽 방향에 청소할 공간이 없다면, **그 방향**으로 회전하고 2번으로 돌아간다." 대체 그 방향이 무엇인가... 질문 목록을 보고 나서야 왼쪽이라는 걸 알았다. 아니 어째서...😖

산 넘어 산이라고 방향 전환이 정말정말 헷갈렸다... 어렵진 않았는데 한 번 잘못 잡았더니 혼동돼서 제대로 잡느라 힘들었다.

처음엔 접근조차 힘들어서 다른 사람 풀이를 좀 봤고, 세부적인 사항은 직접 짜려고 노력했다.

```
1. 현재 위치를 청소한다.
2. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
	a.왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
	b.왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
	c.네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
	d.네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
```

<br>

1. 입력을 받고, 문제에서 명시한 시작점부터 BFS를 시작한다.
2. 현재 방향을 기준으로 왼쪽 방향을 봐야한다. 이 부분은 turnDirection 함수에서 처리한다.
3. turnDirection에서는 북쪽(0)일 때는 서쪽(3)을 반환하고, 동쪽(1)일 때는 동쪽의 방향을 기준으로 서쪽이 되는 남쪽(2)를 반환하는 방식이다. 이때 탐색을 진행하기 위해 반환값은 dx와 dy의 인덱스로 작동한다. 즉 3을 반환하면 서쪽이 되도록 dx[3] = 0, dx[3] = -1이 되도록 dx, dy 배열을 전역 변수로 선언한다. (이 지점이 가장 오래 걸렸다.😢)
4. 만약 아직 방문하지 않았고 (즉, 청소하지 않음) 벽이 아니라면 turnDirection에서 반환된 값을 방향으로 해서 전진한다.
5. 4번의 과정은 반복문으로 진행되는데, 만약 서쪽의 값이 벽이거나 청소를 이미 했다면 b의 과정을 거치기 위해 회전을 해야 하기 때문이다. 만약 왼쪽 방향에 청소할 곳을 찾는다면 반복문에서 빠져나오기 위해 break를 하면 된다.
6. flag 변수를 통해 c를 구현하면 되는데, 마찬가지로 4번의 반복문 안에서 청소할 곳을 발견하면 flag를 true값으로 바꿔주면 되고, 만일 그렇지 않다면 네 방향 모두 청소가 되었거나 벽인 경우, 즉,  c의 조건이 성립된다.
7. flag가 false이면 바라보는 방향을 유지한 채로 후진해야 하기 때문에 goBack이라는 함수를 호출해 후진할 경우 변경될 좌표 값을 만들고, 큐에는 현재 방향 d를 그대로 삽입한다.
8. goBack이라는 함수는 현재 방향이 북인 경우, dx가 1, dy가 0인 경우의 인덱스를 반환하면 된다. 예를 들어, 이 경우에는 2를 반환하면 된다.
9. 큐가 빌 때까지 위 과정들을 진행하면서, 더 이동할 수 없기 때문에 d는 자연스럽게 구현된다. 

<br>

<hr>

#### #치킨 배달

[치킨 배달 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_15686.java)

예에에전에 북마크에 담아두었다가 이제야 풀었다. 🧐 다행히 어려움 없이 처음 생각한대로 잘 풀렸다. 난이도는 체감 실버 1정도?

<br>

1. 빈 칸을 무시하기 위해 집과 치킨집의 좌표를 담을 리스트를 각각 선언하고, 입력값이 1이면 home 리스트에, 2이면 chicken 리스트에 각각 담는다.
2. DFS 백트래킹을 이용해서 조합의 값을 구한다. 이때 조합의 결과값은 chicken의 인덱스 값이 된다.
3. 만약 수를 다 뽑았다면,  집 하나를 기준으로 어떤 치킨집이 더 가까운지 치킨 거리를 세야 하기 때문에 home 리스트 길이만큼 반복문을 돌면서 home의 좌표를 기준으로 다시 중첩 반복문으로 조합의 결과값으로 구한 chicken의 좌표를 구해 거리를 구한다. 
4. 이때 거리가 짧은 게 치킨 거리가 되기 때문에 정수의 최댓값으로 초기화한 min_chicken과 비교한 뒤, 작은 값을 min_chicken에 입력한다.
5. 한 집에 대해서 치킨 거리를 구한 후, sum 값에 합한다. 이 과정을 모든 집마다 다 거친다.
6. sum 값을 전역 변수로 선언된 min과 비교 후, 작은 값을 min에 넣는다.
7. 메인으로 돌아와서 min을 출력한다.

 
# BFS, DFS

#### BFS, DFS로 푼 문제

| 문제 번호 | 이름                      |
| ----- | ----------------------- |
| 11725 | [트리의 부모 찾기](#트리의-부모-찾기) |
| 2573  | [빙산](#빙산)               |

<br>

#### BFS로 푼 문제

| 문제 번호 | 이름                                |
| ----- | --------------------------------- |
| 14503 | [로봇 청소기](#로봇-청소기)⭐                |
| 14226 | [이모티콘](#이모티콘)                     |
| 1389  | [케빈 베이컨의 6단계 법칙](#케빈-베이컨의-6단계-법칙) |
| 6593  | [상범 빌딩](#상범-빌딩)                   |
| 2660  | [회장뽑기](#회장뽑기)                     |

<br>

#### DFS로 푼 문제

| 문제 번호 | 이름                    |
| ----- | --------------------- |
| 15686 | [치킨 배달](#치킨-배달)       |
| 14500 | [테트로미노](#테트로미노)⭐      |
| 14888 | [연산자 끼워넣기](#연산자-끼워넣기) |

<br>

<hr>

#### #트리의 부모 찾기

[트리의 부모 찾기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.10/Solution_11725)

평소에 인접행렬로 풀다가 인접 리스트로 풀었다. 사실 인접행렬로 풀면 런타임 에러가 난다.😜

그럼에도 시간이 오래 걸리길래 평소에 쓰던 `System.out.print`대신에 `StringBuffer`나 `BufferedWriter`를 써봤다. `StringBuffer` 속도가 더 빠르기 때문에 코드엔 `StringBuffer` 로 사용했다. 해설은 DFS 방법으로 설명하겠다.

<br>

1. ArrayList를 2차원 리스트로 만들어주기 위해 ArrayList<ArrayList< Integer>>의 형식으로 선언한다.
2. 반복문을 통해서 입력을 받으면서 부모 리스트에는 자식 노드를 추가하고, 자식 리스트에도 부모 노드를 추가한다.
3. 1이 루트 노드이기 때문에 1부터 탐색을 시작한다.
4. 1이랑 인접한 노드를 방문하기 위해서 정점 1에 대한 인접 리스트에서 노드를 하나씩 꺼낸 뒤, 방문 여부를 표시하고 answer를 채운다.
5. 4번의 과정을 끝낸 뒤, answer를 출력한다.

<br>

<hr>

⭐⭐⭐⭐⭐

#### #로봇 청소기

[로봇 청소기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_14503.java)

기본적으로 삼성 SW 기출 문제는 실제 문제에 비해 난이도가 낮게 잡혀있는 것 같다😂 체감 골드4였는데...🙄

예전부터 풀려고 시도는 했었으나, 문제가 너무 이해가 되지 않았다. 특히 이 부분... "왼쪽 방향에 청소할 공간이 없다면, **그 방향**으로 회전하고 2번으로 돌아간다." 대체 그 방향이 무엇인가... 질문 목록을 보고 나서야 왼쪽이라는 걸 알았다. 아니 어째서...😖

산 넘어 산이라고 방향 전환이 정말정말 헷갈렸다... 어렵진 않았는데 한 번 잘못 잡았더니 혼동돼서 제대로 잡느라 힘들었다.

처음엔 접근조차 힘들어서 다른 사람 풀이를 좀 봤고, 세부적인 사항은 직접 짜려고 노력했다.

```
1. 현재 위치를 청소한다.
2. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
    a.왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
    b.왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
    c.네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
    d.네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
```

<br>

1. 입력을 받고, 문제에서 명시한 시작점부터 BFS를 시작한다.
2. 현재 방향을 기준으로 왼쪽 방향을 봐야한다. 이 부분은 turnDirection 함수에서 처리한다.
3. turnDirection에서는 북쪽(0)일 때는 서쪽(3)을 반환하고, 동쪽(1)일 때는 동쪽의 방향을 기준으로 서쪽이 되는 남쪽(2)를 반환하는 방식이다. 이때 탐색을 진행하기 위해 반환값은 dx와 dy의 인덱스로 작동한다. 즉 3을 반환하면 서쪽이 되도록 dx[3] = 0, dx[3] = -1이 되도록 dx, dy 배열을 전역 변수로 선언한다. (이 지점이 가장 오래 걸렸다.😢)
4. 만약 아직 방문하지 않았고 (즉, 청소하지 않음) 벽이 아니라면 turnDirection에서 반환된 값을 방향으로 해서 전진한다.
5. 4번의 과정은 반복문으로 진행되는데, 만약 서쪽의 값이 벽이거나 청소를 이미 했다면 b의 과정을 거치기 위해 회전을 해야 하기 때문이다. 만약 왼쪽 방향에 청소할 곳을 찾는다면 반복문에서 빠져나오기 위해 break를 하면 된다.
6. flag 변수를 통해 c를 구현하면 되는데, 마찬가지로 4번의 반복문 안에서 청소할 곳을 발견하면 flag를 true값으로 바꿔주면 되고, 만일 그렇지 않다면 네 방향 모두 청소가 되었거나 벽인 경우, 즉,  c의 조건이 성립된다.
7. flag가 false이면 바라보는 방향을 유지한 채로 후진해야 하기 때문에 goBack이라는 함수를 호출해 후진할 경우 변경될 좌표 값을 만들고, 큐에는 현재 방향 d를 그대로 삽입한다.
8. goBack이라는 함수는 현재 방향이 북인 경우, dx가 1, dy가 0인 경우의 인덱스를 반환하면 된다. 예를 들어, 이 경우에는 2를 반환하면 된다.
9. 큐가 빌 때까지 위 과정들을 진행하면서, 더 이동할 수 없기 때문에 d는 자연스럽게 구현된다. 

<br>

<hr>

#### #치킨 배달

[치킨 배달 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_15686.java)

예에에전에 북마크에 담아두었다가 이제야 풀었다. 🧐 다행히 어려움 없이 처음 생각한대로 잘 풀렸다. 난이도는 체감 실버 1정도?

<br>

1. 빈 칸을 무시하기 위해 집과 치킨집의 좌표를 담을 리스트를 각각 선언하고, 입력값이 1이면 home 리스트에, 2이면 chicken 리스트에 각각 담는다.
2. DFS 백트래킹을 이용해서 조합의 값을 구한다. 이때 조합의 결과값은 chicken의 인덱스 값이 된다.
3. 만약 수를 다 뽑았다면,  집 하나를 기준으로 어떤 치킨집이 더 가까운지 치킨 거리를 세야 하기 때문에 home 리스트 길이만큼 반복문을 돌면서 home의 좌표를 기준으로 다시 중첩 반복문으로 조합의 결과값으로 구한 chicken의 좌표를 구해 거리를 구한다. 
4. 이때 거리가 짧은 게 치킨 거리가 되기 때문에 정수의 최댓값으로 초기화한 min_chicken과 비교한 뒤, 작은 값을 min_chicken에 입력한다.
5. 한 집에 대해서 치킨 거리를 구한 후, sum 값에 합한다. 이 과정을 모든 집마다 다 거친다.
6. sum 값을 전역 변수로 선언된 min과 비교 후, 작은 값을 min에 넣는다.
7. 메인으로 돌아와서 min을 출력한다.

<br>

<hr>

#### #이모티콘

[이모티콘 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_14226.java) 😊

처음에는 Bottom-up 방식의 DP로 풀려고 규칙을 찾아내려고 했다. 근데 생각해 보니 복사, 붙여넣기, 제거의 3가지 행동만 해야 한다는 문제의 룰에서 벗어난 방법까지 생각하려고 했던 것 같다... 어쨌든 DP로 어떻게 문제를 풀지 감이 잘 잡히지 않았고, 문제 라벨이 그래프 이론이길래 어떻게 푼다는 거지...? 하고 풀이를 먼저 참고했었다.

지도가 대놓고 그려져있는 문제나 경로를 찾는 문제 등은 바로 BFS로 풀어야겠다고 가닥이 잡히는데 이런 문제들은 바로 방법이 생각나지 않는다... 😥 좀 더 많은 문제를 풀고 연습해야지.

<br>

최소시간을 구해야 하기 때문에 BFS를 사용해야 하고, 여러 가지 경우의 수가 나올 수 있고 반복될 수도 있기 때문에 visited 방문 배열을 선언해 중복을 없애야 한다. 그리고 나머지는 직관적으로 문제에 주어진 조건에 따르면 쉽게 풀 수 있다.

1. visited 이차원 배열을 선언할 때, 첫 번째 인덱스에는 화면에 출력된 개수, 두 번째 인덱스에는 복사된 개수라고 생각해서 문제에 접근해야 한다.
2. 출력 개수, 복사된 개수, 해당 시간을 저장할 Emoji 객체를 선언하고, 이 타입의 큐를 선언한다.
3. 탐색 초기 값은 문제에 주어진대로, 이미 출력된 하나의 개수를 고려해 (1, 0, 0)에 해당하는 객체 값을 큐에 넣어주고, visited[1] [0]에 방문 여부를 표시한다.
4. 만약, 큐에서 꺼낸 값의 display가 S와 같을 땐 원하는 결과를 얻은 것이므로 time을 출력하고 끝낸다.
5. 복사할 경우, 일부 복사가 불가하기 때문에 copy의 값은 display가 될 것이다. 해당 정점에 대해 방문 여부를 확인하고 큐에 삽입한다.
6. 붙여넣기의 경우, 현재 display 값과 copy 값이 같이 출력된다는 것인데 이때 전체 범위를 넘어가지 않는지 확인하고 마찬가지로 방문 여부를 확인한 뒤, 큐에 삽입한다.
7. 삭제의 경우, 현재 display 값에서 하나 빼줘야 한다. 이때 0보다 크거나 같은지 확인하고 방문 여부를 확인한다.
8. 4 ~ 6까지의 경우를 큐가 빌 때까지 전부 확인한다.

<br>

<hr>

#### #빙산

[빙산 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.10/Solution_2573) 🧊

왜 골드4인지 모르겠는 문제... 체감 골드5 정도였다. 처음 생각했던 방식대로 그대로 풀렸지만, 중복되는 부분이 많아서 다른 사람 풀이를 참고해서 새로 고친 버전도 같이 업로드했다. 

<br>

1. 배열을 입력을 받으면서 0이 아닌 값은 list에 add한다.
2. list의 사이즈가 0이면 전체가 0이기 때문에 바로 0을 출력하고 프로그램을 끝낸다.
3. list를 기준으로 빙하가 몇 덩어리인지 센다. 만약 ice가 2이상이면 처음부터 분리되었기 때문에 더 볼 필요 없이 0을 출력하고 끝낸다.
4. 2, 3에 조건과 맞지 않는다면 time을 0으로 초기화하고, 빙하를 녹이고 세는 과정을 반복하기 위해 while문을 사용한다.
5. map의 값이 0이 아니고 아직 방문하지 않았다면, removeIceBerg 함수를 호출한다.
6. removeIceBerg에서는 빙산을 녹여야 하기 때문에 BFS를 돌면서 상하좌우에 0이 존재하면 cnt를 증가시킨다.
7. 만약 0이 아니고 아직 방문하지 않았다면 해당 정점을 큐에 삽입한다.
8. map에 cnt를 빼서 0보다 크면 iceberg에 빙산의 위치를 표시하고, 전체 배열을 도는 대신에 list에 있는 값만 확인할 수 있도록 list에 해당 정점을 삽입한다. map에도 cnt를 뺀 값으로 갱신한다.
9. 만약 0보다 작거나 같으면, **다른 정점들도 전부 확인해야 하기 때문에 바로 0으로 갱신하지 않고**, zero 리스트에 해당 정점을 넣어 후에 zero 리스트를 돌면서 0으로 초기화해야 한다.
10. 메인으로 돌아가 zero 값들을 0으로 초기화하고, 빙산에 대해 방문 여부를 확인한 뒤, (방문하지 않았다면 0, 방문했다면 2) countIce를 호출한다.
11. countIce에서는 BFS를 돌면서 빙산을 방문한다.
12. 위의 과정은 countIce의 결과값이 2이상 즉, 빙산이 처음으로 분리될 때 혹은 빙산이 전부 녹아 0이 아닌 값이 없을 때 즉, list의 크기가 0일 때까지 반복한다.

<br>

구현할 때도 시간 초과 나는 게 아닌가 걱정했을 만큼 복잡하다. 그래서 리스트를 사용하지 않고, 처음부터 분리 여부를 판단한 뒤에 빙산을 녹이는 방식을 사용했다. 이때, 바로 녹일 순 없기 때문에 melt라는 이차원 배열을 선언해 상하좌우의 0의 개수를 저장한다.

1. BFS/DFS 방식을 사용해 덩어리가 분리되었는지 확인한다.
2. 만약 1의 결과가 2이상이면 time을 출력하고, 0이면 모든 정점이 0이라는 뜻이기 때문에 0을 출력하고 끝낸다.
3. 2번의 조건과 부합하지 않는다면 meltIce를 호출해 countIce에서 셌던 melt의 값을 이용해 빙산을 녹인다.
4. 위 과정을 반복한다.

<br>

<hr>

⭐⭐⭐⭐⭐

#### #테트로미노

[테트로미노 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_14500.java)

역시 삼성 SW 역량 테스트 기출 문제는 난이도가 너무 저평가됐다...💦 이게 어떻게 골드5지. 체감 골드4 문제였다.🤯

여러가지 경우를 생각해야 하기 때문에 백트래킹으로 문제를 풀어야 하나? 싶었다. 하지만 백트래킹으로 어떻게 모양을 만들어낼지 감이 잡히지 않았고, 하드코딩을 한다고 해도 그 모양들을 다 만들고 맵의 범위에 벗어나지 않게 어떻게 위치시켜야 할지 잘 모르겠더라. 결론적으로는... 다른 사람 풀이를 참고했다! 😢

<br>

이 문제의 관건은 회전과 대칭을 사용한 경우도 생각해야 하지만 무엇보다 **모양 'ㅗ' 등은 DFS로 풀 수 없기 때문에 다른 방법을 생각해야 한다**는 게 가장 생각하기 어려운 지점이다. 나도 풀이를 보지 않았으면 전혀 몰랐을 것 같다.

사실 여러 풀이를 봤는데 아무도 왜 저 모양이 안 되는지 설명은 없었다 (왜애애액 난 모르겠는데에엑‼) 

그러다 겨우 블로그 하나를 찾았다!

![image](https://user-images.githubusercontent.com/62419307/95337731-1e169580-08ed-11eb-8c8c-eca3bc3dc0af.png)

(2, 0)부터 DFS를 시작한다고 가정하면 다음 위치가 두 번째 사진처럼 나타날 수 있다. 이 경우 세 번째 점은 사진 4개처럼 여러가지 경우가 올 수 있다. 다만 'ㅗ' 모양은 depth가 최대 3이기 때문에 따로 고려해야 한다! [출처](https://hyeooona825.tistory.com/60)

<br>

'ㅗ' 모양에 대해서 여러 풀이가 있었지만, 하드코딩 방식이나 날개(?)를 잘라내는 방식은 생소해서 [이 블로그](https://velog.io/@skyepodium/%EB%B0%B1%EC%A4%80-14500-%ED%85%8C%ED%8A%B8%EB%A1%9C%EB%AF%B8%EB%85%B8)를 참고했다.

ex, ey의 이차원 좌표를 미리 정의하여 차례대로 'ㅜ', 'ㅏ', 'ㅗ', 'ㅓ' 모양을 만들 수 있도록 했다. 이 좌표들을 더해서 값을 만드는 게 아니라 인덱스 즉, 위치를 잡는다고 생각하면 이해하기 쉽다. 물론 디버깅까지 해서 확인도 했다.

요약하자면,

1. DFS 백트래킹으로 (DFS는 재귀 즉, 일종의 스택이기 때문에 이전값으로 돌아오는 것이 가능하다) depth가 4인 경우, 최댓값을 구한다. (조합을 생각하면 쉽다.)

2. 예외 모양에 대해 따로 ex, ey를 통해 범위가 넘어서지 않는 한에서 합을 구해 max와 비교한 후 최댓값을 갱신한다.

3. 최댓값 max를 출력한다.
   
   <br>

<hr>

#### #케빈 베이컨의 6단계 법칙

[케빈 베이컨의 6단계 법칙](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_1389.java)

오랜만에 실버 문제를 풀었다! 그래서 아주 쉽게 풀었다😜 굳이 따지자면 [바이러스](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.07/Solution_2606) 문제와 비슷하다. 

사실 풀이 쓰기도 민망하다...😂

<br>

1. 모든 정점에 대해서 케빈 베이컨의 합을 구해야 하기 때문에 정점의 수만큼 반복문을 돌려 BFS를 수행한다.
2. BFS가 끝나면 정점에 대한 visited 배열의 합을 더해 min 값과 비교한다. 만약 min 값보다 작으면 min 값을 갱신해 주고 idx도 현재 i의 값으로 갱신한다.
3. idx를 출력한다.

<br>

<hr>

#### #상범 빌딩

[상범 빌딩 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_6593.java) 🏢

📌 [2023.01.10 업데이트](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2023.01/Solution_6593.java)

오랜만엔 푸는 3차원 BFS 문제였다. 이번엔 토마토 문제를 풀기 전에 풀었고 이전에 풀었던 방식이랑 크게 다르지 않았는데 자꾸 틀렸다고 나와서 뭐지 싶었다... 😕

저번에 말했던 것처럼 이 문제는 입력이 까다롭고 문제 풀이 자체는 어렵지 않다. 3차원이라서 골드5인 듯... 3차원일 땐 이동할 때 사용하는 dx 배열을 확장하는 법만 알아두자.

<br>

<u>✍ 이전에 작성한 풀이!</u>

3차원 BFS 문제다. [토마토](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.08/Solution_7569.java)와 비슷한 문제. 오랜만에 알고리즘 문제를 풀려고 하다보니 막혀서 다른 사람 풀이를 대충 봤는데 그냥 혼자 풀 수 있을 것 같아서 얼렁뚱땅 풀었다! 🤗

사실, 이 문제의 키 포인트는 입력 부분이다. 입력값이 0 0 0 일 때 입력을 멈추도록 하는 건 다른 문제에서도 간혹 있는데 입력 값을 줄간격으로 구분하는 건 조금 생소했다. 이럴 경우 그냥 br.readLine으로 읽어주되 사용하지 않고 넘기면 된다.

<br>

1. 입력을 받는다.
2. 이때 S의 값은 큐에 넣어주고, E의 값은 end라는 별도의 객체를 만들어 따로 저장한다.
3. BFS 탐색을 한다. 이때 3차원 배열이기 때문에 상하좌우 뿐만 아니라 다른 층도 신경 써줘야 하기 때문에 탐색 범위는 4에서 6으로 늘어난다.
4. 만약 map의 범위에서 벗어나지 않는 조건에서 빈 칸이거나 E일 때 아직 방문하지 않았다면 주소값을 큐에 넣어준다. 이때 방문 여부를 갱신하기 위해서는 h, x, y의 값에서 1만큼 더해준 값으로 갱신한다.
5. 만약 큐에서 나온 좌표가 end에 저장한 값과 같을 때 더 볼 필요도 없으므로 visited에서 현재 좌표값에 해당하는 값을 이용해 출력하고 true를 반환한다.
6. 만약 5번과 같은 결과가 나오지 않는다면 반환값은 false가 될 것이고 그러면 결국 도착지점까지 도달할 수 없었다는 의미이므로 Trapped를 출력하면 된다.

<br>

<hr>

#### #회장뽑기

[회장뽑기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.10/Solution_2660)🙋‍♀️

간만에 푼 BFS 문제다. 체감 실버1 수준이었다. 어려운 문제는 아니었고, 처음 푼 풀이 방법도 맞았는데 변수 하나가 틀려서 틀린 걸 잡지 못하고 다른 사람 풀이를 보고 다시 개선해서 문제를 풀어서 풀이 방식이 여러가지로 나뉘었다. 이번에는 플로이드-와샬로도 풀어봤다. 

<br>

플로이드-와샬에 대해서는 개념 정리를 따로 정리하는 걸로 하고, 이번에는 ver1과 ver2 중심으로만 해설을 하려고 한다. 사실 두 방법에는 큰 차이가 없으므로 처음 생각한 ver1 방식으로 풀이를 하겠다.

✅ [Floyd-Warshall Algorithm](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/Floyd-Warshall%20Algorithm.md)

1. 무방향 그래프이기 때문에 x와 y가 친구라면 map[x] [y] = 1이면서 map[y] [x] = 1이 된다.
2. 나는 1번부터 차례대로 한 사람에 대해서 친구 점수가 몇 점이 되는지 확인하려고 했다. 그래서 BFS 함수 안에서 반복문을 돌려 1번부터 n번까지 전부 체크했다. (ver2에서는 BFS를 호출할 때 반복문을 돌린다는 것에 차이점이 있다.)
3. 나는 visited 함수를 이용해서 친구 점수를 확인하려고 했는데 그 방식은 **현재 큐에서 나온 visited 값에 + 1을 더해 친구의 친구 등을 표시하는 방식이었다.** (ver2에서는 visited는 boolean으로 선언해서 순수하게 방문여부를 확인하고 대신 별도의 객체를 생성해 depth를 표시하는 방식이다.) 그래서 2번의 큰 반복문의 반복인자인 i에 대해서는 방문 여부를 표시할 수 없기 때문에(0점이어야 하므로 초기값과 겹칠 수밖에 없다.) i와 같은 값을 만나게 되면 넘어가는 방식을 사용했다.
4. visited 함수에서 가장 큰 값이 그 사람의 친구 점수가 되기 때문에 max 값을 구한 뒤, 친구 점수를 담는 배열 arr에 값을 저장한다.
5. 메인으로 돌아와서 arr의 최솟값을 구하고, 그 값과 동일한 값을 갖는 인덱스를 리스트에 넣어서 출력한다.

<br>

<hr>

#### #연산자 끼워넣기

[연산자 끼워넣기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_14888.java)

삼성 SW 역략 테스트 기출 문제이다. 유형은 백트래킹 문제이다. 처음에는 연산자의 개수를 하나씩 감소하면서 어떻게 모든 경우를 구할까 고민했다. 그러다가 C++로 푸신 분의 풀이를 봤고 대충 무슨 말인지 알 것 같아서 풀었더니 맞았다. DFS는 재귀 성격을 가지고 있다는 걸 유념해야겠다. 😜

<br>

1. 각각의 연산자의 개수를 매개변수로 하여 dfs 함수에 넣어준다. 이때, 연산자로 값을 계산해야 하므로 sum의 값을 주어지는 수(여기서는 numArr)의 첫 번째 값으로 초기화하고, cnt를 인덱스로 사용하기 위해 같이 매개변수로 넘겨준다.
2. 각각의 연산자가 0 이상이라면 해당하는 연산자의 개수를 하나 감소시키고 cnt를 인덱스로 하여 수를 가져와서 sum과 해당 연산자로 하여 계산을 수행한 뒤, sum에 다시 넣어주고 cnt도 하나 늘려준다.
3. 만약 cnt가 N이라면 numArr 만큼 다 돌았다는 뜻이므로 최솟값과 최댓값을 각각 비교하여 갱신해 준다.
4. 메인으로 돌아와 최솟값과 최댓값을 출력한다.

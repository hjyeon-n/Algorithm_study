# BFS, DFS

#### BFS, DFS로 푼 문제

| 문제 번호 | 이름                                  |
| --------- | ------------------------------------- |
| 11725     | [트리의 부모 찾기](#트리의-부모-찾기) |
| 2573      | [빙산](#빙산)                         |

<br>

#### BFS로 푼 문제

| 문제 번호 | 이름                         |
| --------- | ---------------------------- |
| 14503     | [로봇 청소기](#로봇-청소기)⭐ |
| 14226     | [이모티콘](#이모티콘)        |

<br>

#### DFS로 푼 문제

| 문제 번호 | 이름                       |
| --------- | -------------------------- |
| 15686     | [치킨 배달](#치킨-배달)    |
| 14500     | [테트로미노](#테트로미노)⭐ |

<br>

<hr>

#### #트리의 부모 찾기

[트리의 부모 찾기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.10/Solution_11725)

평소에 인접행렬로 풀다가 인접 리스트로 풀었다. 사실 인접행렬로 풀면 런타임 에러가 난다.😜

그럼에도 시간이 오래 걸리길래 평소에 쓰던 `System.out.print`대신에 `StringBuffer`나 `BufferedWriter`를 써봤다. `StringBuffer` 속도가 더 빠르기 때문에 코드엔 `StringBuffer` 로 사용했다. 해설은 DFS 방법으로 설명하겠다.

<br>

1. ArrayList를 2차원 리스트로 만들어주기 위해 ArrayList<ArrayList< Integer>>의 형식으로 선언한다.
2. 반복문을 통해서 입력을 받으면서 부모 리스트에는 자식 노드를 추가하고, 자식 리스트에도 부모 노드를 추가한다.
3. 1이 루트 노드이기 때문에 1부터 탐색을 시작한다.
4. 1이랑 인접한 노드를 방문하기 위해서 정점 1에 대한 인접 리스트에서 노드를 하나씩 꺼낸 뒤, 방문 여부를 표시하고 answer를 채운다.
5. 4번의 과정을 끝낸 뒤, answer를 출력한다.

<br>

<hr>

⭐⭐⭐⭐⭐

#### #로봇 청소기

[로봇 청소기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_14503.java)

기본적으로 삼성 SW 기출 문제는 실제 문제에 비해 난이도가 낮게 잡혀있는 것 같다😂 체감 골드4였는데...🙄

예전부터 풀려고 시도는 했었으나, 문제가 너무 이해가 되지 않았다. 특히 이 부분... "왼쪽 방향에 청소할 공간이 없다면, **그 방향**으로 회전하고 2번으로 돌아간다." 대체 그 방향이 무엇인가... 질문 목록을 보고 나서야 왼쪽이라는 걸 알았다. 아니 어째서...😖

산 넘어 산이라고 방향 전환이 정말정말 헷갈렸다... 어렵진 않았는데 한 번 잘못 잡았더니 혼동돼서 제대로 잡느라 힘들었다.

처음엔 접근조차 힘들어서 다른 사람 풀이를 좀 봤고, 세부적인 사항은 직접 짜려고 노력했다.

```
1. 현재 위치를 청소한다.
2. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
	a.왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
	b.왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
	c.네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
	d.네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
```

<br>

1. 입력을 받고, 문제에서 명시한 시작점부터 BFS를 시작한다.
2. 현재 방향을 기준으로 왼쪽 방향을 봐야한다. 이 부분은 turnDirection 함수에서 처리한다.
3. turnDirection에서는 북쪽(0)일 때는 서쪽(3)을 반환하고, 동쪽(1)일 때는 동쪽의 방향을 기준으로 서쪽이 되는 남쪽(2)를 반환하는 방식이다. 이때 탐색을 진행하기 위해 반환값은 dx와 dy의 인덱스로 작동한다. 즉 3을 반환하면 서쪽이 되도록 dx[3] = 0, dx[3] = -1이 되도록 dx, dy 배열을 전역 변수로 선언한다. (이 지점이 가장 오래 걸렸다.😢)
4. 만약 아직 방문하지 않았고 (즉, 청소하지 않음) 벽이 아니라면 turnDirection에서 반환된 값을 방향으로 해서 전진한다.
5. 4번의 과정은 반복문으로 진행되는데, 만약 서쪽의 값이 벽이거나 청소를 이미 했다면 b의 과정을 거치기 위해 회전을 해야 하기 때문이다. 만약 왼쪽 방향에 청소할 곳을 찾는다면 반복문에서 빠져나오기 위해 break를 하면 된다.
6. flag 변수를 통해 c를 구현하면 되는데, 마찬가지로 4번의 반복문 안에서 청소할 곳을 발견하면 flag를 true값으로 바꿔주면 되고, 만일 그렇지 않다면 네 방향 모두 청소가 되었거나 벽인 경우, 즉,  c의 조건이 성립된다.
7. flag가 false이면 바라보는 방향을 유지한 채로 후진해야 하기 때문에 goBack이라는 함수를 호출해 후진할 경우 변경될 좌표 값을 만들고, 큐에는 현재 방향 d를 그대로 삽입한다.
8. goBack이라는 함수는 현재 방향이 북인 경우, dx가 1, dy가 0인 경우의 인덱스를 반환하면 된다. 예를 들어, 이 경우에는 2를 반환하면 된다.
9. 큐가 빌 때까지 위 과정들을 진행하면서, 더 이동할 수 없기 때문에 d는 자연스럽게 구현된다. 

<br>

<hr>

#### #치킨 배달

[치킨 배달 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_15686.java)

예에에전에 북마크에 담아두었다가 이제야 풀었다. 🧐 다행히 어려움 없이 처음 생각한대로 잘 풀렸다. 난이도는 체감 실버 1정도?

<br>

1. 빈 칸을 무시하기 위해 집과 치킨집의 좌표를 담을 리스트를 각각 선언하고, 입력값이 1이면 home 리스트에, 2이면 chicken 리스트에 각각 담는다.
2. DFS 백트래킹을 이용해서 조합의 값을 구한다. 이때 조합의 결과값은 chicken의 인덱스 값이 된다.
3. 만약 수를 다 뽑았다면,  집 하나를 기준으로 어떤 치킨집이 더 가까운지 치킨 거리를 세야 하기 때문에 home 리스트 길이만큼 반복문을 돌면서 home의 좌표를 기준으로 다시 중첩 반복문으로 조합의 결과값으로 구한 chicken의 좌표를 구해 거리를 구한다. 
4. 이때 거리가 짧은 게 치킨 거리가 되기 때문에 정수의 최댓값으로 초기화한 min_chicken과 비교한 뒤, 작은 값을 min_chicken에 입력한다.
5. 한 집에 대해서 치킨 거리를 구한 후, sum 값에 합한다. 이 과정을 모든 집마다 다 거친다.
6. sum 값을 전역 변수로 선언된 min과 비교 후, 작은 값을 min에 넣는다.
7. 메인으로 돌아와서 min을 출력한다.

<br>

<hr>

#### #이모티콘

[이모티콘 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_14226.java) 😊

처음에는 Bottom-up 방식의 DP로 풀려고 규칙을 찾아내려고 했다. 근데 생각해 보니 복사, 붙여넣기, 제거의 3가지 행동만 해야 한다는 문제의 룰에서 벗어난 방법까지 생각하려고 했던 것 같다... 어쨌든 DP로 어떻게 문제를 풀지 감이 잘 잡히지 않았고, 문제 라벨이 그래프 이론이길래 어떻게 푼다는 거지...? 하고 풀이를 먼저 참고했었다.

지도가 대놓고 그려져있는 문제나 경로를 찾는 문제 등은 바로 BFS로 풀어야겠다고 가닥이 잡히는데 이런 문제들은 바로 방법이 생각나지 않는다... 😥 좀 더 많은 문제를 풀고 연습해야지.

<br>

최소시간을 구해야 하기 때문에 BFS를 사용해야 하고, 여러 가지 경우의 수가 나올 수 있고 반복될 수도 있기 때문에 visited 방문 배열을 선언해 중복을 없애야 한다. 그리고 나머지는 직관적으로 문제에 주어진 조건에 따르면 쉽게 풀 수 있다.

1. visited 이차원 배열을 선언할 때, 첫 번째 인덱스에는 화면에 출력된 개수, 두 번째 인덱스에는 복사된 개수라고 생각해서 문제에 접근해야 한다.
2. 출력 개수, 복사된 개수, 해당 시간을 저장할 Emoji 객체를 선언하고, 이 타입의 큐를 선언한다.
3. 탐색 초기 값은 문제에 주어진대로, 이미 출력된 하나의 개수를 고려해 (1, 0, 0)에 해당하는 객체 값을 큐에 넣어주고, visited[1] [0]에 방문 여부를 표시한다.
4. 만약, 큐에서 꺼낸 값의 display가 S와 같을 땐 원하는 결과를 얻은 것이므로 time을 출력하고 끝낸다.
5. 복사할 경우, 일부 복사가 불가하기 때문에 copy의 값은 display가 될 것이다. 해당 정점에 대해 방문 여부를 확인하고 큐에 삽입한다.
6. 붙여넣기의 경우, 현재 display 값과 copy 값이 같이 출력된다는 것인데 이때 전체 범위를 넘어가지 않는지 확인하고 마찬가지로 방문 여부를 확인한 뒤, 큐에 삽입한다.
7. 삭제의 경우, 현재 display 값에서 하나 빼줘야 한다. 이때 0보다 크거나 같은지 확인하고 방문 여부를 확인한다.
8. 4 ~ 6까지의 경우를 큐가 빌 때까지 전부 확인한다.

<br>

<hr>

#### #빙산

[빙산 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.10/Solution_2573) 🧊

왜 골드4인지 모르겠는 문제... 체감 골드5 정도였다. 처음 생각했던 방식대로 그대로 풀렸지만, 중복되는 부분이 많아서 다른 사람 풀이를 참고해서 새로 고친 버전도 같이 업로드했다. 

<br>

1. 배열을 입력을 받으면서 0이 아닌 값은 list에 add한다.
2. list의 사이즈가 0이면 전체가 0이기 때문에 바로 0을 출력하고 프로그램을 끝낸다.
3. list를 기준으로 빙하가 몇 덩어리인지 센다. 만약 ice가 2이상이면 처음부터 분리되었기 때문에 더 볼 필요 없이 0을 출력하고 끝낸다.
4. 2, 3에 조건과 맞지 않는다면 time을 0으로 초기화하고, 빙하를 녹이고 세는 과정을 반복하기 위해 while문을 사용한다.
5. map의 값이 0이 아니고 아직 방문하지 않았다면, removeIceBerg 함수를 호출한다.
6. removeIceBerg에서는 빙산을 녹여야 하기 때문에 BFS를 돌면서 상하좌우에 0이 존재하면 cnt를 증가시킨다.
7. 만약 0이 아니고 아직 방문하지 않았다면 해당 정점을 큐에 삽입한다.
8. map에 cnt를 빼서 0보다 크면 iceberg에 빙산의 위치를 표시하고, 전체 배열을 도는 대신에 list에 있는 값만 확인할 수 있도록 list에 해당 정점을 삽입한다. map에도 cnt를 뺀 값으로 갱신한다.
9. 만약 0보다 작거나 같으면, **다른 정점들도 전부 확인해야 하기 때문에 바로 0으로 갱신하지 않고**, zero 리스트에 해당 정점을 넣어 후에 zero 리스트를 돌면서 0으로 초기화해야 한다.
10. 메인으로 돌아가 zero 값들을 0으로 초기화하고, 빙산에 대해 방문 여부를 확인한 뒤, (방문하지 않았다면 0, 방문했다면 2) countIce를 호출한다.
11. countIce에서는 BFS를 돌면서 빙산을 방문한다.
12. 위의 과정은 countIce의 결과값이 2이상 즉, 빙산이 처음으로 분리될 때 혹은 빙산이 전부 녹아 0이 아닌 값이 없을 때 즉, list의 크기가 0일 때까지 반복한다.

<br>

구현할 때도 시간 초과 나는 게 아닌가 걱정했을 만큼 복잡하다. 그래서 리스트를 사용하지 않고, 처음부터 분리 여부를 판단한 뒤에 빙산을 녹이는 방식을 사용했다. 이때, 바로 녹일 순 없기 때문에 melt라는 이차원 배열을 선언해 상하좌우의 0의 개수를 저장한다.

1. BFS/DFS 방식을 사용해 덩어리가 분리되었는지 확인한다.
2. 만약 1의 결과가 2이상이면 time을 출력하고, 0이면 모든 정점이 0이라는 뜻이기 때문에 0을 출력하고 끝낸다.
3. 2번의 조건과 부합하지 않는다면 meltIce를 호출해 countIce에서 셌던 melt의 값을 이용해 빙산을 녹인다.
4. 위 과정을 반복한다.

<br>

<hr>

⭐⭐⭐⭐⭐

#### #테트로미노

[테트로미노 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_14500.java)

역시 삼성 SW 역량 테스트 기출 문제는 난이도가 너무 저평가됐다...💦 이게 어떻게 골드5지. 체감 골드4 문제였다.🤯

여러가지 경우를 생각해야 하기 때문에 백트래킹으로 문제를 풀어야 하나? 싶었다. 하지만 백트래킹으로 어떻게 모양을 만들어낼지 감이 잡히지 않았고, 하드코딩을 한다고 해도 그 모양들을 다 만들고 맵의 범위에 벗어나지 않게 어떻게 위치시켜야 할지 잘 모르겠더라. 결론적으로는... 다른 사람 풀이를 참고했다! 😢

<br>

이 문제의 관건은 회전과 대칭을 사용한 경우도 생각해야 하지만 무엇보다 **모양 'ㅗ' 등은 DFS로 풀 수 없기 때문에 다른 방법을 생각해야 한다**는 게 가장 생각하기 어려운 지점이다. 나도 풀이를 보지 않았으면 전혀 몰랐을 것 같다.

사실 여러 풀이를 봤는데 아무도 왜 저 모양이 안 되는지 설명은 없었다 (왜애애액 난 모르겠는데에엑‼) 

그러다 겨우 블로그 하나를 찾았다!

![image](https://user-images.githubusercontent.com/62419307/95337731-1e169580-08ed-11eb-8c8c-eca3bc3dc0af.png)

(2, 0)부터 DFS를 시작한다고 가정하면 다음 위치가 두 번째 사진처럼 나타날 수 있다. 이 경우 세 번째 점은 사진 4개처럼 여러가지 경우가 올 수 있다. 다만 'ㅗ' 모양은 depth가 최대 3이기 때문에 따로 고려해야 한다! [출처](https://hyeooona825.tistory.com/60)

<br>

'ㅗ' 모양에 대해서 여러 풀이가 있었지만, 하드코딩 방식이나 날개(?)를 잘라내는 방식은 생소해서 [이 블로그](https://velog.io/@skyepodium/%EB%B0%B1%EC%A4%80-14500-%ED%85%8C%ED%8A%B8%EB%A1%9C%EB%AF%B8%EB%85%B8)를 참고했다.

ex, ey의 이차원 좌표를 미리 정의하여 차례대로 'ㅜ', 'ㅏ', 'ㅗ', 'ㅓ' 모양을 만들 수 있도록 했다. 이 좌표들을 더해서 값을 만드는 게 아니라 인덱스 즉, 위치를 잡는다고 생각하면 이해하기 쉽다. 물론 디버깅까지 해서 확인도 했다.

요약하자면,

1. DFS 백트래킹으로 (DFS는 재귀 즉, 일종의 스택이기 때문에 이전값으로 돌아오는 것이 가능하다) depth가 4인 경우, 최댓값을 구한다. (조합을 생각하면 쉽다.)
2. 예외 모양에 대해 따로 ex, ey를 통해 범위가 넘어서지 않는 한에서 합을 구해 max와 비교한 후 최댓값을 갱신한다.
3. 최댓값 max를 출력한다.

 
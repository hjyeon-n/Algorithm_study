# Programmers

| 문제 이름                                 |
| ----------------------------------------- |
| [튜플](#튜플)                             |
| [n진수 게임](#n진수-게임)                 |
| [압축](#압축)                             |
| [파일명 정렬](#파일명-정렬)               |
| [기능개발](#기능개발)                     |
| [다리를 지나는 트럭](#다리를-지나는-트럭) |
| [프린터](#프린터)                         |

<br>

<hr>

#### #튜플

[튜플 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.10)

이 문제의 관건은 어떻게 파싱하느냐에 따라 달려있다. 나는 아직 자바 람다식을 잘 활용하는 편이 아니라서 직접 코드로 짰다. 이 부분도 차근차근 연습해야지.😊

<br>

1. 제일 가장 자리에 있는 괄호를 없애기 위해 substring으로 1부터 길이 - 1까지 구한다.
2. 이제 중괄호마다 분리해야 한다. 하지만 그 수가 어느 정도인지 가늠을 할 수 없기 때문에 ArrayList를 선언한다.
3. 반복문을 돌면서 charAt으로 중괄호를 분리하고 ','는 공백으로 처리한다. (이 이유는 숫자가 3, 11를 311이라고 혼동하지 않기 위해)
4. ArrayList를 완성하고 길이를 기준으로 정렬한다. 왜냐면 중괄호 안의 원소가 하나만 존재할 때부터 마지막까지 차근차근 알아내야 튜플을 구할 수 있기 때문이다.
5. contains를 사용해 리스트에 이미 있는 값은 생략하기 위해 answerList를 선언한다. 
6. list만큼의 반복문을 돌리면서 공백을 기준으로 String 값을 자른다.
7. 6번의 결과만큼 반복문을 돌리면서 answerList에 포함돼 있는지를 확인하고, 만약 그렇지 않다면 answerList에 add한다.
8. answerList를 배열 값으로 바꿔준다.

<br>

<hr>

#### #n진수 게임

[n진수 게임 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.10/n%EC%A7%84%EC%88%98%20%EA%B2%8C%EC%9E%84.java)

진수를 라이브러리를 사용하지 않고 바꾸는 건 오랜만이라 살짝 헷갈렸다. 나머지가 10이상부터는 문자로 표현해야 하기 때문에 Character로 선언을 해야 하고, 일반 정수는 '0'을 더해주고, 10 이상의 나머지부터는 55를 더해줘야 A부터 문자를 채워나갈 수 있다.

<br>

1.  수를 잘라서 한 명씩 말하기 때문에 우선, 진법으로 변환한 arr을 얻어야 한다. 이때 arr의 최대 크기는 구하고자 하는 길이 t와 사람 수 m을 곱해 구한다.
2. 진수는 0부터 구해야 하고, 0은 언제나 0이기 때문에 우선, arr[0]을 0으로 채워준다.
3. 배열의 인덱스가 될 idx가 배열의 크기보다 1작을 때까지 반복문을 돌리면서 1부터 n진법으로 바꾼다. (이때 num이 n진법으로 바뀔 수이다.)
4. n진법으로 바꾸기 위해 num이 0보다 작기 전까지 나머지 연산과 나눗셈 연산을 하면서 리스트에 넣어준다. 이때 리스트인 이유는 배열처럼 범위를 정확히 알 수 없고, 진법 변환을 위해서 역순으로 구해야 하기 때문에 list 자료구조를 사용한다.
5. list를 역순으로 구해 arr을 채운다.
6. arr을 전부 채웠으면 메인으로 돌아간다.
7. 메인에서는 arr의 길이까지 반복문을 돌리면서 people이 p일 때, 내 차례이므로 answer에 arr의 값을 넣어준다. 만약 people가 m이 되면 한 바퀴 돈 것이기 때문에 다시 0으로 초기화해서 내 차례를 기다린다.

<br>

<hr>

#### #압축

[압축 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.10/%EC%95%95%EC%B6%95.java)

어피치 문제다😉 1점짜리 문제인데 3점은 줬으면 했다. 어려운 건 아니었지만 그래도...😢

사전을 채우기 위해서 HashMap을 사용했다. w + c를 만들고 나서 인덱스 조정하는 게 제일 까다로웠다.

<br>

1. 아스키 코드를 이용해 A부터 Z까지의 사전을 채운다. 
2. msg 문자 하나씩 뽑아야 하기 때문에 msg의 길이만큼 반복문을 돌린다. 
3. 가장 긴 길이를 기준으로 색인을 찾아야 하기 때문에 str을 선언해 현재 글자 w 뿐만 아니라 다음 글자로 올 c를 더해 나가면서 색인이 어디까지 등록돼 있는지 확인해야 한다.
4. j가 msg 길이가 될 때까지 반복문을 돌려야 한다. 이때 j는 str에 문자들을 더해나가는 인덱스 역할을 한다.
5. 4번의 반복문 안에서 str에 대한 색인이 있는지 containsKey 값을 통해 알아낸다.
6. 만약 색인이 있으면 val 값이 색인 값을 저장한다. 이 이유는 만약 K, KA에 대한  str의 색인 값이 K일 때는 11, KA는 27로 이미 존재할 때, KA가 들어왔다고 가정하자. 하나씩 분리해서 확인하기 때문에 K일 때는 11을 출력하고 KA일 때는 27을 출력할 것이다. 이때 11은 출력할 필요가 없으므로, val이라는 별도의 변수를 선언해 색인 값을 저장하고 4번의 반복문 밖에서 list에 val을 삽입하면 된다. (이때 list는 출력할 값을 저장하기 위함)
7. 6번의 경우에 이어서 str의 길이가 2 이상이 되면 현재 글자 w와 다음 글자 c를 합한 값에 색인이 존재한다는 것인데 그렇다면 다시 c값을 보지 않아도 되므로 k값을 증가시켜 다음 인덱스를 무시하도록 조정해 준다.
8. 6번과 달리 만약 색인 값이 없다면, 1번의 사전의 길이로 초기화한 len을 1 증가 시켜서 str의 값과 같이 해시에 저장한다.
9. 모든 과정이 끝나면 list를 answer로 옮긴 후, answer를 반환한다.

<br>

<hr>

#### #파일명 정렬

[파일명 정렬 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.10/%ED%8C%8C%EC%9D%BC%EB%AA%85%20%EC%A0%95%EB%A0%AC.java)

이 문제는 Comparator을 잘 활용할 수 있는지 묻는 문제다. 카카오 기출 문제는 문자열 문제가 많은 것 같다. 삼성 SW 역량 테스트 문제에 BFS, DFS 문제가 많은 것처럼😉 확실히 기출 문제가 적당한 난이도가 있어서 좋다!

<br>

1. 숫자를 구별하기 위해 미리 아스키코드를 이용해 숫자만 담은 리스트를 생성한다.
2. files의 길이만큼 반복문을 돌면서 파일명을 분리해야 한다. 이때, head, numer, tail 순으로 분리해야 하기 때문에 숫자가 나오기 전까지는 head, 숫자 부분만 number 다시 문자가 등장할 때는 tail로 넘어가야 하는데 head랑 구분을 하기 위해서 flag 변수를 선언한다.
3. files의 한 원소에 대해서 그 문자열 길이만큼 반복문을 돌면서 head, number, tail을 분리한다. tail일 때는 break한 뒤 반복문을 빠져나온 후, 남은 문자열의 길이만큼 나머지를 채운다.
4. 원래 문자열 str, head로 정렬해야 하기 때문에 head와 앞에 0이 올 경우 0을 제외해야 하기 때문에 number와 number를 Integer로 바꾼 값, 그리고 tail을 파라미터로 해서 객체를 하나 만든 뒤 배열에 넣어준다.
5. **Comparator를 사용해서 head를 기준으로 정렬하되, 대소문자를 무시하기 위해 compareToIgnoreCase를 쓴다.**
6. **5의 값이 같을 때는 number를 기준으로 정렬해야 한다.** [참고](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/Comparable%EA%B3%BC%20Comparator.md)
7. 정렬된 배열에서 원래 문자열 name만 answer 배열에 넣은 뒤 반환한다.

<br>

<hr>

#### #기능개발

[기능 개발 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.10/%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C)

이 문제는 3가지 버전으로 풀어서 업로드했다. 첫 번째 버전은 처음 생각한 방식대로 풀었고, 두 번째 버전은 첫 번째 버전에서 코드를 조금 수정했고 세 번째 버전은 다른 사람 풀이 중 람다식으로 푼 풀이가 있길래 가져와 봤다.

생각보다 스택으로 풀지 않은 사람이 더 많았는데, 나는 뒤에 있는 순서가 더 빨리 완성되더라도 첫 번째 순서가 배포되지 않으면 배포될 수 없다는 문제의 조건에 따라 선입선출 형식의 스택을 이용해서 문제를 풀었다.

<br>

첫 번째와 두 번째 풀이는 사실상 비슷하다.

1. ver1의 경우, progress와 speed를 저장할 수 있도록 객체를 하나 선언한다. 또한 이 타입을 저장할 수 있도록 ArrayList와 Stack을 정의한다.
2. ver2의 경우, 객체를 별도로 선언하지 않고 speed만 저장하면 되기 때문에 Integer 타입의 ArrayList와 Stack을 정의한다.
3. 파라미터로 주어진 배열을 역순으로 스택에 넣는다. (선입후출이기 때문)
4. 이때 스택에 넣을 값은 소요시간이다. ver1의 경우, while문으로 speed와 day를 곱한 값과 progress를 더한 값이 100이상이 되면 break해서 day 값을 구했다. ver2의 경우, 100에서 progress를 빼서 남은 일자를 구한 뒤, speed로 나눠서 총 걸린 시간을 구한다. 이때 시간은 double 형태이기 때문에 Math.ceil을 이용해 반올림한다.
5. 스택이 전부 빌 때까지 pop해서 스택 값을 하나 얻은 뒤에, 또 중첩으로 while문을 돌려 peek()한 값이 현재 값과 비교해서 작거나 같을 때 pop해준다. 이 경우도 스택이 전부 빌 경우도 고려해야 한다. 그리고 cnt를 하나씩 늘려 하루에 몇 개가 배포되는지 파악한다.
6. cnt를 리스트에 넣어준다.
7. 리스트를 answer 배열로 옮기고 그 값을 반환한다.

<br>

세 번째 풀이는 람다식인데... 사실 파이썬에서만 사용했을 정도로 자바의 람다식은 나에게 낯설다. 그리고 람다식 코드는 짧지만, 항상 댓글에는 "성능이 별로다" 라는 글이 꼭 달리는데 그 이유도 잘 몰라서 찾아봤다. [아주 설명이 잘 되어있다!!!](https://brunch.co.kr/@heracul/3)

특히 프로그래머스 풀이에는 stream 방식이 많이 쓰이는데... 이게 무슨 역할을 하는지 알아보는 걸로 이번 풀이는 마쳐야겠다.

```java
return Arrays.stream(dayOfend).filter(i -> i != 0).toArray();
```

이 코드는 i가 0이 아닐 때까지 stream의 모든 요소를 배열로 바꿔서 반환하는 역할을 한다.

[람다식 문법은 여기에서 참조했다!](https://khj93.tistory.com/entry/JAVA-%EB%9E%8C%EB%8B%A4%EC%8B%9DRambda%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%82%AC%EC%9A%A9%EB%B2%95)

<br>

<hr>

#### #다리를 지나는 트럭

[다리를 지나는 트럭 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.10/%EB%8B%A4%EB%A6%AC%EB%A5%BC%20%EC%A7%80%EB%82%98%EB%8A%94%20%ED%8A%B8%EB%9F%AD.java) 🚚

리스트 자료구조를 통해서 풀어도 되지만 카테고리가 큐/스택인 만큼 큐와 스택으로 풀었다.

1. truck_weights를 역순으로 해서 스택에 값을 쌓는다.
2. 다리 위에 트럭이 바로 놓인다고 가정하기 때문에 answer는 1부터 시작한다.
3. 만약 다리 위에 차가 없을 때에 스택에서 값을 꺼내 큐에 넣는다. 이때 큐에 넣은 시간과 트럭의 무게를 같이 넣어준다.
4. 만약 다리 위에 차가 있을 때 즉, 큐에 값이 존재할 때엔 제일 앞에 있는 값을 가져와서 현재 시간에서 빼준 값이 다리의 길이와 같을 때 트럭이 다리 위에서 빠져나온다.
5. weight와 비교를 위한 sum에서 해당 트럭의 무게 값을 빼주고, 다리 끝까지 도착했기 때문에 end 리스트에 트럭의 무게 값을 삽입한다.
6. 만약 end의 길이와 트럭들의 수와 같으면 멈춘다.
7. 스택이 비어있지 않고, 스택의 가장 위에 있는 값과 sum을 합했을 때, 무게 제한에 걸리지 않는다면 해당 트럭의 무게와 현재 시간을 큐에 넣어주고, sum을 더해준다.

<br>

<hr>

#### #프린터

[프린터 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.10/%ED%94%84%EB%A6%B0%ED%84%B0)

ver1은 내가 풀이한 방식, ver2는 다른 사람 풀이를 가지고 왔다. Comparator로 풀어도 될까 싶었지만 리스트의 맨끝으로 이동하는 과정이 생략돼서 결과적으로 이상한 값이 나와서 그냥 문제가 요구한 조건을 그대로 따라서 풀었다.

1. 우선순위와 인덱스를 함께 저장하는 객체를 선언한 뒤, 리스트에 넣는다. (큐를 사용하지 않는 이유는 탐색에 적합하지 않아서다.)
2. 리스트의 크기가 0이 될 때까지 반복문을 돌린다.
3. 리스트에서 첫 번째 값을 꺼내 해당 우선순위가 다른 우선순위들보다 큰지 확인하고 그렇지 않으면 다시 리스트 맨끝에 추가하고, 우선순위가 가장 크다면 end 리스트에 객체의 값 중 인덱스를 삽입한다.
4. 2번 반복문에서 빠져나오면, end 리스트를 돌면서 location과 같은 값을 가진 자리 + 1을 반환하면 된다.

<br>

다른 사람 풀이 중 단박에 이해가 되는 것도 있지만 보통은 잘 이해가 되지 않을 때가 많다... 아직 다른 사람 코드를 읽는 데 익숙하지 않아서 그런가...? 😂 그래서 이번에도 직접 디버깅 하면서 이해했다.

1. priorities를 순서대로 큐에 삽입한다.
2. priorites를 오름차순으로 정렬한다.
3. 이때 마지막 인덱스를 가리킬 size는 priorites의 길이 - 1이다.
4. 큐가 빌 때까지 값을 꺼내서 현재 값과 정렬된 priorites의 역순부터 비교한다. (결국 우선순위대로 출력되기 위함)
5. 만약 값이 같다면 priorities의 역순으로 진행해야 하기 때문에 answer를 증가시키고, 찾고자 하는 l (location을 복사한 값)을 1만큼 빼준다. (**그렇다! 이 방식은 location을 빼주면서 인덱스를 찾아주는 방식이다!**)
6. l이 음수라면 0에서 1만큼 뺐다는 뜻이고, 즉 **내가 찾고자하는 값을 이미 찾았다는 뜻과 같으므로** break한다.
7. 5와 달리 값이 다르다면, 큐의 뒤에 값을 다시 삽입한다. 이때도 마찬가지로 l값을 빼준다. 다만, 값이 같지 않다는 건 내가 찾는 값이 아니라는 것이기 때문에 l이 음수이면 다시 큐의 길이 -1로 갱신해 준다.


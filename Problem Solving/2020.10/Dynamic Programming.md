# Dynamic Programming

| 문제 번호                                      | 이름                  |
| ---------------------------------------------- | --------------------- |
| [11048](https://www.acmicpc.net/problem/11048) | [이동하기](#이동하기) |
| [1309](https://www.acmicpc.net/problem/1309)   | [동물원](#동물원)     |
| [2631](https://www.acmicpc.net/problem/2631)   | [줄세우기](#줄세우기) |
| [4811](https://www.acmicpc.net/problem/4811)   | [알약](#알약)         |

<br>

<hr>

#### #이동하기

[이동하기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.10/Solution_11048)

쉬운 문제다. 이동 방향에 대한 값들 중 최댓값을 갱신하면 된다. 나는 처음에 visited 배열을 별도로 생성해서 풀어서 맞았는데, 다른 사람 풀이를 보니 그럴 필요가 없어서 다시 수정한 버전도 같이 올려뒀다. 풀이는 크게 차이가 없어서 ver2로 풀이한다.

이동할 수 있는 경로는 `r + 1, c`,  `r, c + 1`, `r + 1, c + 1`이기 때문에 만약 갱신하려는 좌표가 i, j라면 `i - 1, j`,  `i, j + 1`, `i + 1, j + 1`에서 올 수 있다. 인덱스에서 1을 빼주면서 생길 수 있는 인덱스 에러를 위해 배열은 N + 1 크기로 선언한다.

그리고 세 경로 중 올 수 있는 최댓값을 골라 현재 좌표의 값을 더해서 갱신한다.

이 과정을 N, M까지 반복한 뒤, N, M 좌표 값을 출력하면 된다.   

<br>

<hr>

#### #동물원

[동물원 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_1309.java)

예제조차 이해가 안 돼서 한참 생각했다. 식을 혼자 짜려고 끙끙대다가 다른 사람 풀이를 조금 참고했다. DP 문제는 구현 문제랑 달리 좋은 아이디어가 없으면 접근조차 힘들다는 게 어렵다. 😥 예전에는 DP 문제가 제일 재밌었는데 요즘은 제일 어렵다!

<br>

우리 안에서 사자는 가로로도 세로로도 붙어 있게 배치할 수 없다는 조건 때문에 이렇게 배치될 수 있다.

![image](https://user-images.githubusercontent.com/62419307/95674900-46a0d700-0bee-11eb-86b7-2c5becd77fcd.png)

<br>

또한 사자가 아예 없을 경우도 하나의 경우라고 생각해야 하기 때문에 아래와 같이 나타낼 수 있다.

```
dp[0] = 1, dp[2] = 3
```

<br>

![image](https://user-images.githubusercontent.com/62419307/95675750-6935ee80-0bf4-11eb-9a5b-a8d587b93cbd.png)

따라서, N - 1에는 사자가 올 수 있는 위치가 2가지로 나뉘고, N - 2의 경우엔 그냥 더해주면 된다.

```
dp[i] = (dp[i - 1]  * 2 + dp[i - 2]) % 9901
```

최댓값을 넘을 수 있기 때문에 문제에 주어진 조건대로 9901으로 나눈 나머지를 저장하면 된다.

<br>

<hr>

#### #줄세우기

[줄세우기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_2631.java)

너무너무너무 오랜만에 푸는 문제다! 한동안 다른 일로 바빠서 못 풀었는데 그동안 감을 많이 잃었을까 봐 약간 걱정된다💦

이 문제도 sort 문제이긴 하지만 단순히 sort가 아니라 이동 수를 최소한으로 해야하기 때문에 어떻게 해야 할 지 잘 몰랐다. 그래서 처음엔 오름차순 / 내림차순 순으로 수를 이동해 볼까 했다. 하지만 예제부터 올바른 결과가 나오지 않아서 질문란을 봤더니 **LIS처럼 생각하면 된대서** 정말 놀랐다. 😳 이런 안목은 어디서 기를 수 있는지 궁금하다... 

[LIS 코드는 여기에서 참고할 수 있다!](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.07/Solution_11053.java) LIS는 가장 긴 증가부분 수열이니까 그 부분은 제외하고 다른 수만 이동하면 문제를 쉽게 풀 수 있다. 

<br>

<hr>

#### #알약

[알약 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.10/Solution_4811.java)💊

문제 접근은 쉬웠고, 나름대로 괜찮았는데 규칙을 찾지 못했다... ☹

dp 문제를 또 많이 풀어봐야겠다. 자꾸 감을 잃는다.

**n이 1일 때**

일단 약 하나(W)를 쪼개야 약의 반쪽(H)을 얻을 수 있으므로 WH로 경우의 수는 하나이다.

**n이 2일 때**

처음에는 약 하나를 쪼갠 후, 올 수 있는 경우는 W나 H다. 다만 마지막의 경우는 약의 반쪽만 남아있어야 하므로 처음은 W, 마지막은 H로 정해져있다. 그러면 WHWH, WWHH로 경우의 수는 2가지이다.

**n이 3일 때**

마찬가지로 처음과 끝은 W와 H로 정해져 있으므로 나머지 4가지 경우만 생각하면 된다. 이 때, H는 앞에 나온 W의 개수보다 많으면 안 된다. 이 경우를 전부 고려하면 WWWHHH, WWHWHH, WHWWHH, WHWHWH, WWHHWH로 5가지 경우의 수가 나온다.

✔ 따라서 점화식은 dp[k] = dp[i] \* dp[N - 1 - i]

[참고](https://steady-coding.tistory.com/187)
# Dynamic Programming

| 문제 번호 | 이름                  |
| --------- | --------------------- |
| 11048     | [이동하기](#이동하기) |

<br>

<hr>

#### #이동하기

[이동하기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2020.10/Solution_11048)

쉬운 문제다. 이동 방향에 대한 값들 중 최댓값을 갱신하면 된다. 나는 처음에 visited 배열을 별도로 생성해서 풀어서 맞았는데, 다른 사람 풀이를 보니 그럴 필요가 없어서 다시 수정한 버전도 같이 올려뒀다. 풀이는 크게 차이가 없어서 ver2로 풀이한다.

이동할 수 있는 경로는 `r + 1, c`,  `r, c + 1`, `r + 1, c + 1`이기 때문에 만약 갱신하려는 좌표가 i, j라면 `i - 1, j`,  `i, j + 1`, `i + 1, j + 1`에서 올 수 있다. 인덱스에서 1을 빼주면서 생길 수 있는 인덱스 에러를 위해 배열은 N + 1 크기로 선언한다.

그리고 세 경로 중 올 수 있는 최댓값을 골라 현재 좌표의 값을 더해서 갱신한다.

이 과정을 N, M까지 반복한 뒤, N, M 좌표 값을 출력하면 된다.   
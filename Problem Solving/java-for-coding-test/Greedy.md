# Greedy

연습 문제는 딱히 풀이하지 않았지만 기출문제부터는 문제를 해결하면서 어려웠던 부분이나 더 배워야 할 것이 있을 것 같아서 따로 풀이한다! 😉 모든 유형의 문제를 차례로 풀어볼 것이 아니기 때문에 유형별로 풀었을 때마다 풀이를 추가하는 식으로 진행할 것이다. 

<br>

| 문제 이름                                 | 풀이 날짜  |
| ----------------------------------------- | ---------- |
| [모험가 길드](#모험가-길드)               | 2021.05.05 |
| [곱하기 혹은 더하기](#곱하기-혹은-더하기) | 2021.05.05 |
| [문자열 뒤집기](#문자열-뒤집기)           | 2021.05.05 |

<br>

<hr>

#### #모험가 길드

[모험가 길드 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Greedy/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EB%AA%A8%ED%97%98%EA%B0%80%20%EA%B8%B8%EB%93%9C.java)

난 정말 그리디 바보이다... 😥

대충 오름차순으로 정리해서 풀어야겠다고는 생각했는데 거꾸로 가장 큰 수부터 접근해야 하나 고민했다. 하지만 문제에서 최대한 많은 수의 그룹으로 묶어야 한다고 했고 또한 모든 모험가를 포함해야 하는 것이 아니기 때문에 낮은 수부터 접근해야 한다.

그리고 해당 숫자보다 크거나 같으면 그룹에 속할 수 있기 때문에 배열을 순회하면서 포함 가능한 모험가를 모을 수 있을 때까지 cnt를 증가시킨다. 만약 cnt가 공포도 이상이라면 그룹을 결성해야 하기 때문에 그룹의 수를 세는 answer를 증가시키고 cnt를 0으로 초기화한다.

<br>

<hr>

#### #곱하기 혹은 더하기

[곱하기 혹은 더하기 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Greedy/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EA%B3%B1%ED%95%98%EA%B8%B0%20%ED%98%B9%EC%9D%80%20%EB%8D%94%ED%95%98%EA%B8%B0.java)

정말 왕쉬운 문제이군... 하면서 풀었는데 생각보다 예외가 많았을 문제이다.

나는 단순히 0일 때 continue로 넘어가려고 했는데 풀이를 보니 1인 경우에도 생각을 해야 한대서 뭐지 싶었는데 1일 때도 0과 마찬가지로 곱하는 것보다 더하는 게 더 큰 수가 나오는 것이었다...! (당연하지 바보야) 😫

그리고 단순히 n만 고려하는 게 아니라 answer가 1이하일 때도 마찬가지로 적용되기 때문에 이 부분도 주의해야 한다.

쉬운 문제도 꼼꼼히 푸는 노력을 해야겠다...! ✍

<br>

<hr>

#### #문자열 뒤집기

[문자열 뒤집기 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Greedy/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EB%AC%B8%EC%9E%90%EC%97%B4%20%EB%92%A4%EC%A7%91%EA%B8%B0.java)

아까 앞 문제에서 꼼꼼히 보겠다고 다짐했거늘 바로 밑천이 드러나버렸다... 😂

'0000'이거나 '1111' 같은 상황의 경우 문자열을 뒤집을 필요가 없으니 이에 대해 처리해 줘야 한다.

그리고 0과 1 그룹의 수를 세는 zero, one의 경우 min 값을 구해야 하기 때문에 -1로 초기화한다면 '0000'일 경우 둘다 -1이기 때문에 이에 대해 처리하기가 아주 귀찮다.

그래서 처음 숫자를 확인해 보고 반대의 cnt를 올려준다. 그리고 다시 반복문을 돌면서 처음부터 끝까지 zero와 one의 수를 세주면 된다.
# Greedy

연습 문제는 딱히 풀이하지 않았지만 기출문제부터는 문제를 해결하면서 어려웠던 부분이나 더 배워야 할 것이 있을 것 같아서 따로 풀이한다! 😉 모든 유형의 문제를 차례로 풀어볼 것이 아니기 때문에 유형별로 풀었을 때마다 풀이를 추가하는 식으로 진행할 것이다. 

<br>

| 문제 이름                                 | 풀이 날짜  |
| ----------------------------------------- | ---------- |
| [모험가 길드](#모험가-길드)               | 2021.05.05 |
| [곱하기 혹은 더하기](#곱하기-혹은-더하기) | 2021.05.05 |
| [문자열 뒤집기](#문자열-뒤집기)           | 2021.05.05 |
| [만들 수 없는 금액](#만들-수-없는-금액)   | 2021.05.06 |
| [볼링공 고르기](#볼링공-고르기)           | 2021.05.11 |

<br>

<hr>

#### #모험가 길드

[모험가 길드 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Greedy/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EB%AA%A8%ED%97%98%EA%B0%80%20%EA%B8%B8%EB%93%9C.java)

난 정말 그리디 바보이다... 😥

대충 오름차순으로 정리해서 풀어야겠다고는 생각했는데 거꾸로 가장 큰 수부터 접근해야 하나 고민했다. 하지만 문제에서 최대한 많은 수의 그룹으로 묶어야 한다고 했고 또한 모든 모험가를 포함해야 하는 것이 아니기 때문에 낮은 수부터 접근해야 한다.

그리고 해당 숫자보다 크거나 같으면 그룹에 속할 수 있기 때문에 배열을 순회하면서 포함 가능한 모험가를 모을 수 있을 때까지 cnt를 증가시킨다. 만약 cnt가 공포도 이상이라면 그룹을 결성해야 하기 때문에 그룹의 수를 세는 answer를 증가시키고 cnt를 0으로 초기화한다.

<br>

<hr>

#### #곱하기 혹은 더하기

[곱하기 혹은 더하기 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Greedy/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EA%B3%B1%ED%95%98%EA%B8%B0%20%ED%98%B9%EC%9D%80%20%EB%8D%94%ED%95%98%EA%B8%B0.java)

정말 왕쉬운 문제이군... 하면서 풀었는데 생각보다 예외가 많았을 문제이다.

나는 단순히 0일 때 continue로 넘어가려고 했는데 풀이를 보니 1인 경우에도 생각을 해야 한대서 뭐지 싶었는데 1일 때도 0과 마찬가지로 곱하는 것보다 더하는 게 더 큰 수가 나오는 것이었다...! (당연하지 바보야) 😫

그리고 단순히 n만 고려하는 게 아니라 answer가 1이하일 때도 마찬가지로 적용되기 때문에 이 부분도 주의해야 한다.

쉬운 문제도 꼼꼼히 푸는 노력을 해야겠다...! ✍

<br>

<hr>

#### #문자열 뒤집기

[문자열 뒤집기 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Greedy/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EB%AC%B8%EC%9E%90%EC%97%B4%20%EB%92%A4%EC%A7%91%EA%B8%B0.java)

아까 앞 문제에서 꼼꼼히 보겠다고 다짐했거늘 바로 밑천이 드러나버렸다... 😂

'0000'이거나 '1111' 같은 상황의 경우 문자열을 뒤집을 필요가 없으니 이에 대해 처리해 줘야 한다.

그리고 0과 1 그룹의 수를 세는 zero, one의 경우 min 값을 구해야 하기 때문에 -1로 초기화한다면 '0000'일 경우 둘다 -1이기 때문에 이에 대해 처리하기가 아주 귀찮다.

그래서 처음 숫자를 확인해 보고 반대의 cnt를 올려준다. 그리고 다시 반복문을 돌면서 처음부터 끝까지 zero와 one의 수를 세주면 된다.

<br>

<hr>

#### #만들 수 없는 금액

[만들 수 없는 금액 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Greedy/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EB%A7%8C%EB%93%A4%20%EC%88%98%20%EC%97%86%EB%8A%94%20%EA%B8%88%EC%95%A1.java)

문제를 보자마자 정렬해서 target을 정한 뒤에 만들 수 있는 금액인지 확인하면 되겠다고 생각했다.

맞는 접근이었지만 만약 1원이 2개, 2원이 1개 있을 때 4원을 어떻게 만드는지 별도의 식이 필요한가? 에 대해서 고민했고 어떻게 이를 알 수 있는지 고민했다...

그러다가 답을 봤는데 target (내 코드에서는 answer이다.)을 만들 수 있다면 target을 해당 동전의 금액만큼 증가시키면 된다.

만약 우리가 동전 1원, 2원, 3원, 8원이 있다고 가정하자. 과정은 아래와 같다. 원 단위는 생략한다.

1. 1원을 만들 수 있는지 확인한다. 이를 위해 target은 1로 설정한다.
2. 1원이 있기 때문에 target = 1을 만족한다. 그러므로 target = 1 + 1로 업데이트한다. (이 말은 1까지의 모든 금액을 만들 수 있다는 의미이다.)
3. 2원이 있기 때문에 target = 2를 만족한다. 그러므로 target = 2 + 2로 업데이트한다. (3까지의 모든 금액을 만들 수 있다는 의미)
4. 3원이 있기 때문에 target = 4보다 작으므로 만족한다. target은 3 + 4 = 7로 업데이트한다.
5. target은 7이지만 더 큰 화폐 단위인 8인 동전이 있다. 그렇기 때문에 7원은 만들지 못한다.

<br>

그리디나 DP 문제는 아이디어도 중요하지만 간단하게 코드로 옮길 수 있는 능력도 필요한 것 같다...

특히 이러한 스킬들은 많은 문제를 푸는 것도 중요하지만 다른 사람 코드를 보는 것도 중요하니 유념해야겠다!

<br>

<hr>

#### #볼링공 고르기

[볼링공 고르기 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/tree/master/Greedy/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EB%B3%BC%EB%A7%81%EA%B3%B5%20%EA%B3%A0%EB%A5%B4%EA%B8%B0) 🎳

난 단순히 조합으로 풀긴 했지만 문제를 풀면서 M이 주어진 이유도 있겠고 더 간단하게 풀 수 있을 거라고 생각하긴 했었다...

하지만 한 발 더 나가는 게 항상 어렵다. 😥

<br>

이 문제를 해결하기 위해서 무게마다 몇 개의 볼링공이 있는지 확인해야 한다. 이런 볼링공이 있다고 가정해 보자. (책 풀이를 참고했다!)

+ 무게가 1인 볼링공 : 1개
+ 무게가 2인 볼링공 : 2개
+ 무게가 3인 볼링공 : 2개

1. A가 무게가 1인 볼링공을 선택한다면 B는 나머지 4개의 볼링공을 선택할 수 있다. 1 * 4 = 4
2. A가 무게가 2인 볼링공을 선택한다면 B는 나머지 2개의 볼링공을 선택할 수 있다. 이때 무게가 1인 볼링공과의 조합은 1번 케이스에서 모두 해결했기 때문에 신경쓰지 않아도 된다. 2 * 2 = 4
3. A가 무게가 3인 볼링공을 선택했다면 B가 선택할 수 있는 경우의 수는 없다. 2 * 0 = 0

따라서 경우의 수는 8가지가 나온다.

<br>

문제 풀이는 이와 같다.

1. 무게마다 몇 개의 볼링공이 있는지 확인해야 하기 때문에 입력 값을 인덱스로 삼아 그 인덱스에 해당하는 배열의 값을 증가시킨다.
2. 볼링공이 존재하는 수 N에서 현재 선택한 볼링공의 수만큼 빼준다.
3. answer에 N과 현재 선택한 볼링공의 수를 곱한 뒤 더한다.
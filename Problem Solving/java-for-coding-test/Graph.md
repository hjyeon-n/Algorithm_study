# Graph

| 문제 이름               | 풀이 날짜  |
| ----------------------- | ---------- |
| [여행 계획](#여행-계획) | 2021.05.07 |
| [탑승구](#탑승구)       | 2021.05.14 |

<br>

<hr>

#### #여행 계획

[여행 계획 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Graph/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EC%97%AC%ED%96%89%20%EA%B3%84%ED%9A%8D.java)

여행 계획이 가능한지 여부를 확인하려면 서로 이어져 있는지 즉, 같은 집합인지를 확인해야 한다.

따라서 union-find를 사용해서 문제를 풀면 쉽게 풀 수 있다. 그 이후 여행경로가 같은 부모로 파생되는지 확인하면 된다.

정말 기본적인 문제이므로 풀이는 생략한다.

<br>

<hr>

#### #탑승구

[탑승구 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Graph/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%ED%83%91%EC%8A%B9%EA%B5%AC.java)

처음엔 문제가 이해조차 안 됐는데 나중에는 그래프 이론이니까 위상 정렬인가? 하고 끼워맞추다가 실패했다!

결론적으로 말하자면 풀이를 보고 풀었고 union-find 문제이다.

각 탑승구를 서로 다른 집합으로 나타내고 도킹하는 과정을 union을 통해서 구하면 된다. union 연산은 해당 집합과 바로 왼쪽 집합을 수행하면 된다. 이 경우 루트가 0이면 더 이상 도킹할 수 없다는 의미이기 때문에 break해서 빠져나오면 된다.

1. 탑승구의 수만큼 arr 배열을 선언한 후 값을 자기 자신으로 초기화한다.
2. 비행기의 수만큼 값을 입력 받고 Gi의 루트가 0이면 break 그렇지 않으면 Gi - 1과 union 연산을 수행한다.
3. break를 만날 때까지 위 과정을 수행하고 몇 번 수행했는지 answer에 저장해 출력한다.
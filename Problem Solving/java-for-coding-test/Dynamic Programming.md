# Dynamic Programming

| 문제 이름                        | 풀이 날짜  |
| -------------------------------- | ---------- |
| [금광](#금광)                    | 2021.05.06 |
| [정수 삼각형](#정수-삼각형)      | 2021.05.06 |
| [퇴사](#퇴사)                    | 2021.05.13 |
| [병사 배치하기](#병사-배치하기)⭐ | 2021.05.13 |
| [못생긴 수](#못생긴-수)          | 2021.05.14 |
| [편집 거리](#편집-거리)          | 2021.05.15 |

<br>

<hr>

#### #금광

[금광 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Dynamic%20Programming/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EA%B8%88%EA%B4%91.java)

정말 간만에 푼 DP 문제. DP를 어려워해서 보자마자 포기하고 싶었는데 침착하게 생각하니 문제를 풀 수 있었다! 뿌듯하다 😊

매번 오른쪽 위, 오른쪽, 오른쪽 아래로 이동할 수 있다는 말은 거꾸로 현재 위치로 오기까지 왼쪽 위, 왼쪽, 왼쪽 아래에서 진입을 했다는 것이다. 이를 토대로 코드를 짜면 된다.

문제는 금의 최대 크기를 요구하고 있기 때문에 왼쪽 위, 왼쪽, 왼쪽 아래에서 가장 큰 값을 현재 위치와 더해주면 된다.

이때, 위와 아래의 경우 범위를 벗어날 수 있으므로 첫 행에 위치할 때는 왼쪽과 왼쪽 아래만 그리고 마지막 행에 위치할 때는 왼쪽과 왼쪽 위만 고려하면 된다. 나머지는 세 가지 경우를 모두 고려한다.

<br>

<hr>

#### #정수 삼각형

[정수 삼각형 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Dynamic%20Programming/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EC%A0%95%EC%88%98%20%EC%82%BC%EA%B0%81%ED%98%95.java)

정수 삼각형 문제는 진짜 여러 번 풀었는데 한 번도 내 힘으로 처음부터 끝까지 풀어본 적이 없었다... 😥

그래서 이번에도 별 기대를 안 했는데 차분히 생각하면서 문제에 접근하니 의외로 쉽게 풀렸다! 앞으로도 이런 마음가짐으로 문제를 풀어야겠다! 😉

금광 문제와 비슷하다. 오른쪽 대각선과 왼쪽 대각선 중 큰 값을 구해 현재 값과 더해나가면 된다.

다만, 왼쪽과 오른쪽의 가장자리 부분은 주의해야 한다. 왼쪽 가장자리는 오른쪽 대각선만 고려하면 되고 반대로 오른쪽 가장자리는 왼쪽 대각선만 고려하면 되기 때문에 이 경우 큰 값을 찾을 필요 없이 더해나가면 된다.

가운데 부분은 왼쪽 대각선과 오른쪽 대각선 중 큰 값을 고려하면 된다. 이 경우도 단순히 열을 더하고 빼는 게 아니라 그림을 그리면서 올바른 인덱스를 찾는 게 좋다! 

<br>

<hr>

#### #퇴사

[퇴사 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Dynamic%20Programming/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%ED%87%B4%EC%82%AC.java)

난 dp 바보다... 😂 

예전에 풀었던 문제이고 그때도 실버4라는 믿을 수 없는 난이도에 당황했다... 삼성 SW 역량 테스트 기출이라서 난이도가 낮게 평가된 건지 원래 쉬운 문제인지는 모르겠으나 그때나 지금이나 갈피를 잡지 못했다...

그때는 풀이를 봤을 때도 뭐냐 싶었는데 그나마 지금은 이해가 된다! 예전 풀이는 [여기](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.07/Dynamic%20Programming.md#%ED%87%B4%EC%82%AC)서 참조하면 된다.

<br>

<hr>

⭐⭐⭐⭐⭐

#### #병사 배치하기

[병사 배치하기 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/tree/master/Dynamic%20Programming/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EB%B3%91%EC%82%AC%20%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0)

LIS 문제이다. LIS도 이제 스스로 풀 때가 되지 않았나 싶다 정말루...😂

최장 증가 수열 문제이기 때문에 내림차순으로 입력되는 값을 거꾸로 받아서 배열에 저장한 후, LIS를 구한 뒤 N에서 빼면 된다.

LIS에 대해서 설명하겠다! 👀 이 설명은 교재의 풀이를 참고했다! 아래와 같은 수열이 있다고 가정하자.

| 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 10   | 20   | 10   | 30   | 20   | 50   |

이때 dp 배열의 초기상태는 아래와 같다.

| 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | 1    | 1    | 1    |

<br>

끝점 즉, i의 값이 1일 때

| 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 1    | 1    | 1    | 1    |



i의 값이 2일 때

| 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 1    | 1    | 1    | 1    |



i의 값이 3일 때

| 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 1    | 3    | 1    | 1    |



i의 값이 4일 때

| 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 1    | 3    | 1    | 1    |



i의 값이 5일 때

| 0    | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 2    | 1    | 3    | 1    | 4    |

<br>

따라서 최대 길이는 4가 된다.

그리고 처음엔 난 i가 시작점이라고 생각했는데 끝점이고 끝점이 i일 때 j가 0부터 시작하면서 증가되는지 확인한다.

만약 arr[i]가 arr[j]보다 크다면 증가하고 있다는 의미이므로 dp[j] 즉, j까지의 증가 수열 길이에 1을 더한 값과 dp[i] 값을 비교한 뒤 dp[j] + 1이 더 길다면 i까지의 증가 수열 길이도 길어져야 하기 때문에 dp[i]의 값을 dp[j] + 1로 갱신한다.

<br>

<hr>

#### #못생긴 수

[못생긴 수 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/tree/master/Dynamic%20Programming/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EB%AA%BB%EC%83%9D%EA%B8%B4%20%EC%88%98)

두 가지 버전으로 풀어서 올리긴 했지만 문제에서 주어진 N이 작아서 그렇지 사실상 더 큰 수가 나오면 ver1은 터질 것 같다.

ver1 풀이

1. dp[1]을 1로 초기화하고 2부터 소인수를 체크해나간다.
2. 따라서 cnt를 2로 초기화하고 dp의 인덱스가 될 idx도 2로 초기화한다.
3. cnt의 소인수가 2, 3, 5만 존재하는지 확인하고 그렇다면 dp[idx]에 cnt를 대입한다. 그리고 idx를 늘려준다.
4. 만약 못생긴 수가 아니라면 cnt만 늘려준다.

<br>

ver2는 교재 풀이를 참고하였다.

소인수가 2, 3, 5만 존재한다는 것은 현재 못생긴 수에 2, 3 혹은 5를 곱한 값도 못생긴 수가 된다는 점을 유의해야 한다.

그래서 2, 3, 5의 배수를 오름차순으로 확인하면서 가장 작은 값을 dp에 넣어주면 된다.

1. 인덱스를 1로 초기화하고 곱셈 값도 각각 2, 3, 5로 초기화한다. 그리고 dp[1]을 1로 초기화한다.
2. 2, 3, 5의 배수 중 가장 작은 값을 dp 배열에 넣어준다.
3. 현재 dp 값이 어떤 수의 배수인지 확인하고 해당하는 배수의 크기와 인덱스를 늘려준다.

<br>

<hr>

#### #편집 거리

[편집 거리 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/tree/master/Dynamic%20Programming/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%ED%8E%B8%EC%A7%91%20%EA%B1%B0%EB%A6%AC)

두 가지 버전으로 풀었다. 일단 큰 값을 줬을 때도 터지진 않았는데 ver1 는 HashMap으로 매번 contatinsKey 연산을 수행하기 때문에 시간 복잡도상 좋을 것 같지는 않다. 

ver1 풀이

1. A의 길이만큼 반복문을 돌며 HashMap으로 문자와 문자의 수를 저장한다.
2. B의 길이만큼 반복문을 돌며 현재 위치의 문자가 HashMap에 있는지 확인하고 만약 존재하고 그 수가 1 이상이라면 수를 1만큼 빼준다. 만약 존재하지 않거나 그 수가 0이라면 answer 값을 증가시킨다.
3. answer를 출력한다.

<br>

ver2는 책 풀이를 참고하였다. 풀이를 보기 전 이렇게 문제를 풀 거라고 감히 상상도 못했다😂 이런 풀이 방법도 있다는 걸 익혀둬야겠다!

1. A의 길이를 행으로, B의 길이를 열로한 이차원 배열을 선언한다.
2. 첫 번째 행과 첫 번째 열은 i 로 초기화한다. (즉 반복인자만큼의 수로 초기화한다.)
3. 행을 기준으로 열을 탐색하면서 A의 현재 문자와 B의 문자가 일치하다면 편집 거리는 증가될 필요가 없기 때문에 왼쪽 위 값을 그대로 가져온다. dp[i] [j] = dp[i - 1] [j - 1]
4. A의 문자와 B의 문자가 일치하지 않는다면 편집 거리를 1만큼 증가시켜야 한다. 왼쪽(삽입), 위쪽(삭제), 왼쪽 위(교체)의 값 중 작은 값을 골라 1만큼 더한 뒤 대입한다. dp[i - 1] [j - 1] = Math.min(dp[i - 1] [j - 1], Math.min(dp[i - 1] [j], dp[i] [j - 1])) + 1
# Shortest Path

| 문제 이름                   | 풀이 날짜  |
| --------------------------- | ---------- |
| [정확한 순위](#정확한-순위) | 2021.05.06 |
| [숨바꼭질](#숨바꼭질)       | 2021.05.12 |
| [화성 탐사](#화성-탐사)     | 2021.05.14 |

<br>

<hr>

#### #정확한 순위

[정확한 순위 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/tree/master/Shortest%20Path/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C)

처음엔 그림만 보고 위상정렬 문제인 줄 알고 그렇게 풀다가 어떻게 순위를 확정지어야 할지 도저히 감이 잡히지 않았다.

진입차수와 진출차수가 관계가 있나 하고 고민하다가 풀이를 봤는데 최단 경로 문제였다.

예전에 BFS와 DFS 문제를 처음 풀기 시작했을 때 경로를 구하는 문제가 아니라면 도저히 감을 잡지 못하던 때가 있었다. 지금도 비슷한 시기라고 생각한다. 최단 경로를 구하는 문제일 거라고 전혀 생각 못했지만 나중엔 잘 풀 수 있겠지...? 👻

**A가 B로 도달이 가능하거나 B에서 A로 도달이 가능하면 성적 비교가 가능하다.** 반대로 둘 다 도달하지 못하는 경우엔 비교 결과를 알 수가 없다. 따라서 모든 정점에 대해서 모든 정점으로의 최단 경로를 구하기 위해 플로이드 워셜 알고리즘으로 문제를 풀면 된다.

플로이드 워셜 알고리즘 수행 후 비교 가능 여부를 판단하기 위해서 한 명씩 확인하며 도달이 가능한지 확인한다. 만약 1번부터 5번까지의 학생이 있고 4번이 정확한 순위를 갖는다면 4번에 도달하거나 4번으로부터 모두 도달이 가능해야 한다.

<br>

<hr>

#### #숨바꼭질

[숨바꼭질 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Shortest%20Path/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88.java)

1번 노드부터 시작해서 모든 정점으로의 최단거리를 구하기 위해 다익스트라 알고리즘을 구현하면 된다.

1. 그래프는 양방향 통로로 존재한다는 점을 유념하고 값을 입력 받는다.
2. 거리를 나타내는 dist 배열을 정수의 최댓값으로 초기화한다.
3. 다익스트라 알고리즘을 수행한다.
4. 최단 거리가 가장 먼 헛간을 구하기 위해 dist 배열을 순회한다. 이때 거리가 같은 헛간의 수를 구하기 위해 cnt를 선언한다.
5. answer 값보다 큰 값을 발견하면 인덱스를 나타내는 변수인 idx에 해당 인덱스를 저장하고 answer 값을 갱신한다.
6. 만약 answer 값과 동일한 값이라면 cnt를 늘려준다.

<br>

<hr>

#### #화성 탐사

[화성 탐사 소스 코드](https://github.com/hjyeon-n/java-for-coding-test/blob/master/Shortest%20Path/hjyeon-n/%EA%B8%B0%EC%B6%9C%20%EB%AC%B8%EC%A0%9C/%ED%99%94%EC%84%B1%20%ED%83%90%EC%82%AC.java)

처음에는 그냥 나올 수 있는 경우의 수로 최소 경로를 구하고자 했다.

예를 들어 i가 0이면 grph[i - 1] [0]의 값을 더해나가는 식으로 말이다. 하지만 예외가 있는지 틀린 답을 출력했다.

기존에 풀었던 방식과 달리 이동 방향이 동서남북으로만 이동이 가능했기 때문에 다익스트라 알고리즘을 어떻게 구현할지 잘 감이 잡히지 않았다. 그래서 풀이를 보고 이해하는 방식으로 풀었다.

1. 노드의 개수가 125개이므로 인접 행렬 방식으로 풀 수 있기 때문에 이차원 배열 형태의 graph를 선언한 뒤, 값을 입력 받는다. dist 배열도 정수의 최댓값으로 초기화한다.
2. 상하좌우로만 이동하면서 dist 배열 값이 다른 노드를 거쳐서 오는 거리보다 값이 큰지 확인한다. 이전에는 인접 리스트로만 풀어서 익숙하지 않아 변수의 값이 헷갈렸는데 평소 내가 nw라고 선언하는 다음 노드의 가중치 값이 graph[nx] [ny] 값으로 치환되고 마찬가지로 dist[v] 값이 현재 노드의 가중치 값이 된다.
3. 다익스트라 알고리즘을 수행한 뒤 dist[N - 1] [N - 1] 값을 출력하면 된다.
# BFS, DFS

### BFS로 푼 문제

| 문제 번호                                      | 이름                      |
| ---------------------------------------------- | ------------------------- |
| [16953](https://www.acmicpc.net/problem/16953) | [A → B](#A-→-B )          |
| [1697](https://www.acmicpc.net/problem/1697)   | [숨바꼭질 1](#숨바꼭질-)  |
| [12851](https://www.acmicpc.net/problem/12851) | [숨바꼭질 2](#숨바꼭질-2) |

<br>

### DFS로 푼 문제

| 문제 번호                                      | 이름                        |
| ---------------------------------------------- | --------------------------- |
| [2210](https://www.acmicpc.net/problem/2210)   | [숫자판 점프](#숫자판-점프) |
| [13023](https://www.acmicpc.net/problem/13023) | [ABCDE](#ABCDE)             |

<br>

<hr>

#### #A → B

[A → B 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_16953.java)

딱 실버 1 수준다운 문제였다. 급하게 푼 문제였는데 딱 생각대로 풀렸다. 예전에는 그래프 형식이 아니면 이 문제를 어떻게 풀어야 하나 감이 안 잡혔는데 이제 이런 문제는 유형이 뭔지 몰라도 대충 BFS로 풀 수준은 됐다!

역시 사람은 계속 연습하면 변하나 봐...😊

다만, 계속 연습해야 하는 부분은 냅다 풀지 말고 숫자의 범위를 잘 봐야 한다는 것! 이 문제도 처음엔 그냥 제출했다가 int 정수형 범위를 넘어서서 컴파일 에러가 났다.

1. 최솟값을 MAX_VALUE로 설정한다. bfs 후 값이 변하지 않았다면 -1, 변했다면 min 값을 출력하기 위해서다.
2. Node 클래스를 선언한다. 연산의 결과값으로 나온 값이 몇 번의 연산을 거쳤는지 동시에 확인해야 하기 때문이다.
3. HashSet은 방문 여부를 확인하기 위해서 정의한다.
4. BFS 탐색을 시작한다.
5. 만약 val이 B보다 크다면 문제에서 요구하는 2를 곱하거나 "1"을 추가하더라도 원하는 값에 도달할 수 없으므로 다시 반복문 처음부터 시작한다.
6. val이 B와 같다면 해당 결괏값에 해당하는 연산이 몇 번 이루어졌는지를 min과 비교한다.
7. 만약 val * 2의 결괏값이 전에 없는 결과였다면 큐에 넣고 방문 여부를 표시해 준다.
8. val에 "1"을 더하는 과정은 우선, 현재 val 값을 String 값으로 바꾼 뒤 ''1"을 더해 다시 숫자 값으로 바꿔준다.
9. 8번의 결괏값이 전에 나오지 않은 결과라면 큐에 넣고 방문 여부를 표시해 준다.

<br>

<hr>

#### #숫자판 점프

[숫자판 점프 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_2210.java)

정말 오랜만에 푸는 DFS 문제이다. 백트래킹 문제는 종종 풀었는데 이런 문제는 오랜만이다.

이 문제에서 중요한 조건은 "임의의 칸에서 부터 탐색을 시작한다는 점"과 "방문했던 지점을 다시 거쳐도 된다는 점"이다. 그래서 다른 DFS 문제와 달리 방문 여부를 확인할 필요가 없다.

문제 자체는 실버2 문제인 만큼 어렵지는 않다. 

1. 반복문을 돌면서 모든 점에서 탐색을 한다.
2. 탐색을 하면서 str값에 map의 값을 더하고 그 길이가 6이 되면 HashSet에 넣는다.
3. 메인으로 돌아와서 set의 사이즈를 출력한다.

<br>

이 문제 자체보다 내가 헷갈렸던 건 재귀에 대한 건데 예전에도 문제를 풀면서 왜 이렇게 되는 건지 궁금했었는데 이번에 디버깅을 돌리면서 확실히 알았다. 😎

내가 궁금해던 것은 str에 어떤 값을 계속 더해가는 거라면 

``` java
str += String.valueOf(map[nx][ny]);
dfs(nx, ny, str);
```

위와 같은 방식으로 해도 될 것 같은데 왜 에러가 나는 거지? 였다. 

``` java
dfs(nx, ny, str + String.valueOf(map[nx][ny]));
```

또한 이 코드는 제대로 작동하는 코드인데 무슨 차이가 있는지 몰랐었다.

<br>

예전에 재귀가 지금보다 훨씬 더 낯선 개념일 때 교수님이 재귀는 문을 열고 닫는 과정이라고 설명해 주신 적이 있다. 

즉, 문제의 조건처럼 str의 길이가 6까지 진행돼서 base condition에 도달한다면 거기서 끝이 아니라 내가 길이가 6이 될 때까지 계속해서 열어왔던 문들을 돌아가면서 하나씩 닫아주는 게 필요하다. 즉, "111111" 이었던 str이 "11111"로 돌아가서 다른 경우의 수가 없는지 확인해 봐야 한다.

이 과정이 2번의 코드인 경우에는 매개변수로 같이 들어가 있기 때문에 회귀가 가능하지만, 1번 코드인 경우에는 다시 돌아갈 방법이 없어진다. 즉, 문을 닫지 못하기 때문에 에러가 발생한다.

이렇게 말해놓고 또 다른 문제 풀면서 엥 이건 또 뭐야 😟 할 것 같긴 한데... 과거의 내가 이렇게 정리했다는 걸 기억이라도 해줬으면 좋겠다... 🙄

<br>

<hr>

#### #숨바꼭질 1

[숨바꼭질 1 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_1697.java)

풀기는 8월에 풀었던 문제 같은데 깃헙에서 도저히 찾을 수가 없어서 새로 올린다... 뭐지... 😕

문제는 단순하다.

1. 방문여부를 확인하기 위해 문제의 제한 조건에 맞게 100001 크기의 visited 배열을 선언한다.
2. bfs 탐색을 시작한다. (최솟값을 찾기 위해 bfs를 사용한다.) 
3. 현재 수빈이의 위치를 x라고 한다면 x + 1, x - 1, x * 2가 범위에 벗어나는지 확인한 후에 큐에 넣어준다. 그리고 방문여부를 표시한다.
4. 큐에서 빠져나온 값이 동생의 위치인 k와 같다면 break해서 큐를 빠져나온다.

<br>

오래 전에 푼 문제라서 지금 내가 다시 푼다면 달라질 만한 점이 많다. 나였으면 visited 배열 대신 HashSet을 사용하던가 하는 방식 말이다. 하지만 이 문제에서는 contains 메소드를 사용하는 것보다 바로 해당 인덱스에 접근할 수 있다는 점에서 visited 배열 방식이 더 좋을 것 같기도 하다... 😯

<br>

<hr>

#### #숨바꼭질 2

[숨바꼭질 2 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_12851.java)

숨바꼭질 1이랑 흡사하지만 이번에는 K가 됐을 때 바로 빠져나오는 게 아니라 K가 되는 방법의 수를 출력해야 한다.

1. 수빈이의 위치를 val, 그리고 val에 다다르기 위해 발생한 연산의 횟수를 cnt로 묶어 클래스를 선언해 객체로 사용한다.
2. 연산의 최소횟수를 min이라고 정의하고 Integer의 MAX_VALUE로 초기화하고, answer를ㅠ 정의해서 방법의 수를 셀 것이다.
3. 수빈이의 위치 즉, N이 0일 때부터 bfs 탐색을 시작한다. 큐에는 1번에서 정의한 객체 Location이 들어가게 된다.
4. 큐에서 값을 빼서 방문여부를 체크한다. 
5. 만약, cnt가 min보다 크다면 이미 최소 횟수는 벗어난 것이기 때문에 break한다.
6. val이 K와 같다면, min과 cnt를 비교해 만약 cnt가 더 작거나 같다면 min 값을 cnt로 초기화해 주고 answer를 하나 늘려준다.
7. 5번과 6번 조건에 해당하지 않는다면 val + 1, val - 1, val * 2에 해당하는 지점이 범위 안에 있는 수인지 확인한 후에 큐에 값을 넣어준다.
8. 메인으로 돌아와 min과 answer를 출력한다.

<br>

음... 결론적으로 말하자면 어려운 문제는 아니었고 오래 걸리지도 않았는데 메모리 초과나 시간 초과가 많이 났다... 🤦‍♀️

처음에는 큐에 넣으면서 방문여부를 체크해줬는데 그렇게 하니까 val이 K가 되는 경우는 당연히 1번밖에 없었다. set에서 중복은 허용하지 않기 때문이다. 그래서 큐는 min이 갱신되는 지점이 큰 수라면 그때까지 계속 큐에는 값이 추가되기 때문에 메모리 초과가 발생한 것 같다.

그래서 음...! HashSet을 커스텀 객체도 사용할 수 있도록 메소드를 재정의하자는 생각을 했다. 나는 val은 같되 cnt는 달라야 하는 상황에 대해 true를 반환하는 식으로 재정의했는데 시간초과가 났다...

고민하다가 풀이 방법을 찾아봤고, 방문한 후에 방문여부를 표시하는 방법이 아니라 **일단 큐에 집어넣은 후에 큐에서 값을 빼낼 때 방문 여부를 확인하는 방법**으로 풀이했더니 정답처리가 됐다. 후에 방문여부를 표시하는 문제를 풀었던 것 같은데 찾아봐도 잘 모르겠네... 나중에 찾게 되면 수정해야겠다!

<br>

<hr>

#### #ABCDE

[ABCDE 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_13023.java)

기계적으로 푼 느낌이 조금 있다... 대충 이렇게 풀면 되겠거니 생각해서 풀었고 얼추 맞았다. (시간초과는 났지만... 😂)

생각을 좀 하면서 풀어야겠다. 생각을 안 하면 굳어져버린다. 그러면 다른 유형이 나왔을 때 굳은 머리로는 풀 수 없다... 💦

친구 관계를 나타낸다고 하니 depth를 써서 풀면 되겠다고 생각했고 depth의 범위에 대해서는 깊이 생각을 안 했던 것 같다. 반성한다...

이 문제는 무엇보다 시간 초과가 몇 번이나 발생했는데 인접행렬이 아니라 인접리스트 방식으로 풀면 쉽게 풀린다.

1. 인접리스트를 선언한다. 즉, ArrayList 안에 ArrayList가 또 있는 형태이다.
2. 무방향 그래프이기 때문에 A와 B가 친구이면, B와 A도 친구임을 표시해야 한다.
3. 모든 정점에 대해 dfs 탐색을 시작한다.
4. 현재 정점에 대해 방문 표시를 해준다. 그리고 그 정점에 인접한 정점들을 찾기 위해 반복문을 사용해서 인접리스트의 크기만큼 모든 정점을 방문하고 또다시 탐색한다. 이때 answer가 true이면 답을 찾은 것이기 때문에 break해서 빠져나온다.
5. 그리고 예제 2번에서 나온 것처럼 0 - 1 - 2 - 3 으로 가다가 1 4가 나왔을 때 이미 1은 방문한 정점이기 때문에 이 친구 관계를 표시할 수가 없다. 따라서 이러한 경우까지 모두 고려해야 하기 때문에 백트래킹이 필요하다.
6. depth가 4 이상일 때 문제에서 요구하는 조건에 부합하므로 answer의 값을 true로 초기화한다. 
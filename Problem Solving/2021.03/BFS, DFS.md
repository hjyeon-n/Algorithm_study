# BFS, DFS

| 문제 번호                                      | 이름             |
| ---------------------------------------------- | ---------------- |
| [16953](https://www.acmicpc.net/problem/16953) | [A → B](#A-→-B ) |

<br>

<hr>

#### #A → B

[A → B 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_16953.java)

딱 실버 1 수준다운 문제였다. 급하게 푼 문제였는데 딱 생각대로 풀렸다. 예전에는 그래프 형식이 아니면 이 문제를 어떻게 풀어야 하나 감이 안 잡혔는데 이제 이런 문제는 유형이 뭔지 몰라도 대충 BFS로 풀 수준은 됐다!

역시 사람은 계속 연습하면 변하나 봐...😊

다만, 계속 연습해야 하는 부분은 냅다 풀지 말고 숫자의 범위를 잘 봐야 한다는 것! 이 문제도 처음엔 그냥 제출했다가 int 정수형 범위를 넘어서서 컴파일 에러가 났다.

1. 최솟값을 MAX_VALUE로 설정한다. bfs 후 값이 변하지 않았다면 -1, 변했다면 min 값을 출력하기 위해서다.
2. Node 클래스를 선언한다. 연산의 결과값으로 나온 값이 몇 번의 연산을 거쳤는지 동시에 확인해야 하기 때문이다.
3. HashSet은 방문 여부를 확인하기 위해서 정의한다.
4. BFS 탐색을 시작한다.
5. 만약 val이 B보다 크다면 문제에서 요구하는 2를 곱하거나 "1"을 추가하더라도 원하는 값에 도달할 수 없으므로 다시 반복문 처음부터 시작한다.
6. val이 B와 같다면 해당 결괏값에 해당하는 연산이 몇 번 이루어졌는지를 min과 비교한다.
7. 만약 val * 2의 결괏값이 전에 없는 결과였다면 큐에 넣고 방문 여부를 표시해 준다.
8. val에 "1"을 더하는 과정은 우선, 현재 val 값을 String 값으로 바꾼 뒤 ''1"을 더해 다시 숫자 값으로 바꿔준다.
9. 8번의 결괏값이 전에 나오지 않은 결과라면 큐에 넣고 방문 여부를 표시해 준다.
# BFS, DFS

### BFS로 푼 문제

| 문제 번호                                          | 이름                |
| ---------------------------------------------- | ----------------- |
| [16953](https://www.acmicpc.net/problem/16953) | [A → B](#A-→-B )  |
| [1697](https://www.acmicpc.net/problem/1697)   | [숨바꼭질 1](#숨바꼭질-)  |
| [12851](https://www.acmicpc.net/problem/12851) | [숨바꼭질 2](#숨바꼭질-2) |
| [17141](https://www.acmicpc.net/problem/17141) | [연구소 2](#연구소-2)   |
| [9019](https://www.acmicpc.net/problem/9019)   | [DSLR](#DSLR)     |
| [18405](https://www.acmicpc.net/problem/18405) | [경쟁적 전염](#경쟁적-전염) |

<br>

### DFS로 푼 문제

| 문제 번호                                          | 이름                |
| ---------------------------------------------- | ----------------- |
| [2210](https://www.acmicpc.net/problem/2210)   | [숫자판 점프](#숫자판-점프) |
| [13023](https://www.acmicpc.net/problem/13023) | [ABCDE](#ABCDE)   |

<br>

<hr>

#### #A → B

[A → B 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_16953.java)

딱 실버 1 수준다운 문제였다. 급하게 푼 문제였는데 딱 생각대로 풀렸다. 예전에는 그래프 형식이 아니면 이 문제를 어떻게 풀어야 하나 감이 안 잡혔는데 이제 이런 문제는 유형이 뭔지 몰라도 대충 BFS로 풀 수준은 됐다!

역시 사람은 계속 연습하면 변하나 봐...😊

다만, 계속 연습해야 하는 부분은 냅다 풀지 말고 숫자의 범위를 잘 봐야 한다는 것! 이 문제도 처음엔 그냥 제출했다가 int 정수형 범위를 넘어서서 컴파일 에러가 났다.

1. 최솟값을 MAX_VALUE로 설정한다. bfs 후 값이 변하지 않았다면 -1, 변했다면 min 값을 출력하기 위해서다.
2. Node 클래스를 선언한다. 연산의 결과값으로 나온 값이 몇 번의 연산을 거쳤는지 동시에 확인해야 하기 때문이다.
3. HashSet은 방문 여부를 확인하기 위해서 정의한다.
4. BFS 탐색을 시작한다.
5. 만약 val이 B보다 크다면 문제에서 요구하는 2를 곱하거나 "1"을 추가하더라도 원하는 값에 도달할 수 없으므로 다시 반복문 처음부터 시작한다.
6. val이 B와 같다면 해당 결괏값에 해당하는 연산이 몇 번 이루어졌는지를 min과 비교한다.
7. 만약 val * 2의 결괏값이 전에 없는 결과였다면 큐에 넣고 방문 여부를 표시해 준다.
8. val에 "1"을 더하는 과정은 우선, 현재 val 값을 String 값으로 바꾼 뒤 ''1"을 더해 다시 숫자 값으로 바꿔준다.
9. 8번의 결괏값이 전에 나오지 않은 결과라면 큐에 넣고 방문 여부를 표시해 준다.

<br>

<hr>

#### #숫자판 점프

[숫자판 점프 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_2210.java)

정말 오랜만에 푸는 DFS 문제이다. 백트래킹 문제는 종종 풀었는데 이런 문제는 오랜만이다.

이 문제에서 중요한 조건은 "임의의 칸에서 부터 탐색을 시작한다는 점"과 "방문했던 지점을 다시 거쳐도 된다는 점"이다. 그래서 다른 DFS 문제와 달리 방문 여부를 확인할 필요가 없다.

문제 자체는 실버2 문제인 만큼 어렵지는 않다. 

1. 반복문을 돌면서 모든 점에서 탐색을 한다.
2. 탐색을 하면서 str값에 map의 값을 더하고 그 길이가 6이 되면 HashSet에 넣는다.
3. 메인으로 돌아와서 set의 사이즈를 출력한다.

<br>

이 문제 자체보다 내가 헷갈렸던 건 재귀에 대한 건데 예전에도 문제를 풀면서 왜 이렇게 되는 건지 궁금했었는데 이번에 디버깅을 돌리면서 확실히 알았다. 😎

내가 궁금해던 것은 str에 어떤 값을 계속 더해가는 거라면 

```java
str += String.valueOf(map[nx][ny]);
dfs(nx, ny, str);
```

위와 같은 방식으로 해도 될 것 같은데 왜 에러가 나는 거지? 였다. 

```java
dfs(nx, ny, str + String.valueOf(map[nx][ny]));
```

또한 이 코드는 제대로 작동하는 코드인데 무슨 차이가 있는지 몰랐었다.

<br>

예전에 재귀가 지금보다 훨씬 더 낯선 개념일 때 교수님이 재귀는 문을 열고 닫는 과정이라고 설명해 주신 적이 있다. 

즉, 문제의 조건처럼 str의 길이가 6까지 진행돼서 base condition에 도달한다면 거기서 끝이 아니라 내가 길이가 6이 될 때까지 계속해서 열어왔던 문들을 돌아가면서 하나씩 닫아주는 게 필요하다. 즉, "111111" 이었던 str이 "11111"로 돌아가서 다른 경우의 수가 없는지 확인해 봐야 한다.

이 과정이 2번의 코드인 경우에는 매개변수로 같이 들어가 있기 때문에 회귀가 가능하지만, 1번 코드인 경우에는 다시 돌아갈 방법이 없어진다. 즉, 문을 닫지 못하기 때문에 에러가 발생한다.

이렇게 말해놓고 또 다른 문제 풀면서 엥 이건 또 뭐야 😟 할 것 같긴 한데... 과거의 내가 이렇게 정리했다는 걸 기억이라도 해줬으면 좋겠다... 🙄

<br>

<hr>

#### #숨바꼭질 1

[숨바꼭질 1 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_1697.java)

풀기는 8월에 풀었던 문제 같은데 깃헙에서 도저히 찾을 수가 없어서 새로 올린다... 뭐지... 😕

문제는 단순하다.

1. 방문여부를 확인하기 위해 문제의 제한 조건에 맞게 100001 크기의 visited 배열을 선언한다.
2. bfs 탐색을 시작한다. (최솟값을 찾기 위해 bfs를 사용한다.) 
3. 현재 수빈이의 위치를 x라고 한다면 x + 1, x - 1, x * 2가 범위에 벗어나는지 확인한 후에 큐에 넣어준다. 그리고 방문여부를 표시한다.
4. 큐에서 빠져나온 값이 동생의 위치인 k와 같다면 break해서 큐를 빠져나온다.

<br>

오래 전에 푼 문제라서 지금 내가 다시 푼다면 달라질 만한 점이 많다. 나였으면 visited 배열 대신 HashSet을 사용하던가 하는 방식 말이다. 하지만 이 문제에서는 contains 메소드를 사용하는 것보다 바로 해당 인덱스에 접근할 수 있다는 점에서 visited 배열 방식이 더 좋을 것 같기도 하다... 😯

<br>

<hr>

#### #숨바꼭질 2

[숨바꼭질 2 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_12851.java)

숨바꼭질 1이랑 흡사하지만 이번에는 K가 됐을 때 바로 빠져나오는 게 아니라 K가 되는 방법의 수를 출력해야 한다.

1. 수빈이의 위치를 val, 그리고 val에 다다르기 위해 발생한 연산의 횟수를 cnt로 묶어 클래스를 선언해 객체로 사용한다.
2. 연산의 최소횟수를 min이라고 정의하고 Integer의 MAX_VALUE로 초기화하고, answer를ㅠ 정의해서 방법의 수를 셀 것이다.
3. 수빈이의 위치 즉, N이 0일 때부터 bfs 탐색을 시작한다. 큐에는 1번에서 정의한 객체 Location이 들어가게 된다.
4. 큐에서 값을 빼서 방문여부를 체크한다. 
5. 만약, cnt가 min보다 크다면 이미 최소 횟수는 벗어난 것이기 때문에 break한다.
6. val이 K와 같다면, min과 cnt를 비교해 만약 cnt가 더 작거나 같다면 min 값을 cnt로 초기화해 주고 answer를 하나 늘려준다.
7. 5번과 6번 조건에 해당하지 않는다면 val + 1, val - 1, val * 2에 해당하는 지점이 범위 안에 있는 수인지 확인한 후에 큐에 값을 넣어준다.
8. 메인으로 돌아와 min과 answer를 출력한다.

<br>

음... 결론적으로 말하자면 어려운 문제는 아니었고 오래 걸리지도 않았는데 메모리 초과나 시간 초과가 많이 났다... 🤦‍♀️

처음에는 큐에 넣으면서 방문여부를 체크해줬는데 그렇게 하니까 val이 K가 되는 경우는 당연히 1번밖에 없었다. set에서 중복은 허용하지 않기 때문이다. 그래서 큐는 min이 갱신되는 지점이 큰 수라면 그때까지 계속 큐에는 값이 추가되기 때문에 메모리 초과가 발생한 것 같다.

그래서 음...! HashSet을 커스텀 객체도 사용할 수 있도록 메소드를 재정의하자는 생각을 했다. 나는 val은 같되 cnt는 달라야 하는 상황에 대해 true를 반환하는 식으로 재정의했는데 시간초과가 났다...

고민하다가 풀이 방법을 찾아봤고, 방문한 후에 방문여부를 표시하는 방법이 아니라 **일단 큐에 집어넣은 후에 큐에서 값을 빼낼 때 방문 여부를 확인하는 방법**으로 풀이했더니 정답처리가 됐다. 후에 방문여부를 표시하는 문제를 풀었던 것 같은데 찾아봐도 잘 모르겠네... 나중에 찾게 되면 수정해야겠다!

<br>

<hr>

#### #ABCDE

[ABCDE 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_13023.java)

기계적으로 푼 느낌이 조금 있다... 대충 이렇게 풀면 되겠거니 생각해서 풀었고 얼추 맞았다. (시간초과는 났지만... 😂)

생각을 좀 하면서 풀어야겠다. 생각을 안 하면 굳어져버린다. 그러면 다른 유형이 나왔을 때 굳은 머리로는 풀 수 없다... 💦

친구 관계를 나타낸다고 하니 depth를 써서 풀면 되겠다고 생각했고 depth의 범위에 대해서는 깊이 생각을 안 했던 것 같다. 반성한다...

이 문제는 무엇보다 시간 초과가 몇 번이나 발생했는데 인접행렬이 아니라 인접리스트 방식으로 풀면 쉽게 풀린다.

1. 인접리스트를 선언한다. 즉, ArrayList 안에 ArrayList가 또 있는 형태이다.
2. 무방향 그래프이기 때문에 A와 B가 친구이면, B와 A도 친구임을 표시해야 한다.
3. 모든 정점에 대해 dfs 탐색을 시작한다.
4. 현재 정점에 대해 방문 표시를 해준다. 그리고 그 정점에 인접한 정점들을 찾기 위해 반복문을 사용해서 인접리스트의 크기만큼 모든 정점을 방문하고 또다시 탐색한다. 이때 answer가 true이면 답을 찾은 것이기 때문에 break해서 빠져나온다.
5. 그리고 예제 2번에서 나온 것처럼 0 - 1 - 2 - 3 으로 가다가 1 4가 나왔을 때 이미 1은 방문한 정점이기 때문에 이 친구 관계를 표시할 수가 없다. 따라서 이러한 경우까지 모두 고려해야 하기 때문에 백트래킹이 필요하다.
6. depth가 4 이상일 때 문제에서 요구하는 조건에 부합하므로 answer의 값을 true로 초기화한다. 

<br>

<hr>

#### #연구소 2

[연구소 2 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_17141.java)

인덱스 조정 잘못해서 2시간 날렸다...^^... 정신 똑바로 차리자 젭발...😂

보자마자 조합 + BFS로 풀어야겠다고 생각했다. 이때 조합은 DFS를 사용했다.

1. 값을 입력 받으면서 바이러스를 놓을 수 있는 2의 개수를 세고 locList에 좌표를 추가한다.
2. list의 size가 n이 되고 바이러스의 개수를 m이라고 해서 조합을 구한다.
3. base condition에서는 바이러스를 놓을 수 있는 경우의 수를 int형 배열에 담아 rslt 리스트에 추가한다.
4. 조합을 통해 모든 경우의 수를 구한 뒤, rslt의 크기만큼 반복문을 돌면서 모든 경우를 고려한다.
5. 큐와 visited 배열을 초기화한다. 이때, map을 복사한 copy를 선언한다.
6. virus 함수를 호출해 경우의 수 즉, list의 인덱스가 될 idx에서 값을 하나씩 빼서 map에 바이러스를 표시한다. (-1로 표시했다.) 방문 여부를 표시하고 큐에도 값을 삽입한다.
7. spread 함수를 호출해서 bfs 탐색을 한다. 벽이 아닐 경우엔 모두 바이러스를 퍼뜨린다.
8. 탐색이 끝날 때마다 바이러스를 퍼뜨리는 데 걸린 최장 시간인 max와 min (max 중에 가장 최솟값을 구해야 함)을 비교한 뒤 min을 갱신한다.
9. min을 출력한다.

<br>

처음 생각한대로 결국 풀렸다... 자잘한 실수가 있었지만... 이걸 잘했다고 해야 할지 말아야 할지 모르겠다😥 그래도 알고리즘은 맞아서 다행이다!

<br>

<hr>

#### #DSLR

[DSLR 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_9019.java)

시간초과가 엄청 났던 문제이다. 그래도 어려운 문제는 아니었다...

시간초과가 난 이유는 

1. R과 L 회전을 arr로 만들어서 자릿수를 이동시키는 방식으로 진행
2. visited 배열 대신 Set 사용

1번이 제일 큰 문제 요인이라고 생각한다. 자릿수를 다 탐색을 해야 하고 이 과정을 B랑 같은 값이 나올 때까지 반복하므로 시간초과가 날 확률이 크다.

2번의 경우에도 시간초과 확률이 크다. visited 배열을 사용하면 바로 그 값에 접근해서 방문 여부를 확인할 수 있는데 Set의 경우엔 Set에 있는 값들을 탐색해서 찾아야 한다.

<br>

따라서 1번의 경우엔 수식으로 해결하고 2번은 visited 배열을 사용했다.

수식에 대해서 더 설명해 보자면 **자릿수**임을 잘 생각해야 한다.

L의 경우 첫 번째 자리가 맨 마지막에 붙는 모양을 한다. 나는 substring을 사용해서 문자열 연산을 통해서 풀기도 했으나 234의 경우 왼편으로 회전하면 2340이 나온다는 점을 간과했기 때문에 틀렸을 것이다. 

```java
L = (val % 1000) * 10 + val / 1000
```

``val % 1000``을 하게 되면 어차피 val은 자릿수가 4개로 고정돼 있기 때문에 두 번째 자릿수부터 네 번째 자릿수까지 나오게 될 것이다. 그리고 그 수에 10을 곱해 자릿수를 상승시켜주고 ``val / 1000 ``즉, 첫 번째 값을 더해서 맨 마지막으로 위치 시킨다.

<br>

R의 경우엔 마지막 자리가 첫 번째 자리로 붙는 모양이다. 

```java
R = (val % 10) * 1000 + val / 10
```

``val %10``을 하게 되면 val의 첫 번째 자리가 나오게 되고 거기에 1000을 곱해 맨처음으로 자리를 이동시킨다. 나머지 값들은 `val / 10`을 이용해서 구한 뒤 더해준다.

<br>

나머지는 단순 BFS이기 때문에 풀이는 생략한다!

<br>

<hr>

#### #경쟁적 전염

[경쟁적 전염 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/BOJ/2021.03/Solution_18405)

📌 2023.01.06 업데이트

이번엔 우선순위 큐로 풀었는데 이전엔 그냥 큐로 풀었었네... 

그땐 실버1이었는데 골드5로 난이도가 올라갔다. 골드는 왜 어려워하는지 모르겠다고 했는데 사실 그냥 골드레벨이라서 그냥 겁 먹고 못 풀었던 것 같네...ㅎ 골드 레벨도 쉽다고 잘만 풀었구나. 앞으로도 쫄지 말고 그냥 풀어야겠다...!

이번엔 Node 객체에 map의 값인 s와 시간을 의미하는 t도 변수에 추가해서 풀었고, 우선순위 큐를 이용했으며 기준 정렬은 t로 우선 정렬 뒤 s로 정렬해서 풀었다.

예전 코드를 보니 그냥 큐로 풀었기 때문에 입력 값을 리스트에 저장한 후에 map 값을 기준으로 정렬하고 이 값들을 다시 큐에 넣어서 풀었었다. 사실 이 풀이가 더 좋을 것 같다. 실행시간도 이 방법이 더 단축된다. 그래도 우선순위 큐도 이용해 보고 잘했다고 생각한다...😌

<br>

<u>✍ 여기서부터 이전 풀이!</u>

실버1의 쉬운 문제. 실버1은 쉬운데 왜 바로 윗단계인 골드5는 어려워 하는가... 미스터리다. 😯

이번에는 두 가지 방법으로 풀어봤다. 첫 번째 방법은 큐의 사이즈만큼 BFS, 두 번째 방법은 Node 객체에 t라는 변수를 추가해서 푸는 방법이다. 보통 2번의 방법으로 풀이하는데 1번의 방법도 도전해봤다!

공통 부분

1. 값이 작은 바이러스부터 탐색을 시작해야 하기 때문에 map을 입력 받으면서 바이러스 중 최솟값을 min으로 저장한다.
2. order는 순서를 저장하는 변수로 min부터 하나씩 증가하면서 해당하는 값에 대한 바이러스를 큐에 넣는다.
3. 만약 order가 바이러스 중 가장 큰 값인 K를 만났을 때 BFS 탐색을 시작한다.

<br>

첫 번째 방법

1. S만큼만 진행해야 하기 때문에 시간을 저장하는 변수 t를 선언하고 1부터 시작한다. (처음 소요 시간이 1초이기 때문이다.)
2. t가 S보다 작거나 같은 경우에만 진행되도록 큰 반복문을 만든다.
3. 1초당 퍼진 바이러스의 개수를 알아내기 위해 큐의 사이즈만큼 탐색을 한다. 
4. t를 늘려 1초가 지났음을 표시한다.

<br>

두 번째 방법

1. map의 위치를 저장하는 Node 클래스에 시간을 저장하는 t 변수를 선언한다.
2. 큐가 빌 때까지 진행하도록 while문을 만든다.
3. 큐에서 값을 빼냈을 때 t의 값이 S와 같다면 S만큼 시간이 시간이 지난 것이고 문제에서 원하는 조건이기 때문에 break해서 BFS 함수를 빠져나온다.

<br>

첫 번째 방법은 344ms, 두 번째 방법은 340ms가 소요되었다. 비슷한 소요시간이지만 첫 번째 시간 복잡도는 O^3, 두 번째 시간 복잡도는 O^2라서 두 번째 방법을 쓰는 게 좋을 것 같다! 👀

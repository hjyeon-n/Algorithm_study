# BFS, DFS

| 문제 번호                                      | 이름                        |
| ---------------------------------------------- | --------------------------- |
| [16953](https://www.acmicpc.net/problem/16953) | [A → B](#A-→-B )            |
| [2210](https://www.acmicpc.net/problem/2210)   | [숫자판 점프](#숫자판-점프) |

<br>

<hr>

#### #A → B

[A → B 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_16953.java)

딱 실버 1 수준다운 문제였다. 급하게 푼 문제였는데 딱 생각대로 풀렸다. 예전에는 그래프 형식이 아니면 이 문제를 어떻게 풀어야 하나 감이 안 잡혔는데 이제 이런 문제는 유형이 뭔지 몰라도 대충 BFS로 풀 수준은 됐다!

역시 사람은 계속 연습하면 변하나 봐...😊

다만, 계속 연습해야 하는 부분은 냅다 풀지 말고 숫자의 범위를 잘 봐야 한다는 것! 이 문제도 처음엔 그냥 제출했다가 int 정수형 범위를 넘어서서 컴파일 에러가 났다.

1. 최솟값을 MAX_VALUE로 설정한다. bfs 후 값이 변하지 않았다면 -1, 변했다면 min 값을 출력하기 위해서다.
2. Node 클래스를 선언한다. 연산의 결과값으로 나온 값이 몇 번의 연산을 거쳤는지 동시에 확인해야 하기 때문이다.
3. HashSet은 방문 여부를 확인하기 위해서 정의한다.
4. BFS 탐색을 시작한다.
5. 만약 val이 B보다 크다면 문제에서 요구하는 2를 곱하거나 "1"을 추가하더라도 원하는 값에 도달할 수 없으므로 다시 반복문 처음부터 시작한다.
6. val이 B와 같다면 해당 결괏값에 해당하는 연산이 몇 번 이루어졌는지를 min과 비교한다.
7. 만약 val * 2의 결괏값이 전에 없는 결과였다면 큐에 넣고 방문 여부를 표시해 준다.
8. val에 "1"을 더하는 과정은 우선, 현재 val 값을 String 값으로 바꾼 뒤 ''1"을 더해 다시 숫자 값으로 바꿔준다.
9. 8번의 결괏값이 전에 나오지 않은 결과라면 큐에 넣고 방문 여부를 표시해 준다.

<br>

<hr>

#### #숫자판 점프

[숫자판 점프 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_2210.java)

정말 오랜만에 푸는 DFS 문제이다. 백트래킹 문제는 종종 풀었는데 이런 문제는 오랜만이다.

이 문제에서 중요한 조건은 "임의의 칸에서 부터 탐색을 시작한다는 점"과 "방문했던 지점을 다시 거쳐도 된다는 점"이다. 그래서 다른 DFS 문제와 달리 방문 여부를 확인할 필요가 없다.

문제 자체는 실버2 문제인 만큼 어렵지는 않다. 

1. 반복문을 돌면서 모든 점에서 탐색을 한다.
2. 탐색을 하면서 str값에 map의 값을 더하고 그 길이가 6이 되면 HashSet에 넣는다.
3. 메인으로 돌아와서 set의 사이즈를 출력한다.

<br>

이 문제 자체보다 내가 헷갈렸던 건 재귀에 대한 건데 예전에도 문제를 풀면서 왜 이렇게 되는 건지 궁금했었는데 이번에 디버깅을 돌리면서 확실히 알았다. 😎

내가 궁금해던 것은 str에 어떤 값을 계속 더해가는 거라면 

``` java
str += String.valueOf(map[nx][ny]);
dfs(nx, ny, str);
```

위와 같은 방식으로 해도 될 것 같은데 왜 에러가 나는 거지? 였다. 

``` java
dfs(nx, ny, str + String.valueOf(map[nx][ny]));
```

또한 이 코드는 제대로 작동하는 코드인데 무슨 차이가 있는지 몰랐었다.

<br>

예전에 재귀가 지금보다 훨씬 더 낯선 개념일 때 교수님이 재귀는 문을 열고 닫는 과정이라고 설명해 주신 적이 있다. 

즉, 문제의 조건처럼 str의 길이가 6까지 진행돼서 base condition에 도달한다면 거기서 끝이 아니라 내가 길이가 6이 될 때까지 계속해서 열어왔던 문들을 돌아가면서 하나씩 닫아주는 게 필요하다. 즉, "111111" 이었던 str이 "11111"로 돌아가서 다른 경우의 수가 없는지 확인해 봐야 한다.

이 과정이 2번의 코드인 경우에는 매개변수로 같이 들어가 있기 때문에 회귀가 가능하지만, 1번 코드인 경우에는 다시 돌아갈 방법이 없어진다. 즉, 문을 닫지 못하기 때문에 에러가 발생한다.

이렇게 말해놓고 또 다른 문제 풀면서 엥 이건 또 뭐야 😟 할 것 같긴 한데... 과거의 내가 이렇게 정리했다는 걸 기억이라도 해줬으면 좋겠다... 🙄
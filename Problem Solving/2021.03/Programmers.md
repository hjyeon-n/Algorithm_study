# Programmers

| 문제 번호                                                    | 문제 이름                     |
| ------------------------------------------------------------ | ----------------------------- |
| [가장 먼 노드](https://programmers.co.kr/learn/courses/30/lessons/49189) | [가장 먼 노드](#가장-먼-노드) |

<br>

<hr>

#### #가장 먼 노드

[가장 먼 노드 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2021.03/%EA%B0%80%EC%9E%A5%20%EB%A8%BC%20%EB%85%B8%EB%93%9C.java)

처음에는 DFS 문제인가 싶었는데 시작점이 1번으로 주어져있기도 하고 인접한 곳부터 순회해야 지나가는 간선의 수를 셀 수 있을 것 같아서 BFS로 풀었고, 생각한대로 잘 풀렸다!

1. 인접한 노드들을 표시하기 위해서 n + 1 크기의 이차원 배열을 선언한다. 또한, 간선의 수를 세면서 동시에 방문여부를 표시해줄 dist 배열을 선언한다.
2. 무방향 그래프이기 때문에 A와 B가 인접하다면 B도 A가 인접하다고 표시한다.
3. BFS 탐색을 시작한다.
4. 노드의 번호와 간선을 몇 개 지나쳤는지 확인하기 위해 Node 클래스를 선언한 뒤, Queue를 이 타입으로 지정한다.
5. 해당 정점을 기준으로 반복문을 활용해 인접한 노드가 있는지 만약 있다면, 방문 여부를 확인하고 dist를 정점의 cnt 값에 1을 더한 값으로 초기화 해주고 큐에도 값을 삽입한다.
6. 메인으로 돌아와 dist 배열을 오름차순으로 정렬해서 가장 마지막 값을 최댓값으로 정한다.
7. dist 배열의 끝부분부터 탐색을 시작하면서 최댓값과 같은 수가 몇 개 있는지 찾는다. 만약, 최댓값보다 작은 수가 발견된다면 나머지 수도 모두 최댓값보다 작은 수이기 때문에 break해서 빠져나온다.
8. answer를 출력한다. 
# Implementation

| 문제 번호                                      | 이름                        |
| ---------------------------------------------- | --------------------------- |
| [2304](https://www.acmicpc.net/problem/2304)   | [창고 다각형](#창고-다각형) |
| [15683](https://www.acmicpc.net/problem/15683) | [감시](#감시)⭐              |
| [17135](https://www.acmicpc.net/problem/17135) | [캐슬 디펜스](#캐슬-디펜스) |
| [1107](https://www.acmicpc.net/problem/1107)   | [리모컨](#리모컨)           |

<br>

<hr>

#### #창고 다각형

[창고 다각형 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_2304.java)

[빗물](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.09/Dynamic%20Programming.md#%EB%B9%97%EB%AC%BC)과 유사한 문제이다. 사실 거의 똑같고 이 문제가 더 쉽다. 그땐 dp로 문제를 분류했는데 사실 구현 문제이다. 

1. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.
2. 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다.

위 조건을 고려하면서 문제를 해결하기 위해서서는 오른쪽으로 가면서 현재 위치에서의 기둥의 최댓값, 왼쪽으로 가면서 현재 위치에서의 기둥의 최댓값을 구해야 한다. 따라서 이 값들을 저장할 두 배열들이 필요하다.

문제 풀이는 이와 같다.

1. 기둥의 범위는 1이상 1,000 이하이기 때문에 arr을 1001 크기의 배열로 선언한다.
2. 입력 값을 받으면서 첫 번재 값은 배열의 인덱스로 활용하고 두 번째 값은 배열의 값으로 이용한다. 이때 len이라는 정수형 변수를 선언해서 오른쪽 가장자리에 위치한 기둥의 위치를 Math 함수를 이용해서 알아낸다. 
3. 1부터 len까지 (나는 그렇게 풀지 않았으나 len을 구했던 것처럼 시작점 인덱스를 구할 수 있다.) arr 배열을 순회하면서 현재 위치에서의 최댓값을 dp_r 배열에 저장한다.
4. len부터 1까지 arr 배열을 순회하면서 현재 위치에서의 최댓값을 dp_l 배열에 저장한다.
5. 반복문을 돌면서 dp_r과 dp_l 중 최솟값을 구해 answer에 더한다.
6. answer를 출력한다.

<br>

<hr>

⭐⭐⭐⭐⭐

#### #감시

[감시 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_15683.java) 🕶

너어어무 풀기 싫어서 북마크 해뒀다가 해제했다가 난리를 치던 판에 안 풀고 냅두는 게 더 괴로워서 그냥 풀어버렸다.

사실 내 힘으로 풀었다기엔 다른 사람 풀이를 보면서 차근차근 풀었다는 게 더 맞는 말이다.

제일 어려웠던 부분은 **이전 상태를 어떻게 저장**하느냐는 거였는데, 예를 들어서 1번과 2번이 있다고 하면 1번은 네 방향의 경우의 수가 있고 2번은 두 방향의 경우의 수가 있다. 이 경우 모든 경우를 따져 봐야 하는데 이걸 백트래킹으로 해야 하나 싶었는데 도저히 어떻게 해야 할지 감이 잡히지 않았다. 🤯

그래서 차라리 다른 사람 풀이를 보고 푼 뒤, 디버깅하면서 어떻게 문제를 해결해 나가야 할지 감을 잡는 게 좋을 것 같아서 그렇게 했다.

이 문제는 재귀의 성격을 잘 이해해야 풀 수 있다. 반복문이 끝나기 전에 또 자기 자신을 호출하게 되면 다음 인덱스로 넘어가게 되는데 이 때 문을 열고 새로운 함수로 들어간다고 생각하면 된다. 그리고 base condition에서 일을 마치면 열어두었던 문을 하나씩 닫고 나온다. **그리하여 첫 번째로 열었던 문을 닫으면, 아직 반복문이 남아있기 때문에 다시 반복한다는 점을 꼭! 알아야 한다.** (사실 이해는 쉬운데 이렇게 작성하기란 정말 어려운 것 같다... 😫)

1. 1부터 5까지의 수인 경우, cctv이기 때문에 list에 좌표와 cctv 값을 추가해준다.
2. 그리고 0번 인덱스부터 재귀를 시작하게 된다. 이때 이전 상태값을 저장하는 prev 배열은 처음에 입력값을 받았던 map을 그대로 넘겨준다.
3. list에서 idx에 해당하는 값을 가지고 와서 몇 번 cctv인지에 따라 switch문으로 조건 분기해준다.
4. 각 케이스에서는 prev의 복사본인 tmp를 정의하고 이 값의 감시 범위를 체크하기 위해서 traversal 함수로 이동한다.
5. traversal 함수는 4방향으로 구성되어있다. 함수 매개변수에 해당하는 값을 기준으로 분기하여 감시 범위를 체크한다.
6. 다시 solution 함수로 돌아와서 idx 값에 1을 증가시켜 재귀 호출한다.
7. 만약 idx가 list의 크기 즉, cctv 전체에 대해서 확인해 봤다면 사각지대 범위를 체크한다. 그리고 그 값을 answer와 비교하여 작은 값을 answer로 초기화한다.
8. 메인으로 돌아와 answer를 출력한다.

<br>

이 문제의 키포인트는 사실 traversal의 매개변수를 어떻게 넘겨주냐에 달려있다.

![image](https://user-images.githubusercontent.com/62419307/111070368-cd970a00-8514-11eb-861b-1d738355273b.png)

1번은 총 4방향의 경우의 수를 가지고 차례대로 하나씩 서, 북, 동, 남으로 진행하면 된다.

``` java
traversal(tmp, x, y, k);
```

<br>

![image](https://user-images.githubusercontent.com/62419307/111070471-44cc9e00-8515-11eb-9fd5-b2ef11cd4db4.png)

2번 CCTV는 두 방향의 경우의 수가 존재하며, 서동, 북남으로 두 방향씩 진행하면 된다.

```java
traversal(tmp, x, y, k);
traversal(tmp, x, y, k + 2);
```

<br>

![image](https://user-images.githubusercontent.com/62419307/111070411-f61f0400-8514-11eb-8b17-36bef78c5d61.png)

3번 CCTV는 네 방향으로 회전이 가능하며, 서북 / 북동 / 동남 / 남서로 두 방향씩 진행하면 된다. 이때 인덱스가 벗어날 수도 있기 때문에 mod 연산을 사용한다. 예를 들어 k가 3일 때 k + 1이 4이기 때문에 인덱스 에러가 날 수 있다. 따라서 방향의 크기 즉, 동서남북인 4의 길이로 mod 연산을 하면 k는 3과 0 그러니까 남과 서 방향임을 알 수 있다.

``` java
traversal(tmp, x, y, k);
traversal(tmp, x, y, (k + 1) % 4);
```

<br>

![image](https://user-images.githubusercontent.com/62419307/111070903-249dde80-8517-11eb-9711-a3d8eef722bd.png)

4번 CCTV도 네 방향으로 회전이 가능하면 서북동 / 북동남 / 동남서 / 남서북 으로 세 방향씩 진행하면 된다. 마찬가지로 mod 연산을 사용해 인덱스를 조정해준다.

``` java
traversal(tmp, x, y, k);
traversal(tmp, x, y, (k + 1) % 4);
traversal(tmp, x, y, (k + 2) % 4);
```

<br>

![image](https://user-images.githubusercontent.com/62419307/111070880-0f28b480-8517-11eb-840d-963b2bc2f9dc.png)

5번 CCTV는 한 방향만 가능하다. 동시에 네 방향을 탐색하면 된다.

``` java
traversal(tmp, x, y, 0);
traversal(tmp, x, y, 1);
traversal(tmp, x, y, 2);
traversal(tmp, x, y, 3);
```

<br>

<hr>

#### #캐슬 디펜스

[캐슬 디펜스 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_17135.java)

와... 정말 하루종일 풀었다...^^.... 어려운 문제는 아니다. 잘못 접근해서 하루를 날렸다...🤯

뻘짓을 너무나도 많이 했다...🤦‍♀️ 하... 처음부터 문제를 잘못 읽었는데 그건 시작에 불과했다...

제일 시간을 많이 잡아먹은 건 위치 계산이었다. 다행히 예전에 [Puyo Puyo](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.09/BFS%2C%20DFS.md#Puyo-Puyo) 같은 문제를 풀었어서 **한 턴에 동시에 공격한다는 조건**은 어렵지 않게 해결했다.

1. 궁수의 위치는 N과 M 중에서 큰 값을 골라 그 값에서 3개를 고르는 방식 즉, 조합으로 궁수의 위치의 모든 경우의 수를 구한다.
2. 1번의 조합에서 경우의 수를 구할 때마다 int형 배열을 담는 list에 배열을 추가한다.
3. list의 크기 즉, 경우의 수만큼 제거할 수 있는 적의 최댓값을 구한다.
4. deepcopy로 map을 copy 배열에 복사한다. 그리고 list에서 배열을 꺼내서 탐색을 시작한다.
5. 적이 남아있는지 check 함수로 확인한다. 만약, 하나라도 1의 값을 가진다면 false를 반환한다.
6. **동시에 공격**한다는 조건 때문에 alive라는 2차원 배열을 둬서 바로 제거하지 않고 턴이 끝날 때 제거가 되도록 한다.
7. kill 함수에서는 거리를 측정해서 제거할 수 있는 적을 찾는다. 이때 중요한 건 **거리가 가까울수록, 또한 거리가 같다면 왼쪽부터** 제거해야 한다는 점이다. 
8. map의 마지막행부터 차례대로 거리를 측정하고 현재 min 값보다 작거나 같고 D 값보다 작은지 확인한다.
9. 만약, min값과 거리 값인 dist 값이 같고 현재 위치의 j 값이 y보다 작다면 즉 더 왼쪽에 위치한다면 위치를 새로 갱신해 준다.
10. dist가 min보다 작다면 현재 위치로 위치를 새로 갱신한다.
11. min값을 초기화한다.
12. 만약 y 값이 archer와 같다면 이전에 y 값이 archer보다 작을 때는 거리 값이 더 컸다는 의미이기 때문에 archer 값이 제일 왼쪽에 위치한 값이며 더 볼 필요도 없기 때문에 alive 값을 체크한 후 true를 반환한다.
13. min이 N이면 제거할 수 있는 적이 없다는 뜻이므로 false를 반환한다. 만약 alive 값이 false라면 그 값을 true로 체크하고 true를 반환한다.
14. true를 반환하면 제거할 수 있는 적이 있다는 의미이기 때문에 enemy를 1 증가시킨다.
15. alive 배열을 확인해 제거한 적을 표시하는 remove를 호출한다.
16. 적을 한 칸 아래로 이동하는 remake를 호출한다.
17. max 값과 enemy 값을 비교한 뒤 더 큰 값을 max로 갱신한다.
18. 위 과정이 다 끝나면 max를 출력한다.

<br>

거리를 측정할 때 처음에는 무슨 생각으로 그랬는지는 모르겠지만... 😫

한 행씩 체크해 보되, 궁수의 바로 윗칸은 제일 가까운 위치기 때문에 break 하고... 또 궁수 칸을 중심으로 왼쪽과 오른쪽을 둘다 체크해 보는 과정을 거쳤다. 물론 이 방법은 틀렸다! 

![image](https://user-images.githubusercontent.com/62419307/111172933-95adc680-85e9-11eb-9d61-9bd462cf6e43.png)

왼쪽과 같은 그림이 있을 때 정답은 오른쪽이어야 한다. 하지만 이전에 내 방식대로 한다면,

![image](https://user-images.githubusercontent.com/62419307/111173154-c42ba180-85e9-11eb-9c30-2e509c8f4080.png)

이런 모양으로 똑같은 거리에 더 왼쪽 방향에 제거할 적이 있지만 제거하지 않고 넘어가버렸다. 

그래서 다음 방식으로는 마지막 행부터 왼쪽부터 오른쪽까지 순서대로 보되, min 값과 위치를 기억할 x, y를 둬서 문제를 풀었다.

사실 이렇게 풀고 겨우 반례를 모두 통과한 뒤, 런타임 에러가 발생했다... 이땐 진짜 어이없어서 소리 질렀다.😂

조합에서 실수한 거였는데 1번의 풀이처럼 풀고나서 겨우 통과됐다!! 구현 문제는 어려운 건 아니지만 너무 오래 걸려서 큰일이다...💦

<br>

<hr>

#### #리모컨

[리모컨 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_1107.java)

문제를 보고 설마... 아무리 문제 분류가 브루트포스라지만 정말 0부터 확인해 보는 건 아니겠지 싶어서 greedy하게 풀고 bfs로 +와 -를 이용해서 최소 횟수를 구하고자 했다. 물론 실패...! 😂

그러기엔 반례가 너어어어무 많아서 이렇게 할 바에 0부터 하겠다 싶어서 풀었고 정답이었다. 🙄

사실 친구가 0부터 푸는 게 낫다고 힌트를 줘서 그렇게 풀었지 아니었으면 정말 오랫동안 greedy를 잡고 있었을 것 같다.

1. N이 100이면 현재 위치도 100이기 때문에 0을 출력하고 끝낸다.
2. 최솟값을 시작 위치인 100에서 N까지의 차이를 절댓값으로 묶어 (+나 -로 접근할 수 있기 때문에) min을 초기화한다.
3. M이 0일 때는 모든 버튼을 사용할 수 있다. 이때 버튼으로도 그냥 접근할 수 있지만 101과 같은 수는 버튼을 3번 누르는 것보다 + 버튼을 누르면 바로 이동할 수 있기 때문에 N의 길이와 min을 비교해서 더 작은 값을 출력한다.
4. 고장난 버튼을 list에 저장한다.
5. 0부터 백만까지 i를 1씩 증가시키면서 min을 갱신한다. 이때, 백만까지 가는 이유는 N이 50000 일 때, 사용할 수 있는 버튼이 7이라면 77777이고 따라서 N이 가능한 범위의 2배까지는 전부 탐색해 봐야 하기 때문이다.
6. check 함수를 호출해 고장난 버튼이 포함됐는지 확인한다. 이때 리스트의 contains 함수를 활용한다.
7. check가 true라면 현재 i와 N 값의 차이에 i의 길이(즉, 버튼을 누른 횟수)를 더해 min 값과 비교한다.
8. min을 출력한다.
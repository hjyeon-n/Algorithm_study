# Implementation

| 문제 번호                                      | 이름                        |
| ---------------------------------------------- | --------------------------- |
| [2304](https://www.acmicpc.net/problem/2304)   | [창고 다각형](#창고-다각형) |
| [15683](https://www.acmicpc.net/problem/15683) | [감시](#감시)⭐              |

<br>

<hr>

#### #창고 다각형

[창고 다각형 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_2304.java)

[빗물](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.09/Dynamic%20Programming.md#%EB%B9%97%EB%AC%BC)과 유사한 문제이다. 사실 거의 똑같고 이 문제가 더 쉽다. 그땐 dp로 문제를 분류했는데 사실 구현 문제이다. 

1. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.
2. 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다.

위 조건을 고려하면서 문제를 해결하기 위해서서는 오른쪽으로 가면서 현재 위치에서의 기둥의 최댓값, 왼쪽으로 가면서 현재 위치에서의 기둥의 최댓값을 구해야 한다. 따라서 이 값들을 저장할 두 배열들이 필요하다.

문제 풀이는 이와 같다.

1. 기둥의 범위는 1이상 1,000 이하이기 때문에 arr을 1001 크기의 배열로 선언한다.
2. 입력 값을 받으면서 첫 번재 값은 배열의 인덱스로 활용하고 두 번째 값은 배열의 값으로 이용한다. 이때 len이라는 정수형 변수를 선언해서 오른쪽 가장자리에 위치한 기둥의 위치를 Math 함수를 이용해서 알아낸다. 
3. 1부터 len까지 (나는 그렇게 풀지 않았으나 len을 구했던 것처럼 시작점 인덱스를 구할 수 있다.) arr 배열을 순회하면서 현재 위치에서의 최댓값을 dp_r 배열에 저장한다.
4. len부터 1까지 arr 배열을 순회하면서 현재 위치에서의 최댓값을 dp_l 배열에 저장한다.
5. 반복문을 돌면서 dp_r과 dp_l 중 최솟값을 구해 answer에 더한다.
6. answer를 출력한다.

<br>

<hr>

⭐⭐⭐⭐⭐

#### #감시

[감시 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_15683.java) 🕶

너어어무 풀기 싫어서 북마크 해뒀다가 해제했다가 난리를 치던 판에 안 풀고 냅두는 게 더 괴로워서 그냥 풀어버렸다.

사실 내 힘으로 풀었다기엔 다른 사람 풀이를 보면서 차근차근 풀었다는 게 더 맞는 말이다.

제일 어려웠던 부분은 **이전 상태를 어떻게 저장**하느냐는 거였는데, 예를 들어서 1번과 2번이 있다고 하면 1번은 네 방향의 경우의 수가 있고 2번은 두 방향의 경우의 수가 있다. 이 경우 모든 경우를 따져 봐야 하는데 이걸 백트래킹으로 해야 하나 싶었는데 도저히 어떻게 해야 할지 감이 잡히지 않았다. 🤯

그래서 차라리 다른 사람 풀이를 보고 푼 뒤, 디버깅하면서 어떻게 문제를 해결해 나가야 할지 감을 잡는 게 좋을 것 같아서 그렇게 했다.

이 문제는 재귀의 성격을 잘 이해해야 풀 수 있다. 반복문이 끝나기 전에 또 자기 자신을 호출하게 되면 다음 인덱스로 넘어가게 되는데 이 때 문을 열고 새로운 함수로 들어간다고 생각하면 된다. 그리고 base condition에서 일을 마치면 열어두었던 문을 하나씩 닫고 나온다. **그리하여 첫 번째로 열었던 문을 닫으면, 아직 반복문이 남아있기 때문에 다시 반복한다는 점을 꼭! 알아야 한다.** (사실 이해는 쉬운데 이렇게 작성하기란 정말 어려운 것 같다... 😫)

1. 1부터 5까지의 수인 경우, cctv이기 때문에 list에 좌표와 cctv 값을 추가해준다.
2. 그리고 0번 인덱스부터 재귀를 시작하게 된다. 이때 이전 상태값을 저장하는 prev 배열은 처음에 입력값을 받았던 map을 그대로 넘겨준다.
3. list에서 idx에 해당하는 값을 가지고 와서 몇 번 cctv인지에 따라 switch문으로 조건 분기해준다.
4. 각 케이스에서는 prev의 복사본인 tmp를 정의하고 이 값의 감시 범위를 체크하기 위해서 traversal 함수로 이동한다.
5. traversal 함수는 4방향으로 구성되어있다. 함수 매개변수에 해당하는 값을 기준으로 분기하여 감시 범위를 체크한다.
6. 다시 solution 함수로 돌아와서 idx 값에 1을 증가시켜 재귀 호출한다.
7. 만약 idx가 list의 크기 즉, cctv 전체에 대해서 확인해 봤다면 사각지대 범위를 체크한다. 그리고 그 값을 answer와 비교하여 작은 값을 answer로 초기화한다.
8. 메인으로 돌아와 answer를 출력한다.

<br>

이 문제의 키포인트는 사실 traversal의 매개변수를 어떻게 넘겨주냐에 달려있다.

![image](https://user-images.githubusercontent.com/62419307/111070368-cd970a00-8514-11eb-861b-1d738355273b.png)

1번은 총 4방향의 경우의 수를 가지고 차례대로 하나씩 서, 북, 동, 남으로 진행하면 된다.

``` java
traversal(tmp, x, y, k);
```

<br>

![image](https://user-images.githubusercontent.com/62419307/111070471-44cc9e00-8515-11eb-9fd5-b2ef11cd4db4.png)

2번 CCTV는 두 방향의 경우의 수가 존재하며, 서동, 북남으로 두 방향씩 진행하면 된다.

```java
traversal(tmp, x, y, k);
traversal(tmp, x, y, k + 2);
```

<br>

![image](https://user-images.githubusercontent.com/62419307/111070411-f61f0400-8514-11eb-8b17-36bef78c5d61.png)

3번 CCTV는 네 방향으로 회전이 가능하며, 서북 / 북동 / 동남 / 남서로 두 방향씩 진행하면 된다. 이때 인덱스가 벗어날 수도 있기 때문에 mod 연산을 사용한다. 예를 들어 k가 3일 때 k + 1이 4이기 때문에 인덱스 에러가 날 수 있다. 따라서 방향의 크기 즉, 동서남북인 4의 길이로 mod 연산을 하면 k는 3과 0 그러니까 남과 서 방향임을 알 수 있다.

``` java
traversal(tmp, x, y, k);
traversal(tmp, x, y, (k + 1) % 4);
```

<br>

![image](https://user-images.githubusercontent.com/62419307/111070903-249dde80-8517-11eb-9711-a3d8eef722bd.png)

4번 CCTV도 네 방향으로 회전이 가능하면 서북동 / 북동남 / 동남서 / 남서북 으로 세 방향씩 진행하면 된다. 마찬가지로 mod 연산을 사용해 인덱스를 조정해준다.

``` java
traversal(tmp, x, y, k);
traversal(tmp, x, y, (k + 1) % 4);
traversal(tmp, x, y, (k + 2) % 4);
```

<br>

![image](https://user-images.githubusercontent.com/62419307/111070880-0f28b480-8517-11eb-840d-963b2bc2f9dc.png)

5번 CCTV는 한 방향만 가능하다. 동시에 네 방향을 탐색하면 된다.

``` java
traversal(tmp, x, y, 0);
traversal(tmp, x, y, 1);
traversal(tmp, x, y, 2);
traversal(tmp, x, y, 3);
```


# Implementation

| 문제 번호                                    | 이름                        |
| -------------------------------------------- | --------------------------- |
| [2304](https://www.acmicpc.net/problem/2304) | [창고 다각형](#창고-다각형) |

<br>

<hr>

#### #창고 다각형

[창고 다각형 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2021.03/Solution_2304.java)

[빗물](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.09/Dynamic%20Programming.md#%EB%B9%97%EB%AC%BC)과 유사한 문제이다. 사실 거의 똑같고 이 문제가 더 쉽다. 그땐 dp로 문제를 분류했는데 사실 구현 문제이다. 

1. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.
2. 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다.

위 조건을 고려하면서 문제를 해결하기 위해서서는 오른쪽으로 가면서 현재 위치에서의 기둥의 최댓값, 왼쪽으로 가면서 현재 위치에서의 기둥의 최댓값을 구해야 한다. 따라서 이 값들을 저장할 두 배열들이 필요하다.

문제 풀이는 이와 같다.

1. 기둥의 범위는 1이상 1,000 이하이기 때문에 arr을 1001 크기의 배열로 선언한다.
2. 입력 값을 받으면서 첫 번재 값은 배열의 인덱스로 활용하고 두 번째 값은 배열의 값으로 이용한다. 이때 len이라는 정수형 변수를 선언해서 오른쪽 가장자리에 위치한 기둥의 위치를 Math 함수를 이용해서 알아낸다. 
3. 1부터 len까지 (나는 그렇게 풀지 않았으나 len을 구했던 것처럼 시작점 인덱스를 구할 수 있다.) arr 배열을 순회하면서 현재 위치에서의 최댓값을 dp_r 배열에 저장한다.
4. len부터 1까지 arr 배열을 순회하면서 현재 위치에서의 최댓값을 dp_l 배열에 저장한다.
5. 반복문을 돌면서 dp_r과 dp_l 중 최솟값을 구해 answer에 더한다.
6. answer를 출력한다.
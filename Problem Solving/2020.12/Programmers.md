# Programmers

| 문제 이름                                                    | 문제 링크                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [이상한 문자 만들기](#이상한-문자-만들기)                    | [이상한 문자 만들기](https://programmers.co.kr/learn/courses/30/lessons/12930) |
| [같은 숫자는 싫어](#같은-숫자는-싫어)                        | [같은 숫자는 싫어](https://programmers.co.kr/learn/courses/30/lessons/12906) |
| [문자열 내 마음대로 정렬하기](#문자열-내-마음대로-정렬하기)  | [문자열 내 마음대로 정렬하기](https://programmers.co.kr/learn/courses/30/lessons/12915) |
| [문자열 내림차순으로 배치하기](#문자열-내림차순으로-배치하기) | [문자열 내림차순으로 배치하기](https://programmers.co.kr/learn/courses/30/lessons/12917) |
| [행렬의 곱셈](#행렬의-곱셈)                                  | [행렬의 곱셈](https://programmers.co.kr/learn/courses/30/lessons/12949) |
| [최솟값 만들기](#최솟값-만들기)                              | [최솟값 만들기](https://programmers.co.kr/learn/courses/30/lessons/12941) |

<br>

<hr>

#### #이상한 문자 만들기

[이상한 문자 만들기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.12/%EC%9D%B4%EC%83%81%ED%95%9C%20%EB%AC%B8%EC%9E%90%20%EB%A7%8C%EB%93%A4%EA%B8%B0)

문제 제목 그대로 이상한 문제였다... 😵 잘못된 문제는 아니었는데 고려할 게 많은 문제였다.

처음에는 단순히 split으로 공백을 기준으로 문자열을 자르고 거기서 인덱스가 짝수인지 홀수인지 구별해서 문자를 바꿔야겠다고 생각했는데 정확성에서 65.8점을 맞고 자꾸 틀렸다. 질문을 찾아보니 **공백이 하나 이상일 경우도 고려**해야 한다고 해서 코드를 고쳤다. split을 쓰지 않고, 앞뒤의 공백을 제거하기 위해 사용한 trim도 없앴다.

1. 공백을 만날 경우를 고려해서 단순히 문자열 인덱스로 짝수 / 홀수를 구별하지 않고 idx라는 별도의 변수를 선언해서 **공백을 기준으로 다시 짝홀을 구분**하도록 한다.
2. 공백일 경우에는 idx를 0으로 초기화하고 정답이 될 answer 문자열에 공백을 더해준다.
3. 만약, 공백이 아닐 경우에는 idx를 기준으로 짝홀을 구분하고 문제 조건에 맞게 짝수는 대문자, 홀수는 소문자로 바꿔준다.

<br>

참고로, 다른 사람 풀이 중에 삼항 연산자로 깔끔하게 푼 방법도 있어서 ver2로 묶어두었다!

<br>

<hr>

#### #같은 숫자는 싫어

[같은 숫자는 싫어 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.12/%EA%B0%99%EC%9D%80%20%EC%88%AB%EC%9E%90%EB%8A%94%20%EC%8B%AB%EC%96%B4.java)

아주아주 간단한 문제였다. 알바 다녀오니 지쳐서 아무것도 하기 싫지만 이렇게라도 간단한 문제를 계속 풀어야겠다💦

처음에는 연속적인 숫자가 아니라 같은 숫자가 나오지 않으면 되는 줄 알고 단순히 contains를 써서 해결하려고 했다. (순서는 맞아야 했기 때문에 Set은 사용불가) 근데 자세히 보니 연속적으로 등장하면 안 된다길래 마찬가지로 ArrayList를 사용하되, list의 끝부분 원소를 뽑아 현재 arr 배열의 값과 비교하는 방식으로 진행했다.

풀이는 다른 사람과 비교해 봤을 때 큰 차이가 없어서 한 가지 버전으로만 업로드했다!

<br>

<hr>

#### #문자열 내 마음대로 정렬하기

[문자열 내 마음대로 정렬하기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.12/%EB%AC%B8%EC%9E%90%EC%97%B4%20%EB%82%B4%20%EB%A7%88%EC%9D%8C%EB%8C%80%EB%A1%9C%20%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0)

보자마자 comparator를 사용해서 풀어야겠다고 생각했다. 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치해야 하기 때문에 우선 오름차순으로 정렬해 주고, compartor를 사용해서 아스키 코드 값이 더 작은 값이 앞으로 오도록 즉, 오름차순으로 정렬했다.

어렵지 않게 맞은 문제였지만 다른 사람 풀이도 좋은 방법인 것 같아서 ver2로 함께 업로드했다.

ver2는 주어지는 인덱스에 해당하는 문자를 문자열의 제일 첫 부분에 붙인다. 만약, 같은 문자열이 여러 개라도 다음 글자를 기준으로 또 정렬이 되기 때문에 별도로 고려해 줄 필요는 없다. 

그리고 정렬 값을 돌려주기 위해서 정답 배열에는 첫 번째 머리 글자를 제외한 문자열(왜냐면 아까 글자를 붙였기 때문에!)을 넣어주고 반환하면 된다.

이런 방법들을 생각하다니 멋진 사람들이 정말 많다. 😜

<br>

<hr>

#### #문자열 내림차순으로 배치하기

[문자열 내림차순으로 배치하기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/tree/master/Programmers/2020.12/%EB%AC%B8%EC%9E%90%EC%97%B4%20%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C%20%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0)

은근히 신경 쓰이는 문제였다. 내림차순으로 정렬해야 했기 때문에 문자열을 정수형 배열로 바꿔주었는데 이때, int로 타입 캐스팅을 해줬다. 람다식을 쓰면 더 간단하게 풀 수 있겠지만 나는 아직 서툴러서 이렇게라도 구현했다 🙄

그리고 내림차순으로 정렬하기 위해 Integer 배열을 선언해서 사용했는데 내림차순 후, 다시 문자열로 만들어줄 때는 int형에서 다시 char형으로 변환될 수 있도록 타입캐스팅한 뒤, `String.valueOf`로 String 값으로 바꿔준 뒤 반환했다.

<br>

두 번째 버전은 다른 사람 풀이인데, 간단하기도 하고 더 직관적이어서 같이 업로드했다.

문자열을 `toCharArray()`메소드를 통해 char형 배열로 바꿔준 뒤에 이를 오름차순으로 정렬한 뒤, StringBuilder를 통해 거꾸로 뒤집어준 뒤에 반환했다.

<br>

<hr>

#### #행렬의 곱셈

[행렬의 곱셈 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.12/%ED%96%89%EB%A0%AC%EC%9D%98%20%EA%B3%B1%EC%85%88.java)

만만하게 봤던 문제인데 헷갈려서 꽤 고생했다😂

행렬 A가 m X n, 행렬 B가 n X r이라면 결과는 m x r이 돼야 한다는 규칙이 이 문제에서 아주 중요하게 적용됐다. 그리고 삼중 반복문을 사용했는데, 반복문의 조건을 이 결과 배열의 크기를 생각하면서 정해야 한다. 그리고 무엇보다 이런 문제는 머리로만 생각하지 않고 직접 행렬의 곱을 하면서 찬찬히 생각해 보는 게 좋은 것 같다.

오랜만에 레벨2 문제를 풀었는데 앞으로도 낮은 난이도여도 꾸준히 풀어봐야겠다🧐 

<br>

<hr>

#### #최솟값 만들기

[최솟값 만들기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/Programmers/2020.12/%EC%B5%9C%EC%86%9F%EA%B0%92%20%EB%A7%8C%EB%93%A4%EA%B8%B0.java)

level2라기에는 너무 쉬웠던 문제 같다. 보자마자 하나는 오름차순, 다른 배열은 내림차순해서 구하면 되겠다 싶었고 바로 정답이었다.

대신 배열을 오름차순으로 정렬한 뒤 역순으로 곱해나가도 되는 걸 처음에는 Collections의 sort 함수를 사용하려고 굳이 Integer 배열로 바꾸는 과정을 거쳤다. 다른 사람 풀이를 보고 곧바로 고치긴 했지만 이런 부차적인 과정이 필요없도록 좀 더 생각해서 코드를 짜는 연습을 해야겠다.
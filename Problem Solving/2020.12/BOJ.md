# BOJ

| 문제 번호                                    | 이름                         |
| -------------------------------------------- | ---------------------------- |
| [1057](https://www.acmicpc.net/problem/1057) | [토너먼트](#토너먼트)        |
| [1058](https://www.acmicpc.net/problem/1058) | [친구](#친구)                |
| [2668](https://www.acmicpc.net/problem/2668) | [숫자 고르기](#숫자-고르기)⭐ |
| [2615](https://www.acmicpc.net/problem/2615) | [오목](#오목)                |
| [1181](https://www.acmicpc.net/problem/1181) | [단어 정렬](#단어-정렬)      |

<br>

<hr>

#### #토너먼트

[토너먼트 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.12/Solution_1057.java)

요즘 문제를 너무 안 푼다... 😖 지금부터 문제를 많이 풀어봤자 얼마 안 될 것 같아서 이번 달은 BOJ로 풀이를 묶어봤다.

쉬운 문제라도 제발 풀어~~ 😫

<br>

간단한 문제일 거라고 생각했는데 좀 오래 걸렸다. 2로 나눠서 짝을 지어야 한다고 생각했는데, 또 주어진 번호를 제외한 다른 번호는 승부가 중요하지 않았기 때문에 굳이 또 묶어가면서 풀지 않아도 될 것 같았다.

잘 감이 잡히지 않아서 질문 게시판을 참고했고, 다행히 거기서는 바로 이해 돼서 문제를 풀었고 쉽게 맞을 수 있었다.

풀이 순서는 중요하지 않아서 정리하지 않고, 중요한 논리 부분만 정리해 보자.

<br>

만약 8강전이라고 하자. 그러면 번호를 문제와 달리 0부터 7까지 줄 수 있다. 이를 위해 문제에 주어진 숫자도 1만큼 빼준다.

(0으로 주는 이유는 2로 나누었을 때 0이 나오는 경우가 있다. 예를 들어, 1일 때는 2로 나누면 몫이 0이다. 이 경우들도 다 고려해야 하기 때문에 0부터 숫자를 부여한다 😏)

그렇게 되면 짝을 나누면 총 0, 1, 2, 3의 4가지 짝이 만들어진다. 이처럼 2를 나눠가면서 김지민과 임한수의 값이 같을 때 혹은 김지민이 짝수의 값이 나오고, 임한수가 이보다 1만큼 크다면 둘이 짝이 되기 때문에 문제에서 원하는 답이 된다.

<br>

<hr>

#### #친구

[친구 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.12/Solution_1058.java)

정말 여러가지 방식으로 풀었다...😐

처음에는 DFS로 풀었는데 이때 조건이 친구의 친구만 구해야지 그 이상은 break해야 하는 걸 잊어버리고 풀었다가 역시나 틀리고 [결혼식](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.09/Solution_5567.java)

문제랑 비슷하겠다 싶어서 BFS로 풀었는데 또 틀렸다... 그래서 마지막으로 시도한 게 플로이드 와샬!

하지만, 또 틀려서 대분노했다... 🤯 알고보니 플로이드 와샬법에 잘못 접근하고 있더라.

1. 거리가 있는 것 말고는 다른 거리는 INF로 설정해 줘야 한다.
2. 이 문제의 경우, x좌표와 y 좌표가 같을 때에 아예 고려하지 말아야 하므로 조건을 따로 두어 0을 표시한다.

오랜만에 이런 문제를 푸는 것 같다. 잊어버리면 정말 큰일이다. 앞으로도 꾸준히 문제를 풀어야겠다.

<br>

<hr>

⭐⭐⭐⭐⭐

#### #숫자 고르기

[숫자 고르기 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.12/Solution_2668.java)

[텀 프로젝트](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.11/Solution_9466.java)와 아주 비슷한 문제다. 하지만 이 문제에서는 뽑힌 정수들을 출력해야 한다. 

꽤 오랫동안 고민하다가 결국 텀 프로젝트를 참고했다. 너무 아쉽다...😢 풀이는 사실상 똑같기 때문에 생략한다.

<br>

<hr>

#### #오목

[오목 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.12/Solution_2615.java)

추억의 오목 문제다. 2학년 때 과제로 나왔었는데 그때보다는 쉬운 문제.

그래도 구현 문제라서 어렵진 않더라도 꽤 오래 걸리긴 했다. 👻 그래도 이런 구현 문제는 풀면 뿌듯하고 재밌다. 

그때나 지금이나 똑같이 육목에서 틀렸다. 주의한다고 주의했는데 현재 위치에서 **앞으로 나아가는 방향**만 신경 써준 게 원인이었다.

그래서 **반대 방향**도 똑같이 고려해 주었고, 어렵지 않게 승패를 구할 수 있었다.

가장 왼쪽 방향을 구하는 것도 `setNode`라는 별도의 함수를 구현해서 방향에 따라 가장 왼쪽 좌표를 구했다.

이 문제는 보기만 하면 대충 어떤 의미인지 알기 때문에 별도의 풀이는 생략한다! 

<br>

<hr>

#### #단어 정렬

[단어 정렬 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.12/Solution_1181.java)

최근에 풀었던 프로그래머스의 [문자열 내 마음대로 정렬하기](https://github.com/hjyeon-n/Algorithm_study/blob/master/Problem%20Solving/2020.12/Programmers.md#%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4-%EB%A7%88%EC%9D%8C%EB%8C%80%EB%A1%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0)와 비슷한 문제였다. 단, 이 문제는 문자열 길이를 중심으로 하기 때문에 더 쉬운 문제였다. 그때와 동일하게 사전 순으로 미리 정렬해 주고, compartor를 사용해서 길이를 비교한 뒤 다시 한 번 정렬해 주었다.

<br>

<hr>

#### #빙고

[빙고 소스 코드](https://github.com/hjyeon-n/Algorithm_study/blob/master/BOJ/2020.12/Solution_2578.java)

실버5의 쉬운 문제. 하지만 구현 문제이기 때문에 엄청 빨리 푼 건 아니었다. 생각할 조건이 많이 줄어들었을 뿐... 🙄

반복문이 많이 들어가고, 심지어는 4중 반복문도 있었기 때문에 시간초과가 걱정되긴 했는데 판의 크기가 작기도 했고, 실버5 문제라서 시간제한이 빡세지는 않았던 것 같다.

1. 빙고판을 우선 입력 받는다.
2. 사회자가 부르는 번호를 입력 받기 위해 1번처럼 이중반복문을 사용한다.
3. 사회자가 부르는 번호를 바로 보드판에 체크하기 위해 보드판에서 그 번호를 찾고 true 값으로 변경해 준 뒤, 빙고가 발생했는지 확인한다.
4. checkBingo 함수에서는 가로, 세로, 왼쪽 대각선, 오른쪽 대각선 모든 경우를 확인하면서 빙고가 되었는지, 빙고의 수는 몇 개인지 체크한다.
5. 이때, 대각선의 경우에는 가로, 세로와는 다르게 첫 시작이 모서리로 고정되어있기 때문에 i의 조건에 주의한다.
6. 그리고 빙고의 수가 3이 아니라 3 이상일 때 true 값을 반환하는 것도 주의한다. 하나의 체크로 두 개 이상의 빙고가 발생할 수 있기 때문이다.